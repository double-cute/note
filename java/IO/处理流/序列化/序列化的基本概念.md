# 序列化的基本概念

<br><br>

## 目录

1. [线性数据 & 立体数据（非线性数据）]()
2. [序列化的应用背景（数据传输）& 序列化的实现]()
3. [反序列化的概念和实现]()
4. [序列化的另一个重要用途：存储Java对象（持久化）]()
5. [Java对序列化/反序列化的支持]()
6. [Java序列化/反序列化的数据格式]()

<br><br>

### 一、线性数据 & 立体数据（非线性数据）：[·](#目录)

<br>

- **线性数据**：就是指**基本类型**的数据.
   - 线性数据最大的特点就是：组成其的字节 **占据一段紧凑、顺序、连续的内存空间**.
   - 说的具体一点儿，例如：
      - 一个long，在内存中它的高4字节一定和它的低4字节连续、顺序地挨在一块儿.
      - 不可能高4字节在0x10000的位置，低4字节在0x20000的位置分开存放.
   - **线性的含义** 就在于内存上的：**紧凑、顺序、连续**.

<br>

- **立体数据**：相对的，也叫**非线性数据**，即**引用类型**数据.
   - 这类数据最大的特点就是 **内容分散在内存中**，呈现**立体**的感觉.
   - 引用类型数据立体性的表现：
      1. **[引用（指针）- 对象分散]**：首先要弄清楚一个概念，引用类型数据包括：
         1. 引用本身（指针变量）.
         2. 引用指向的对象.
            - 其中，引用本身保存在内存函数栈中，而对象数据则保存在内存堆中.
            - 这两个部分分别存放在不一样的地方，这是**第一个非线性的地方**.
      2. **组合类型的多层[指针-对象分散]**：
         - 对象中可能包含其它引用类型数据，这些数据同样存在[指针-对象分散]的现象.
      3. **复杂数据结构**：对象采用一些复杂数据结构保存，如链表、树等.
         - 这从根本上导致了各个数据元素在内存中不连续、分散的特点.
         - 但从源头上讲，还是[指针-对象分散]的结果，因为 **复杂数据结构必用到引用（指针）**.

<br><br>

### 二、序列化的应用背景（数据传输）& 序列化的实现：[·](#目录)
> 序列化简单地用一句话概括就是：**将立体数据转化成线性数据**.
>
>> 实际中，就是：将类对象转换成一个byte数组.

<br>

- 在不同数据节点之间传输数据（如网络传输等）要求：
   1. 只能是字节流.
   2. 字节流必须是连续、紧凑的.
- 这就导致了**立体数据无法直接传输**，必须先进行一番处理，将其转换成线性的序列化数据才行.

<br>

- 序列化的实现：
   1. 其实就是**将引用类型数据（`引用+对象`）转化成一个紧凑而连续的字节数组**.
   2. 其中对象中可能还层层嵌套包含引用类型数据，序列化对象就是 **全部内容（层层剥开，剥到底）**.
      - 类比深拷贝clone，要将全部内容都克隆，而不仅仅是表面的指针变量（引用变量）.

<br><br>

### 三、反序列化的概念和实现：[·](#目录)
> 就是 **将序列化后的线性数据恢复成原来的立体数据**.

<br>

- 光能序列化但不能还原成原本的立体数据是没有任何意义.
   - **序列化仅仅是为了方便数据的传输.**
   - 但只有立体数据才便于各种面向对象的操作.
- 反序列化就是**将序列化后的线性数据恢复成原来的立体数据**.

<br>

- **反序列化的实现：**
   - 必然要对序列化的线性数据进行 **解析**.
   - 这就需要序列化和反序列遵从同一组规则，就如同编码和解码.
      1. 序列化就相当于编码.
      2. 反序列化就相当于解码.

<br><br>

### 四、序列化的另一个重要用途：存储Java对象（持久化） [·](#目录)
> 持久化设备，如磁盘等，不像内存那样，允许数据分散存放.

<br>

- 数据要永久存放在里面，必须要尽最大可能节省空间.
  1. 内存数据都是**用完即可覆盖**（腾出空间给其它数据），放的零散点也没关系，只要保证速度快就行了.
  2. 如果零散存放容易浪费空间（多出很多细小零碎的空间，即碎片空间）.
     - 整理碎片空间代价巨大，毕竟持久化设备速度很慢.

<br>

- 因此：
   1. 持久化Java对象就必须先序列化.
   2. 重新恢复Java对象就必须从持久化设备中反序列化.

<br><br>

### 五、Java对序列化/反序列化的支持：[·](#目录)
> 当然，这里序列化和反序列化的对象是指 **引用类型数据（指针+对象）**.
>
>> 泛指Java对象.
>>
>>> - Java要求，只要类定义了序列化和反序列化的规则，那么它的对象（**引用+对象**）就可以直接用IO流进行传输.
>>>   - 实质上这组规则就是：
>>>      1. 序列化规则：定义 立体->线性 的算法.
>>>      2. 反序列化规则：即序列化规则的逆规则，定义 线性->立体 的算法（立体->线性的逆算法）.
>>>   - 只要定义好这组规则，就可以用IO流直接传输对象，仿佛就像之前用IO流传输byte[]、char[]一样简单.

<br>

- 详细规则：
   1. 能进行序列化/反序列化的类**必须实现Serializable接口**.
   2. ObjectOutputStream、ObjectInputStream两种处理流专门用来传输Java对象数据.
      - 它俩的writeObject和readObject方法：
         1. ObjectOutputStream的writeObject：先 **序列化** 后 **输出**.
            - 自动调用对象的Serializable协议的 **序列化方法（writeObject）** 进行序列化.
         2. ObjectInputStream的readObject：先 **输入** 后 **反序列化**.
            - 自动调用对象的Serializable协议的 **反序列化方法（readObject）** 进行反序列化.
      - 可以看到**Serializable的协议方法和ObjectXxxStream的输入输出方法同名，都是writeObject和readObject**.

<br><br>

### 六、Java序列化/反序列化的数据格式：[·](#目录)
> 主要有两种：
>
> 1. 传统的Java字节码格式.
> 2. IoC环境下的XML、json格式.

<br>

**1.&nbsp; Java字节码格式：**

1. JVM字节码与机器无关，使得Java对象的传输可以轻松跨平台.
2. 这就意味着：
   1. 只要进行序列化和反序列化 **操作的主体是JVM**.
   2. 那么这两个JVM **不管在什么地方** 都可以轻松传输Java对象.
      - 完全可以是同一个JVM进程，也完全可以是两台不同机器上的JVM进程.
      - 即实现远程的两个JVM之间传输Java对象.

<br>

**2.&nbsp; IoC环境下的XML、json格式：**

> 这是序列化的一种特例.

<br>

- 现在大多数Java应用采用依赖注入（IoC）的方式为程序准备数据.
   - 即程序需要用到的Java对象都以XML、json的形式提供.
   - 这两种格式的最大特点：XML、json本身就是一种文本文件.
      - 文本文件本身就是一长串char数组，即线性的字节序列，因此：
         1. 方便存储.
         2. 方便传输.
      - XML、json格式本身就是一种国际上的标准数据传输格式，表现优秀，使用广泛.
   - 最重要的是XML、json等格式与平台无关.

<br>

- 相比Java字节码的优缺点：
   1. 优势：文本格式，清晰易懂，适合人阅读.
   2. 劣势：没有字节码紧凑，占用空间更大.

<br>

- 这种格式下序列化/反序列化的定义：
   1. 序列化：将Java对象转化成XML、json格式.
   2. 反序列化：将XML、json格式的描述数据还原成Java对象.

<br>

- **Java的IO体系本身没有提供XML、json格式的序列化和反序列化，通常需要使用第三方API.**
