# 序列化的基本概念

<br><br>

## 目录

1. []()
2. []()

<br><br>

### 一、线性数据 & 立体数据（非线性数据）：

<br>

- **线性数据**：就是指**基本类型**的数据.
   - 线性数据最大的特点就是：组成其的字节 **占据一段紧凑、顺序、连续的内存空间**.
   - 说的具体一点儿，例如：
      - 一个long，在内存中它的高4字节一定和它的低4字节连续、顺序地挨在一块儿.
      - 不可能高4字节在0x10000的位置，低4字节在0x20000的位置分开存放.
   - **线性的含义** 就在于内存上的：**紧凑、顺序、连续**.

<br>

- **立体数据**：相对的，也叫**非线性数据**，即**引用类型**数据.
   - 这类数据最大的特点就是 **内容分散在内存中**，呈现**立体**的感觉.
   - 引用类型数据立体性的表现：
      1. **[引用（指针）- 对象分散]**：首先要弄清楚一个概念，引用类型数据包括：
         1. 引用本身（指针变量）.
         2. 引用指向的对象.
            - 其中，引用本身保存在内存函数栈中，而对象数据则保存在内存堆中.
            - 这两个部分分别存放在不一样的地方，这是**第一个非线性的地方**.
      2. **组合类型的多层[指针-对象分散]**：
         - 对象中可能包含其它引用类型数据，这些数据同样存在[指针-对象分散]的现象.
      3. **复杂数据结构**：对象采用一些复杂数据结构保存，如链表、树等.
         - 这从根本上导致了各个数据元素在内存中不连续、分散的特点.
         - 但从源头上讲，还是[指针-对象分散]的结果，因为 **复杂数据结构必用到引用（指针）**.

<br><br>

### 二、序列化的应用背景（数据传输）& 序列化的实现：
> 序列化简单地用一句话概括就是：**将立体数据转化成线性数据**.
>
>> 实际中，就是：将类对象转换成一个byte数组.

<br>

- 在不同数据节点之间传输数据（如网络传输等）要求：
   1. 只能是字节流.
   2. 字节流必须是连续、紧凑的.
- 这就导致了**立体数据无法直接传输**，必须先进行一番处理，将其转换成线性的序列化数据才行.

<br>

- 序列化的实现：
   1. 其实就是**将引用类型数据（`引用+对象`）转化成一个紧凑而连续的字节数组**.
   2. 其中对象中可能还层层嵌套包含引用类型数据，序列化对象就是 **全部内容（层层剥开，剥到底）**.
      - 类比深拷贝clone，要将全部内容都克隆，而不仅仅是表面的指针变量（引用变量）.

<br><br>

### 三、反序列化：
> 就是 **将序列化后的线性数据恢复成原来的立体数据**.

<br>

- 光能序列化但不能还原成原本的立体数据是没有任何意义.
   - **序列化仅仅是为了方便数据的传输.**
   - 但只有立体数据才便于各种面向对象的操作.
- 反序列化就是**将序列化后的线性数据恢复成原来的立体数据**.

<br><br>

### 四、Java中序列化和反序列化的最广泛应用：
> 当然，这里的对象是指 **引用类型数据（指针+对象）**.

<br>

**1.&nbsp; Java对序列化/反序列化的支持：**

- Java要求，只要类定义了序列化和反序列化的规则，那么它的对象（**引用+对象**）就可以直接用IO流进行传输.
   - 实质上这组规则就是：序列化（立体->线性）、反序列化（线性->立体）.
   - 只要定义好这组规则，那么在用IO流传输的时候就无须关注底层是怎么处理的，仿佛就像之前用IO流传输byte[]、char[]一样简单.
- 这组规则是：
   1. 能进行序列化/反序列化的类**必须实现Serializable接口**.
   2. ObjectOutputStream、ObjectInputStream两种处理流专门用来传输Java对象数据.
      - 它俩的writeObject和readObject方法：
         1. ObjectOutputStream的writeObject：先 **序列化** 后 **输出**.
            - 自动调用对象的Serializable协议的 **序列化方法（writeObject）** 进行序列化.
         2. ObjectInputStream的readObject：先 **输入** 后 **反序列化**.
            - 自动调用对象的Serializable协议的 **反序列化方法（readObject）** 进行反序列化.
      - 可以看到**Serializable的协议方法和ObjectXxxStream的输入输出方法同名，都是writeObject和readObject**.

<br>

**2.&nbsp; Java序列化/反序列化的数据格式要求：** 必须序列化成**JVM字节码**.

1. JVM字节码与机器无关，使得Java对象的传输可以轻松跨平台.
2. 这就意味着：
   1. 只要进行序列化和反序列化 **操作的主体是JVM**.
   2. 那么这两个JVM **不管在什么地方** 都可以轻松传输Java对象.
      - 完全可以是同一个JVM进程，也完全可以是两台不同机器上的JVM进程.
      - 即实现远程的两个JVM之间传输Java对象.

<br>

**3.&nbsp; 其它常见的应用：** Java对象的持久化

- 直接将Java对象保存（序列化）在永久存储设备（持久化设备（也叫永久性介质））中.
   - 持久化设备，如磁盘等，不像内存那样，允许数据分散存放，原因是：
      - 数据要永久存放在里面，必须要尽最大可能节省空间.
         1. 内存数据都是**用完即可覆盖**（腾出空间给其它数据），放的零散点也没关系，只要保证速度快就行了.
         2. 如果零散存放容易浪费空间（多出很多细小零碎的空间，即碎片空间）.
            - 整理碎片空间代价巨大，毕竟持久化设备速度很慢.
- 程序需要的时候可以直接从持久化设备中反序列化恢复成原本的Java对象到内存中.

<br>

**4.&nbsp; Java序列化的变种：** IoC

- 现在大多数Java应用采用依赖注入（IoC）的方式为程序准备数据.
   - 即程序需要用到的Java对象都以XML、json的形式提供.
   - 同时XML、json格式也是一种良好的数据传输格式.
      - 大多数应用的Java对象传输都是以跨平台的XML、json格式进行传输.
- 这就要求Java对象支持：
   1. 将数据序列化成XML、json格式.
   2. 将XML、json格式反序列化成Java对象.
      - **这和Java传统序列化就有本质不同（序列化的格式是Java字节码）.**
