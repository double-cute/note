# 缓存流 & 回推输入流
> - 缓存流虽然是处理流，但并没有对4种节点流抽象基类做多少扩展.
>   1. 仅仅就是在底层额外支持了 **大容量高效缓存** 的功能.
>   2. 只能说是低级的处理流.
>
> <br>
>
> - 回推输入流：
>   1.

<br><br>

## 目录

1. []()
2. []()

<br><br>

### 一、缓存流：
> 是 **4种节点流抽象基类分别对应的** 具有 **大容量高效缓存功能的** 处理流 **实现类**.
>
>> 1. 命名仅仅就是4种节点流抽象基类加上 **"Buffered"** 前缀.
>> 2. 实际并没有比4种节点流抽象基类多多少方法，属于 **比较低级的处理流**.
>> 3. 仅仅就是在底层支持大容量的缓存，在 **处理大容量数据时效率很高**.

<br>

**1.&nbsp; 构造器：** 以对应类型的节点流作为输入，同时可以指定缓存的大小

- 缓存大小的单位（即int size）为：字节-对应字节流，字符-对应字符流.

```Java
// 不指定size则会自动根据流的内容大小得到一个合适的大小.
  // 当然精确指定可以更加节省空间，前提是你对需要的大小了解的非常清楚
BufferedInputStream(InputStream in[, int size]);
BufferedOutputStream(OutputStream out[, int size]);
BufferedReader(Reader in[, int size]);
BufferedWriter(Writer out[, int size]);
```

<br>

**2.&nbsp; BufferedInputStream & BufferedOutputStream：**

- 没有对InputStream & OutputStream做任何拓展，**完全当InputStream & OutputStream使用就行**.

<br>

**3.&nbsp; BufferedReader：** 额外支持**逐行读取**

- 涉及到**文本流的大规模逐行读取**一定要用BufferedReader，最为高效.
- 即找\\n来识别行.

```Java
// 1. 接着读取一行
String readLine() throws IOException;

// 2. 接着读完所有行，并返回这些行构成的聚集流
Stream<String> lines();
```

<br>

**4.&nbsp; BufferedWriter：** 额外支持**写一个空行**

```Java
// 等价于write('\n');
void newLine() throws IOException;
```

<br><br>

### 二、回推输入流：
    1) 即用输入流读取数据的时候可以将数据回推到输入流中的输入流；
！！输出流没有回推，以为输出是往外输出，没有回推反复输出的需求；
    2) 是一种高级处理流，可以包装输入节点流（即对各种不同的节点流的缓冲进行回推）；
    3) Java的回推输入流类是PushbackInputStream和PushbackReader；
    4) 回推模型：
         i. 回推输入流具有两个缓冲区，一个是正常的输入流缓冲区，另一个是回推缓冲区；
         ii. 程序正常用read系列读取数据是必须先读取回推缓冲区的数据，只有当回推缓冲区读完后才能继续读取正常输入缓冲区中的数据；
         iii. 从这两个缓冲区中读取数据时都是读取一个少一个，即直接从缓冲区中“取走”数据，取走的数据就不再在缓冲区中了；
         iv. 而往回推缓冲区中回推数据时可以回推任何数据，因此只有将从输入缓冲区中读取的数据回推到回推缓冲区时才能实现对输入数据的反复读取；
！小结：回推缓冲区和输入缓冲区是隔开的，只不过回推缓冲区的数据会先读；
    5) 回推三方法：byte和char分别是字节流版本和字符流版本
         i. void unread(int b/int c);  // 回推一个单位b/c
         ii. void unread(byte[] buf/char[] cbuf);  // 回推一整个数组buf/cbuf
         iii. void unread(byte[] buf/char[] cbuf, int off, int len);  // 将数组从off开始的len个单位回推
！！可以看到和read一模一样，只不过干的是和read完全相反；
    6) 在创建回推输入流时需要指定回推缓冲区的大小（单位）：PushbackReader(Reader in, int size);  // 如果回推超过size个单位会直接抛出异常！
    6) 示例：找出输入流中的字符串"Peter"，并将该字符串之前的全部字符打印出来
[java] view plain copy 在CODE上查看代码片派生到我的代码片
public class Test {  

    public static void main(String[] args) throws IOException {  
        try (PushbackReader pr = new PushbackReader(new InputStreamReader(System.in), 64)) {  
            char[] buf = new char[32]; // 临时读取数据的缓冲  
            String preCon = ""; // 上一次读取的内容  
            int hasRead = 0;  
            int find = 0; // 找到目标字符串的位置  
            while ((hasRead = pr.read(buf)) > 0) {  
                String curCon = new String(buf, 0, hasRead); // 当前读取的内容  
                String con = preCon + curCon; // 由于目标字符串可能加载上一次和当前内容的中间，所以需要合并  
                find = con.indexOf("Peter"); // 检测是否找到目标字符串  
                if (find > 0) { // 如果找到了  
                    pr.unread(con.toCharArray()); // 先将合并内容回推  
                    char[] find_buf = new char[find]; // 目标字符串可能完全在curCon之中，因此find可能大于临时缓冲区大小32  
                    pr.read(find_buf, 0, find); // 然后再从回推缓冲区读取到目标字符串之前的位置  
                    System.out.println(new String(find_buf, 0, find)); // 打印退出  
                    System.exit(0);  
                }  
                else { // 不存在，因此先打印上次内容  
                    System.out.print(preCon); // 但是curCon中也许存在目标字符串的部分内容，因此curCon不能打印  
                    preCon = curCon; // 递推  
                }  
            }  
        }  
    }  
}  
！！可以看到回推输入流最主要是用来对输入流进行分析！！而不是闹着好玩儿瞎回推！！
