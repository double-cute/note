# 泛型构造器、含有泛型参数的重载、数组泛型
> 1. 由于构造器也是一种特殊的方法，因此构造器也可以定义成泛型方法，只不过同时碰到所在的类也是泛型类时会有些特殊.
> 2. 只要类型参数的**形式、名称**不同都能构成方法的重载.
> 3. Java**禁用**元素是泛型的数组.

## 目录：

1. [泛型构造器]()
2. [含有泛型参数的方法重载问题]()
3. [数组泛型：禁用！]()

<br><br>

### 一、泛型构造器：[·](#目录)
> 由于构造器也是方法的一种，因此对构造器定义泛型方法和定义普通的泛型方法没有任何区别！
>   - 定义时同样将**菱形写在构造器名称之前**.

- 定义泛型构造器的示例：
  - 注意：**如果泛型构造器所属的类也是泛型类，那么两者的类型参数注意区分.**
    - 如果同名的话会覆盖.

```Java
public class MyClass {
    public <T> MyClass(T t) { ... }
}

public class MyClass<T> { // 所属类也是泛型类
    public <E> MyClass(E e) { ... }  // 两者的类型参数名称注意区分，如果也是T的话会覆盖
}
```

<br>

- 泛型构造器唯一麻烦的地方就是 **其所属类同时也是泛型类** 时 **如何使用这样的构造器** 创建泛型对象：
  - 很明显，泛型类须要指定类型实参，泛型构造器也须要指定自己的类型实参，那就有可能**同时出现两个菱形**.
  - 共有三种创建对象的方式：

```Java
// 主类如下
public class A<T> {
    public <E> A(E e) { ... }
}

// 3种创建形式
1. 显式：A<String> a = new <Integer>A<String>(15); // 双菱形语法，前一个是泛型构造器的类型实参，后者是泛型类的类型实参
2. 隐式（自动推断）：A<String> a = new A<>(15);   // 泛型构造器的菱形可以省略，但泛型类的菱形不能省
3. 半隐式（自动推断）：A<String> a = new A<String>(15);  // 总之，泛型构造器的菱形可以省，泛型类的不能省

// 半隐式只能省前不省后，不能省后不省前！
A<String> a = new <Integer>A<>(15);  // 编译错误！
// 总结一句话就是：泛型类的类型参数在编译时比泛型构造器的类型参数地位更高！
```

- 还是**首推隐式的写法，最简洁，最容易记！**

<br><br>

### 二、含有泛型参数的方法重载问题：[·](#目录)

- **只要类型参数的形式不同就能形成重载**，例如：

```Java
// 它们全都是不同的参数类型，因此都可以当成重载
List<T>
List<T extends Xxx>
List<? super Xxx>
List<E extends Xxx>
List<T, E>
List<T, E extends A & B & C>
```

<br>

- 由于泛型的灵活，容易发生歧义：
  - 由于上面的规则，歧义的重载不会在编译时报错，但会在运行时发生异常.
  - 典型例子：

```Java
// 形成重载，合理，因此没有编译错误
public static <T> void copy(Collection<T> dest, Collection<? extends T> src);
public static <T> void copy(Collection<? super T> dest, Collection<T> src);

// 但如果这样调用
copy(new ArrayList<Number> ln, new ArrayList<Integer> li);
// 由于两个重载版本都符合条件，因此不知道到底应该调用该哪个方法，随之而来的就是抛出异常了！！
```

- 还是那句话：歧义是低级错误，一定要自己避免！

<br><br>

### 三、数组泛型：禁用！ [·](#目录)
> 数组泛型就是指用泛型对象作为数组的元素，是直接被禁用的，你敢用就直接编译报错.

- 例如：

```Java
List<String>[] arr = new List<String>[10];  // 禁用，直接编译错误！
```

- Java禁用数组泛型的原因：
  1. 由于数组是JVM内核的一部分，太低级太底层.
  2. 而泛型太高级太高层.
  3. 两者在技术层面上就完全不兼容.
