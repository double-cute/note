# 泛型的多态、传参、范围受限
> 1. 泛型的多态规则保障了泛型的类型安全.
> 2. 泛型的传参机制避免了大量的强制类型转换，使代码更简洁.
> 3. 泛型类型参数以及通配符的范围受限则可以在传参的第一线控制类型实参的范围，避免了很多误传.

<br><br>

## 目录：

1. [Java数组类型的多态bug引发对泛型多态的思考](#一java数组类型的多态bug引发对泛型多态的思考)
2. [任意类型参数情况下的泛型传参问题：类型参数通配符?](#二任意类型参数情况下的泛型传参问题类型参数通配符--)
3. [受限的类型参数](#三受限的类型参数)

<br><br>

### 一、Java数组类型的多态bug引发对泛型多态的思考：[·](#目录)
> Java数组类型有一个小bug，那就是：如果A是B的父类，那么A[]也是B[]的父类.

- 这个bug虽然可以在编程时避免（不出现），然而一旦出现了就很容易（几乎是90%可能性）出错，例如：

```Java
String[] sarr = new String[10];
Object[] oarr = sarr;  // 编译正确！Java允许A是B的父类，那么A[]就是B[]的父类！
oarr[0] = 1.5;  // 运行时异常，因为oarr的运行时类型是String[]，String[]无法接受double类型的元素！
```

- 上面这样的错误很显然是不会在编译时检查的（毕竟Java允许这样），但头疼的问题是：
  - **运行时异常抛出的错误信息是ArrayStoreException，而不是类型冲突的ClassCastException！！**
  - 也就是说明明是类型冲突的错误，但报的却是数组存储错误！！
  - 如果开发者不明白这一点的话，肯定会耗费大量的时间被真正的错误原因所折磨！！
    - 简直就是坑爹啊，Java竟然纵容这么容易出错的漏洞设计！！

<br>

- 这种数组多态设计漏洞的背景：
  1. 数组设计得太早，是作为Java语言的一部分诞生的.
  2. Java数组实在太原始太底层了，很多JVM的内核都是基于数组的.
  3. 因此只能将就一下了，所以使用数组的时候一定要格外小心多态bug！

<br>

- 数组多态bug引发对泛型的思考：
  - 数组多态bug中映射出泛型多态的模型：

```Java
1. 可以把数组类型想成一种泛型Array<T>，那么String[]就是Array<String>，Double[]就是Array<Double>.
2. 数组多态bug用泛型来描述就是：如果**类型实参有继承关系**，那么它们**相同泛型如果也允许有继承关系的话**就容易发生运行时的类型冲突异常！

* 具体一点，接着上面的例子就是说：Object是String的父类，但如果也允许Array<Object>是Array<String>的父类的话就容易发生运行时的类型冲突异常！
```

- 这是道理是显然的，所以泛型**作为一个晚辈**，在Java好多个版本之后才出现，因此**有责任要避免这个bug**，**不能重蹈Java数组类型的覆辙**.
- 因此，**Java泛型编译时检查的一条重要规则**：[具有继承关系的类型实参]的[相同泛型]**不具有继承关系**.
  - 具体的说就是，如果A是B的父类，那么Generic\<A\>不是Generic\<B\>的父类！！！两者直接不能发生多态！！
    - 绝对不能用Generic\<A\>的引用指向Generic\<B\>的对象！
  - **但A\<T\>一定是B\<T\>的父类，这是显然的.**

<br>

- Java泛型的**暖心而霸气的承诺**：**只要在编译时没有发生警告或错误，那么在运行时绝对不会发生类型转化异常！**
  - 即人性又牛逼.

<br><br>

### 二、任意类型参数情况下的泛型传参问题：类型参数通配符?  [·](#目录)

- 首先，实例化类型参数的泛型传参肯定是没有问题的，例如：void func(List\<String\> list);  // 可以传进来ArrayList<String>实参，只要Generic是List的子类或本身即可

<br>

- 但如果传参时类型参数不确定，可以是任何类型实参该怎么办呢？
  - 比如说：void func(List\<?\> list)中，?表示类型实参不确定，可以是任意的，既可以是String，也可以是Integer等.
    - 在实际生产开发中必定会有这样的需求的，那该怎么办呢？
  - 能想到的最直接的方案就是用Object来替换?，即void func(List\<Object\> list)，可这样是否就可以接受任意类型实参呢？
    - **大错特错！正因为A是B的父类，但Generic\<A\>不是Generic\<B\>的父类，因此如果这样写的话运行时必定会发生类型冲突！**

<br>

- Java专门提供了类型参数通配符?来解决上述问题，就直接写成void func(List\<?\> list)就能解决问题了！啊哈哈哈！
  1. 当?出现在**泛型的菱形**\<\>中时就表示**类型参数通配符**.
  2. ?可以匹配**一个范围**中的任意类型.
    - 什么叫一个范围呢？就是指**受限的通配符?**
      1. ?可匹配的范围是：≤ Object   （不受限）
      2. ? super Xxx可匹配的范围是：String ≤  ≤ Object   （规定了下限）
      3. ? extends Xxx可匹配的范围是：≤ Xxx   （规定了上限）
- 但是这里要**注意一个概念**：Generic\<? ...\>可以匹配自己范围的所有Generic\<T\>，并不是指Generic\<? ...\>是Generic\<T\>的父类！！！
  - 这个是指**编译器语法上的匹配**，并不指**实际上真正存在继承关系**！！！
  - 只是**语法概念**，而**非继承概念**.

<br>

- 那问题来了，对于类型参数是?通配符的泛型形参在方法中应该怎么使用呢？
  - 即：

```Java
void func(List<?> list) {
    // ???该怎么使用这个list呢？应该注意什么呢？
}
```

1. 首先肯定要慎重，不能乱修改，比如：
  - 如果你直接list.add("abc");就会埋下bug的种子.
    - 设想，如果你传入的实参是List<Integer>类型的，那你添加了一个String类型的不就发生运行时类型冲突了吗！
  - **但Java承诺过，使用泛型一定不会发生运行时类型异常，因此Java编译器会强制关闭出现上述歧义的方法调用，如果出现就会发生编译错误！**
2. 因此，最安全稳妥的方法就是**把?当做自己的类型上限**即可：即把?当做自己匹配范围的上限最安全最稳妥，一定不可能犯错.
  1. 把?当做Object.
  2. 把? super Xxx当做Object.
  3. 把? extends Xxx当做Xxx.

- 例如：

```Java
void func(List<? extends String> list) {
    list.get(0).charAt(5);  // 把?当做上限String即可
}
```

<br>

- 实际上，Java本来就是**将?的编译时类型默认为?的类型上限**：
  - 这样做的好处就是**避免了大量的强制类型转换，使代码大大简洁化**.
  - 验证方法：多态

```Java
class A {
	public void print() { System.out.println("A"); }
}

class B extends A {
	@Override
	public void print() {
		System.out.println("B");
	}
}

public class Test {
	public static void proc(List<? extends A> list) {
		list.get(0).print();  // ?的编译时类型为A
	}

	public static void main(String[] args) throws NullPointerException  {
		ArrayList<A> list = new ArrayList<>();  // 不管是A还是B都一样，ArrayList<B>结果也一样
		list.add(new B());
		proc(list);  // B，调用的是子类的B的print方法，发生了多态！！
                    // 所以推断出?的编译时类型为上限A
	}
}
```

- 总结：
  1. 类型参数通配符?只能在泛型传参时使用.
    - 不能在泛型类型、接口定义中使用.
  2. ?可以具有受限的类型实参范围.
    - ? super Xxx指定了下限.
    - ? extends Xxx指定了上限.
    - ? 就相当于 ? extends Object.
  3. ?的编译时类型默认为类型上限.
    - 使用时，把?的编译类型当做类型上限使用一定不会出错的！

<br><br>

### 三、受限的类型参数：[·](#目录)
> 前面已经介绍过了，类型参数通配符?用于泛型传参，而普通的类型参数（也就是所谓的\<T\>用于泛型类、接口的定义等）.
>
>> 而现在这个类型参数\<T\>也可以受限了.

- 类型参数\<T\>**只能指定上限不能指定下限**：

```Java
public class A<T extends Xxx> { ... }   // 正确
public class A<T super Xxx> { ... }   // 错误！不存在的
```

<br>

- 不仅可以指定范围，还能指定类型实参必须实现的接口：

```Java
class 泛型名<T extends 上限类 & 接口1 & 接口2...> { ... }
// 表示可以接受的类型实参必须以指定的类作为上限，并且必须实现指定的若干接口.
// 如果传入的实参类型不满足上面的要求则编译报错
```

- 注意：
  1. Java不支持类的多继承，所以**最多只能指定一个上限**.
  2. 但Java支持接口的多继承，所以**可以指定多个接口**.
  3. **第一个必须写上限类，后面再跟一个个接口**，否则编译报错.
