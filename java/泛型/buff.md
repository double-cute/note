### 一、定义泛型方法 & 类型参数的作用域及受限：
> Java编译器规定，静态成员（静态方法、静态块）不能使用泛型类的类型参数！

- 也就是说：下面是错误的

```Java
class A<T> {
    static { T t; ... }  // 错误
	public static void func(T t) { } // 错误
}
```

- 但是我们知道，Java中的静态方法、静态块就相当于C语言中的函数，函数使用类型参数是天经地义的（也就是C++中的模板函数）.
  - 模板函数的需求是普遍的、正常的！可Java不允许静态内容使用泛型类的类型参数该怎么办？让人头疼.
  - 至于Java为什么不允许这样，具体原理会在“类型擦除”这一章节中详细讲解，这里先记住这个结论.

<br>

- 亟待满足的需求以及其它可能的需求：
  1. 亟待满足：使静态方法可以使用类型参数（实现C++模板函数的功能）.
  2. 其它可能的需求：
    1. 泛型类的对象方法使用和泛型类不同的类型参数.
    2. 不是泛型类的对象方法也可以使用类型参数.
- 因此，Java专门为方法（静态、非静态）设计了独立的泛型化功能，即**泛型方法**.

<br>

- **泛型方法的定义语法：**

```Java
public static <T, S> int func(List<T> list, Map<int, S> map) { ... }
访问限定符  修饰符  菱形的类型参数声明  返回类型  方法名(形参列表) { 方法体 }
```

1. 只要在**修饰符**和**返回类型**之间加上类型参数声明即可.
2. 接着，在**形参列表**和**方法体**中就可以使用这里声明的类型参数了.

<br>

- **类型参数的作用域：**
  - 类型参数有各自的作用域，和普通变量的作用域概念一模一样.
  - 同样是存在同名覆盖原则，泛型方法的类型参数如果和所在泛型类/接口的类型参数同名，则小范围覆盖大范围.

```Java
public class A<T> { // T的作用域属于整个类
    public <S> void f1(S s) {}  // S的作用域属于f1整个对象方法
    public void f2(T t) {}  // 使用的是泛型类A的类型参数
    public static <S> void f3(S s) {}  // S属于f3自己
    public static <T> void f4(T t) {}  // 同名覆盖A的类型参数
    public <T> void f5(T t) {}  // 同样是同名覆盖
}
```

<br>

- 由于**泛型方法的类型参数**和**普通泛型类/接口的类型参数**一样没有区别，因此后者拥有的受限同样适用于前者：
  1. 只有extends没有super.
  2. 允许额外声明类型参数必须实现的接口.
- 示例：

```Java
public static <T extends Xxx & Serializable & Comparable, E extends Map> void func(List<T> list);  // 正确
public <T super Xxx> void func(T t);  // 错误！没有super，不存在的
```

<br><br>

### 二、泛型方法的调用：
> 分为显式调用和隐式调用：
>   1. 显示调用：调用时使用菱形显式指定类型实参.
>   2. 隐式调用：调用时不使用菱形指定类型实参，根据所传参数让编译器自动推断出类型实参.

- 显式调用：
  - **在方法名之前用菱形指定类型实参：**  obj.**\<String\>**func(...);** **
  - 那么传参时实参中的相关类型必须要和指定的类型实参相同，否则编译错误.

<br><br>

    1) 有两种方式：
         i. 显式指定方法的类型参数，类型参数要写在尖括号中并放在方法名之前，例如：obj.<String>func(...);
！！这样就显式指定了泛型方法的类型参数为String，那么所有出现类型参数T的地方都将替换成String；
         ii. 隐式地自动推断：那就是不指明泛型参数，让编译器根据传入的实参类型来自动推断类型参数是什么；
             a. 最简单的例如：<T> void func(T t);  这样调用的话，obj.func("lala");   // 那么就会根据"lala"的类型String推断出类型参数T的类型是String
             b. 但是一定要避免歧义，例如：<T> void func(T t1, T t2);  如果这样调用的话，obj.func("lala", 15); 虽然编译不会报错，但是仍然会有很大隐患，T到底应该是String还是Integer存在歧义；
！！Java存在一套机制来推断这种情况下到底应该把T当成什么，但是这种机制非常不可靠，通常会发生一些意想不到的错误，因此一定要避免这种歧义，平时编程的时候就应该把这种歧义当成是错误！！
             c. 但是有些歧义Java是会直接当成编译错误的，即所有和泛型参数有关的歧义，例如：<T> void func(List<T> l1, List<T> l2); 如果这样调用的话，obj.func(new List<String>(), new List<Integer>()); 这里当然会有歧义，编译器无法知道T到底应该是String还是Integer，但是这种歧义会直接报错的！！编译都无法通过；
！！即泛型要比普通类型的检查要严很多，很多在普通类型上行得通的擦边球，在泛型上都无法通过！！
！！即泛型方法中，如果类型参数刚好就是泛型参数的类型实参，那么这个类型实参不得有歧义！！否则直接编译报错；

3. 泛型方法VS类型通配符（两者可以混用）：
    1) 你会发现所有能用类型通配符（?）解决的问题都能用泛型方法解决，并且泛型方法可以解决的更好：
         ！！最典型的一个例子就是：
            a. 类型通配符：void func(List<? extends A> list);
            b. 完全可以用泛型方法完美解决：<T extends A> void func(List<T> list);
！！上面两种方法可以达到相同的效果（?可以代表范围内任意类型，而T也可以传入范围内的任意类型实参），并且泛型方法更进一步，?泛型对象是只读的，而泛型方法里的泛型对象是可修改的，即List<T> list中的list是可修改的！！
    2) 要说两者最明显的区别就是：
         i. ?泛型对象是只读的，不可修改，因为?类型是不确定的，可以代表范围内任意类型；
         ii. 而泛型方法中的泛型参数对象是可修改的，因为类型参数T是确定的（在调用方法时确定），因为T可以用范围内任意类型指定；
！！注意，前者是代表，后者是指定，指定就是确定的意思，而代表却不知道代表谁，可以代表范围内所有类型；
    3) 这样好像说的通配符?一无是处，但是并不是这样，Java设计类型通配符?是有道理的，首先一个最明显的优点就是?的书写要比泛型方法简洁，无需先声明类型参数，其次它们有各自的应用场景：
         i. 一般只读就用?，要修改就用泛型方法，例如一个进行修改的典型的泛型方法的例子：
public <T> void func(List<T> list, T t) {
	list.add(t);
}
         ii. 在多个参数、返回值之间存在类型依赖关系就应该使用泛型方法，否则就应该是通配符?：
             a. 具体讲就是，如果一个方法的返回值、某些参数的类型依赖另一个参数的类型就应该使用泛型方法，因为被依赖的类型如果是不确定的?，那么其他元素就无法依赖它），例如：<T> void func(List<? extends T> list, T t);  即第一个参数依赖第二个参数的类型（第一个参数list的类型参数必须是第二个参数的类型或者其子类）；
！！可以看到，Java支持泛型方法和?混用；
！这个方法也可以写成：<T, E extends T> void func(List<E> list, T t);  // 明显意义是一样的，只不过这个list可以修改，而上一个list无法修改
！！总之就是一旦返回值、形参之间存在类型依赖关系就只能使用泛型方法；
             b. 否则就应该使用? ；
    4) 对泛型方法的类型参数进行规约：即有时候可能不必使用泛型方法的地方你不小心麻烦地写成了泛型方法，而此时你可以将其规约成使用?的最简形式
         i. 总结地来讲就是一句话：只出现一次 & 对它没有任何依赖
         ii. 例如：<T, E extends T> void func(List<T> l1, List<E> l2);  // 这里E只在形参中出现了一次（类型参数声明不算），并且没有任何其他东西（方法形参、返回值）依赖它，那么就可以把E规约成?
！！最终规约的结果就是：<T> void func(List<T> l1, List<? extends T> l2);
    5) 一个最典型的应用就是容器赋值方法（Java的API）：public static <T> void Collections.copy(List<T> dest, List<? extends T> src) { ... }
！！从src拷贝到dest，那么dest最好是src的类型或者其父类，因为这样才能类型兼容，并且src只是读取，没必要做修改，因此使用?还可以强制避免你对src做不必要的修改，增加的安全性；
