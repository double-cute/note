# 泛型方法以及和类型参数通配符的关系
> Java设计泛型方法的目的就是为了可以在面向对象领域之外实现和C++模板方法类似的功能.
>
>> 同时，泛型方法又和类型参数通配符之间有着千丝万缕的联系.

<br><br>

## 目录：

1. [定义泛型方法 & 类型参数的作用域及受限]()
2. [调用泛型方法]()
3. [泛型方法 VS 类型通配符]()

<br><br>

### 一、定义泛型方法 & 类型参数的作用域及受限：[·](#目录)
> Java编译器规定，静态成员（静态方法、静态块）不能使用泛型类的类型参数！

- 也就是说：下面是错误的

```Java
class A<T> {
    static { T t; ... }  // 错误
	public static void func(T t) { } // 错误
}
```

- 但是我们知道，Java中的静态方法、静态块就相当于C语言中的函数，函数使用类型参数是天经地义的（也就是C++中的模板函数）.
  - 模板函数的需求是普遍的、正常的！可Java不允许静态内容使用泛型类的类型参数该怎么办？让人头疼.
  - 至于Java为什么不允许这样，具体原理会在“类型擦除”这一章节中详细讲解，这里先记住这个结论.

<br>

- 亟待满足的需求以及其它可能的需求：
  1. 亟待满足：使静态方法可以使用类型参数（实现C++模板函数的功能）.
  2. 其它可能的需求：
    1. 泛型类的对象方法使用和泛型类不同的类型参数.
    2. 不是泛型类的对象方法也可以使用类型参数.
- 因此，Java专门为方法（静态、非静态）设计了独立的泛型化功能，即**泛型方法**.

<br>

- **泛型方法的定义语法：**

```Java
public static <T, S> int func(List<T> list, Map<int, S> map) { ... }
访问限定符  修饰符  菱形的类型参数声明  返回类型  方法名(形参列表) { 方法体 }
```

1. 只要在**修饰符**和**返回类型**之间加上类型参数声明即可.
2. 接着，在**形参列表**和**方法体**中就可以使用这里声明的类型参数了.

<br>

- **类型参数的作用域：**
  - 类型参数有各自的作用域，和普通变量的作用域概念一模一样.
  - 同样是存在同名覆盖原则，泛型方法的类型参数如果和所在泛型类/接口的类型参数同名，则小范围覆盖大范围.

```Java
public class A<T> { // T的作用域属于整个类
    public <S> void f1(S s) {}  // S的作用域属于f1整个对象方法
    public void f2(T t) {}  // 使用的是泛型类A的类型参数
    public static <S> void f3(S s) {}  // S属于f3自己
    public static <T> void f4(T t) {}  // 同名覆盖A的类型参数
    public <T> void f5(T t) {}  // 同样是同名覆盖
}
```

<br>

- 由于**泛型方法的类型参数**和**普通泛型类/接口的类型参数**一样没有区别，因此后者拥有的受限同样适用于前者：
  1. 只有extends没有super.
  2. 允许额外声明类型参数必须实现的接口.
- 示例：

```Java
public static <T extends Xxx & Serializable & Comparable, E extends Map> void func(List<T> list);  // 正确
public <T super Xxx> void func(T t);  // 错误！没有super，不存在的
```

<br><br>

### 二、调用泛型方法：[·](#目录)
> 分为显式调用和隐式调用：
>   1. 显示调用：调用时使用菱形显式指定类型实参.
>   2. 隐式调用：调用时不使用菱形指定类型实参，根据所传参数让编译器自动推断出类型实参.

- 显式调用：
  - **在方法名之前用菱形指定类型实参：**  obj.**\<String\>**func(...);** .**
  - 那么传参时实参中的相关类型必须要和指定的类型实参相同，否则编译错误.

<br>

- 隐式调用：自动推断
  - 例如：

```Java
public <T> void func(T t);
obj.func("lala");  // 正确的调用，推断出T是String
```

- **隐式调用的歧义问题：**
  - 有两种类型的歧义：
    1. 单歧义：单单一个T类型实参的歧义.
      - 编译不报错，但运行时异常！
        - 算是Java泛型的一个小缺点.
    2. 复歧义：由T构成的泛型实参的歧义.
      - 直接编译报错.
  - 原则：**尽量在编写代码的第一线上就避免这种歧义，歧义是一种低级错误！**

- 举例：

```Java
<T> void func(T t1, T t2);
obj.func("lala", 15);  // 单歧义，编译通过，但运行时异常

<T> void func(List<T> l1, List<T> l2);
obj.func(new List<String>(), new List<Integer>());  // 复歧义，直接编译报错！
```

<br><br>

### 三、泛型方法 VS 类型通配符：[·](#目录)
> 两者都用于Java的方法，两者可以**混合使用**，也可以**相互转化和规约**，但**各自又有不同的特点和用处**.

#### 1. 两者在语义上完全可以相互转化：

- 可以发现，所有可以用泛型方法写出来的完全可以用类型通配符写出来，反之亦然.
- 仅仅就是**文字游戏上（表达的意义上）** 的相互转换.
  - 实质是有区别的，这个后面讲，但这里先介绍**语义上的等价关系**.

- 以下两者**在语义上等价**：

```Java
public void func(List<? extends A> list);
public <T extends A> void func(List<T> list);
```
<br>

#### 2. 两者的本质区别和应用场合：

- 通配符?表示未知类型，使用时其编译时类型为其上限，因此使用时受到的限制特别多.
  - 最显著的特点就是**含有?的参数通常难以修改**，因此最好是把它看成只读的.
    - 编译器自身为了保证运行时的类型安全**会限制很多有修改效果的方法的使用，甚至是关闭**，例如：

```Java
public void func(List<?> list) {
	list.add("lala");  // 错误，由于?的运行时类型未知，只能当成Object
                       // 但Java直接关闭了这个用法

    // 只允许使用下面这个
    list.add(null);   // 所以含有?的实参几乎可以看成是只读的
}
```

- 因此，**平时就应该把含有类型通配符?的参数当成是只读的.**
  - 不要老想着钻进脑汁去修改它，往往是失败的，啊哈哈哈，我就玩儿过，认输了已经.

<br>

- 相比之下，泛型方法中的类型参数T则是确定的，没有范围啊上限一说.
  - 在传入时其编译类型就是确定的（**不管显式还是隐式，都是能肉眼直接从调用方法的代码中看出来类型实参是什么**）.
  - 虽然有extends的受限，但其调用的时候必须先确定类型实参，受限也只是在编译时检查是否满足范围要求而已.
  - 因此含有T的实参不是可读的，可以修改.

```Java
public <T> void func(List<T> list, T t) {
	list.add(t);  // 没问题，正确
}
```

#### 3. 混用、依赖和规约：
> 其实都是编译时的语法规则，编译时检查，错误的话再改改就行，不用强行记忆.

- 混用：

```Java
<T> void func(List<? extends T> list, T t);  // list只读，t可写
<T, E> void func(List<T>, E e);  // 多个普通类型参数也可以同时使用
```

- 依赖：?可以依赖T，T不能依赖?
  - 这是显然的，?是不确定类型参数，怎么可能让一个确定的T去依赖一个不确定的?

```Java
<T> void func(List<? extends T> list, T t);  // 正确，?依赖T
<T> void func(List<T extends ?> list, ? t);  // 错误，T依赖?
```

- 规约：在形参中没有被依赖的E可以规约成?
  - 规约的意义在于：泛型方法通常比通配符表达的要复杂，规约可以简化.
  - 但这种简化做出的改变就是，**原来泛型方法中被规约的参数原来是可修改的，变成?之后就只读了.**

```Java
<T, E extends T> void func(List<E> list, T t);
<T> void func(List<? extends T> list, T t);  // 规约正确，E没有被依赖，list从可写变成只读

<T, E> void func(List<T extends E> list, T t);
<T> void func(List<T extends ?> list, T t);  // 规约错误，E被T依赖
```

- 是否要规约看的还是需求：
  1. 如果在实现中那个参数本身就**要求是只读的，那毫不犹豫选择规约成?** ，毕竟代码更加简洁.
  2. 如果在实现中按个参数**要求是可修改的，那就不能规约了**.
- 经典案例：Java容器API

```Java
public static <T> void Collections.copy(List<T> dest, List<? extends T> src) { ... }
```

- 值得赞扬的地方：
  1. src拷给dest，儿子拷给老子是符合多态规则的，因此? extends T用的很妙.
  2. dest是必须要修改的，而src本身无须修改，是只读的，因此src规约成?非常合理，简洁了代码.
