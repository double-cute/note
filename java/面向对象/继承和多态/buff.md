2. 覆盖（重写）父类的方法：
    1) 子类可以通过重写（覆盖）父类的方法达到多态的目的（多态的概念下一章会详细介绍）；
    2) 覆盖的原则必须要遵循“三同两小一大”：
         i. 三同：
            a. 方法名相同；
            b. 形参列表相同；
            c. 覆盖的方法要和子类方法一样，要么都是静态的，要么都是非静态的，不能不一致，不一致会直接编译报错！
！！总结来说就是方法签名相同；
         ii. 两小：
            a. 子类方法的返回值类型要比父类方法返回值类型的范围更小或者相等；（如果更小就是返回类型协变）
            b. 子类方法抛出的异常的类型要比父类方法抛出的异常类型范围更小或者相等；
！！这在类型上是兼容的，可以理解为范围小的类型是范围大的类型的子类族，刚好向上兼容！
         iii. 一大：子类覆盖方法的访问控制符应该比父类的更大；
！！从大到小是：public  ->  protected  ->  default  -> private
    3) 只要符合“三同两小一大”原则的都会触发“覆盖（重写）”，这样Java编译器会把子类的该方法当成“覆盖”方法，将具备多态功能！只要上面的原则有一点不符，该方法就会被当做一个普通方法（或者是其它重载方法），不具备多态的特性；
！！再次强调，如果符合“两同两小一大”，但一个是静态一个是非静态（差一同），就会编译报错！千万要小心，静态属性必须相同；
    4) 特殊情况：子类无法覆盖父类的private方法
         i. 由于父类的private方法对于子类来说也是不可见的；
         ii. 既然子类不可见，那子类就会当完全没有这个方法；
         iii. 因此如果子类还是强行覆盖该方法（访问控制符可以是任意一种，都是大于等于private的），那也不会形成覆盖！Java会把它当成一个属于子类的新方法；
！！因此private限定符要跟就不是用来覆盖的（继承、多态），仅仅表示这是一样非常私人的东西，谁都不能看见，包括自己的儿子；
小结：因此，对于父类中的private方法（静态、非静态）根本就不再“三同两小一大”的体系当中，因此子类中可以肆无忌惮地写和该方法同方法签名的方法，即使一个是静态的一个是非静态的也行，毕竟父类的private的方法子类是当完全不存在的！！
