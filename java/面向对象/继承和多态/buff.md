# 多态 & 重写（Override）
> Java中触发多态的亘古不变的条件：
>
> 1. （引用的）**编译时类型** 是 **运行时类型** 的 **父类**.
> 2. 并且调用了被子类重写的方法.
>
>> 那么多态将被触发，这个 **编译时类型为父类的引用** 最终调用的是 **子类重写版本** .
>>
>>> - 子类重写（覆盖）父类方法的 **三同两小一大** 原则：小/大 是 ≤和≥ （**包括相等**）
>>>    1. 方法名、方法签名相同，都是静态或者都是非静态.
>>>    2. 返回类型、抛出异常类型比父类的要小.（返回类型小就是**返回类型协变**）
>>>    3. 访问控制符比父类的大.（但private不可见，不能覆盖）

<br><br>

## 目录

1. []()
2. []()

<br><br>

### 一、多态的各种形式：假设重写方法是f()

<br>

**1.&nbsp; 正常形式：**

```Java
Father father = new Son();
father.f();
```

<br>

**2.&nbsp; 自放大：** 通过强转（放大类型）

```Java
((Father)new Son()).f();
```

<br>

**3.&nbsp; 隐式：**

```Java
// 假设R的覆盖Object的toString返回的是"R"
Object obj = new R();
System.out.println(obj);  // 输出R
System.out.println((Object)new R()); // 同样输出R
```

<br>




    6) 那多态有什么用呢？
         i. 设想一个父类Father，有多个子类Son1、Son2、Son3...，每个子类都覆盖了f1方法，并且f1的内容还都不一样；
         ii. 现在用一个Father的引用来指向各个不同子类的对象，然后分别调用f1，就会呈现出每个子类f1的行为；
！！每修改一次引用的指向，就会更新一次该引用所对应的虚函数表，例如f = new Xxx()，这里修改f的指向，因此就会根据新的运行时类型更新一下f的虚函数表；
         iii. 这就发生了，同一个引用，调用同一个方法却能表现出不同行为的现象，这就是多态；
         iv. 而其本质就是编译时类型的引用表现出运行时类型的行为；


             2. 覆盖（重写）父类的方法：
                 1) 子类可以通过重写（覆盖）父类的方法达到多态的目的（多态的概念下一章会详细介绍）；
                 2) 覆盖的原则必须要遵循“三同两小一大”：
                      i. 三同：
                         a. 方法名相同；
                         b. 形参列表相同；
                         c. 覆盖的方法要和子类方法一样，要么都是静态的，要么都是非静态的，不能不一致，不一致会直接编译报错！
             ！！总结来说就是方法签名相同；
                      ii. 两小：
                         a. 子类方法的返回值类型要比父类方法返回值类型的范围更小或者相等；（如果更小就是返回类型协变）
                         b. 子类方法抛出的异常的类型要比父类方法抛出的异常类型范围更小或者相等；
             ！！这在类型上是兼容的，可以理解为范围小的类型是范围大的类型的子类族，刚好向上兼容！
                      iii. 一大：子类覆盖方法的访问控制符应该比父类的更大；
             ！！从大到小是：public  ->  protected  ->  default  -> private
                 3) 只要符合“三同两小一大”原则的都会触发“覆盖（重写）”，这样Java编译器会把子类的该方法当成“覆盖”方法，将具备多态功能！只要上面的原则有一点不符，该方法就会被当做一个普通方法（或者是其它重载方法），不具备多态的特性；
             ！！再次强调，如果符合“两同两小一大”，但一个是静态一个是非静态（差一同），就会编译报错！千万要小心，静态属性必须相同；
                 4) 特殊情况：子类无法覆盖父类的private方法
                      i. 由于父类的private方法对于子类来说也是不可见的；
                      ii. 既然子类不可见，那子类就会当完全没有这个方法；
                      iii. 因此如果子类还是强行覆盖该方法（访问控制符可以是任意一种，都是大于等于private的），那也不会形成覆盖！Java会把它当成一个属于子类的新方法；
             ！！因此private限定符要跟就不是用来覆盖的（继承、多态），仅仅表示这是一样非常私人的东西，谁都不能看见，包括自己的儿子；
             小结：因此，对于父类中的private方法（静态、非静态）根本就不再“三同两小一大”的体系当中，因此子类中可以肆无忌惮地写和该方法同方法签名的方法，即使一个是静态的一个是非静态的也行，毕竟父类的private的方法子类是当完全不存在的！！




3. 兼容下反转：
    1) 现在的问题是多态完事儿后想回来了应该怎么办？简单的来说就是，Father f = new Son();是多态，多态下的工作完成之后，我想让f恢复成Son类型（编译时类型），原因很简单，因为我现在又想使用f指向的对象的子类部分了（加入该Son对象只有一个f指向它，想要使用该对象的子类部分就只能通过f了）；
    2) 总结来说，就是现在想让多态下引用的编译时类型恢复到和运行时类型相同的状态；
    3) 你可能会想，直接Son s = f;不就行了，现在s编译时类型是Son，而f指向的对象运行时类型是Son，那现在s的编译时类型不就和运行时类型想同了嘛！
         i. 虽然前面讲过，编译时类型和运行时类型没有关系，但上面的这个语句还是无法通过编译的；
         ii. 毕竟，Java是一个强类型语言，强类型语言指的是编译时对类型进行检查，而这个检查的对象就是编译时类型；
         iii. 编译器发现s的编译时类型是Son，而f的编译时类型是Father，而Father ≠ Son，因此会爆出类型转换异常！
    4) 向上转换是兼容的，向下转换是不兼容的！
         i. 前面讲过Father f = new Son(); 或者 Son s = new Son();  Father f = s;是不会发生类型转换异常的！因为等号左边的类型是左边的子类，即向上转换，即多态，因此类型是兼容的！
         ii. 而s = f之类的，即等号右边是左边的父类，即向下转换，是不兼容的，编译会直接报错，因为逻辑上就能解释，你只能说苹果是水果，但不能说水果是苹果，继承是is-a的关系；
    5) 但有时向下转换并不是错误的！就像上面的例子那样，多态下f的运行时类型是Son，把f赋值给Son引用恢复成Son编译时类型是无可厚非的，但这样做编译又会报错，此时就需要用到强制类型转换了！
         i. 强制类型转换除了可以用在数值类型的基本类型之间（int、double、char等之间的相互转换）；
         ii. 其次强制类型转换还可以用在兼容情况下的引用类型反转，而这个说的就是上述的情况：
             a. 例如：s = (Son)f;
             b. 能这样使用的前提：
                 *1. 右边必须是左边的编译时类型范围更大（父类或间接父类）；（兼容是必不可少的前提，而这个兼容指的是编译时类型的兼容，而这个方向是和向上转型相反看，因此叫做反转）
                 *2. 右边引用的运行时类型必须和左边引用的编译时类型相同；（这是强转的目的，即把编译时类型恢复成运行时类型）其实小于等于也行（即f的运行时类型是s编译时类型的子类，这样就又形成多态了）
         iii. 示例：Object o = "lala";  String s = (String)o;    // o的编译时类型是Object，而运行时类型是String，符合兼容反转的条件

4. instanceof运算符：
    1) 该运算符和+、-、*之类的都属于Java的基本运算符；
    2) 该运算符的作用是对引用进行运行时类型检查；
    3) 用法：引用 instanceof 类/接口
    4) 目的是判断该引用的运行时类型是否为指定类或接口的子类或者相等，简单地说就是检查该引用指向的对象是否是指定类或接口的实例（或者其子类的实例），返回值当然是boolean类型的；
    5) 使用规定：
         i. instanceof左边的引用的编译时类型必须和操作符右边的类型有继承关系才行！
         ii. 例如：String a = "lala";  a instanceof Math就是错误的，直接编译报错！而a instanceof Object就对了，因为a的编译时类型String和Object具有继承关系；
         iii. 为什么有这样的规定呢？理由其实很好解释，那就要反问，为什么要使用instanceof操作符呢？不就是在进行类型强转之前先检查运行时类型是否匹配，如果不匹配就不强转（否则会报错）？那运行时类型匹配也是有前提，你设想，如果两个引用的编译时类型都没有继承关系，那他们运行时类型怎么可能会有继承关系呢？？怎么可能匹配呢？用脚趾头都可以知道两个编译时类型无继承关系的引用是根本无法强转匹配的！
！！因此Java干脆要求做操作数的编译时类型必须至少要和右操作数有继承关系才能继续检查运行时类型；
    6) 示例：
Object o = "lala";
if (o instanceof String) { // true
	String s = (String)o;
}
out.println(o instanceof Math); // false


String s = "lala";
s instanceof Math; // 编译报错，s的编译时类型和Math没有继承关系
