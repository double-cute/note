# 抽象类 & 模板模式
> 1. 逻辑上专门用来被子类继承.
> 2. 形式上作为具体的子类们的高度抽象，即子类的通用模板.
> 3. 是 **模板模式** 的必要组成部分.


<br><br>

## 目录

1. []()
2. []()

<br><br>

### 一、

抽象类：
1. class必须用abstract修饰才会被编译器视为抽象类.
   - 如果有abstract方法，但class没被定义成abstract会直接编译报错.
2. 可以含有或者不含有abstract方法.
3. abstract方法不提供实现，只有方法签名（实现部分的{}被一个;代替）.
    - 没有抽象构造器，即使是抽象类，也只能定义普通构造器.
       1. abstract和static不能同时修饰方法，不支持抽象类方法（用类调用一个没有实现的方法是不可行的）.
       2. abstract和static可以同时修饰内部类.
       3. abstract和private不能同时修饰方法，子类无法继承就无法实现（直接编译报错）.
4. 编译器判断是否是抽象类的依据：
   1. 是否用abstract修饰class.
   2. 继承了一个抽象类但又木有实现其抽象方法.
   3. 接口中也能定义抽象方法（接口也能用abstract修饰），实现了包含抽象方法的接口，但又没有实现其中的抽象方法.
      - 以及继承了abstract class或者实现了接口，但又不实现其中的抽象方法，编译错误！除非将该类定义成abstract才行.
      - JDK8 要求，继承一个抽象类就必须实现其中的抽象方法，否则编译报错！JDK8之前好像没有这样的规定.

和普通类的相同之处和区别：
- 相同：多了抽象方法外没有任何区别，可以包含成员变量、方法、构造器、初始化块、内部类、接口、枚举（不管是静态的还是非静态的）.
- 不同之处：不能创建实例（new），只能被子类继承

1. abstract类：只能被子类继承，因此不能和final连用（final表示class不能被继承）.
2. abstract方法：该方法必须由子类实现.


<br><br>

### 二、模板模式：

1. 抽象父类提供多个子类的通用模板方法（这些都是抽象父类自己无法实现的方法），然后让子类去实现它们.
2. 抽象类中的普通方法可以依赖于（在其中调用）抽象方法.
