# 构造器（this & super构造器）
> 在默认值和初始化代码块之后执行.
>
>> 1. Java弱化了无参构造器，希望把无参初始化交给默认值和初始化块.
>>    - Java希望构造器只用来执行有参初始化.
>> 2. this可以调用本类中的重载构造器，super可以调用父类中的重载构造器.
>> 3. Java规定，必须保证父类部分构造完后再构造子类部分.

<br><br>

## 目录

1. [构造器的定义规则]()
2. [Java构造器的设计思想]()
3. [重载构造器之间的相互调用]()
4. [调用父类构造器]()

<br><br>

### 一、构造器的定义规则：[·](#目录)

<br>

1. 命名和类名一样.
   - 通过new关键字来调用.
2. 不得有返回值：
   - 其默认隐式返回this引用.
   - 如果**强行加返回类型**就**变成一个普通方法**了.
      - 就只能通过引用来调用而不能用new调用了.
3. 可以重载.
4. 访问控制符任意.
   - private一般作为特殊用途，比如单例模式.
5. 必须**至少要有一个**构造器.
   - 如果自己不定义则会**隐式提供**一个**空的无参构造器**.
6. 在默认值和初始化块**之后**调用.
   - 也就是最后调用，**调用的时间点非常晚**.

<br><br>

### 二、Java构造器的设计思想：[·](#目录)
> 除了构造一个对象时可以使用new来调用构造器之外，构造器还有更加深层次的设计思想.

<br>

**1.&nbsp; 从表面上看：构造器在默认值和初始化块之后才调用，这就意味着：**

- Java希望开发者只拿构造器做有参初始化.
   - 把无参初始化的工作交给默认值和初始化块.
      - 然后只是形式上不要忘记多写一个空的无参构造器的定义.
   - **刻意弱化无参构造器的作用！**

<br>

**2.&nbsp; 为什么要可以弱化无参构造器呢？为什么不把无参初始化交给无参构造器呢？**

- 因为软件开发最重要的一种设计思路就是代码重用.
   - 在对象初始化时一般都习惯先给所有数据成员赋一个默认的初值（无参初始化的工作）.
   - 然后再根据需要给特别关注的几个值重新赋初值.
      - 这在构造器这个层面上的表现就是：**往往很多重载的构造器都会先调用无参构造器**
      - 这样做的缺点就两个：
         1. 每个构造器中都要先调用一次无参构造器，显得**代码很冗余**.
         2. 构造器的相互调用降低效率.

<br><br>

### 三、重载构造器之间的相互调用：[·](#目录)
> 就是把this当做构造器名在构造器内部调用即可.
>
>> 例如：this(name, age); 表示调用了另一个重载构造器 MyClass(String name, int age);

<br>

- 相互调用规则：
   1. 只能在构造器中调用.
      - 不得在其它方法中调用，否则编译报错.
   2. 不能递归调用自己，否则编译错误.
      - 例如：MyClass() { this(); }  // 编译错误
   3. 如果不是用this调用而是用类名的构造器形式调用那就表示创建了一个其它对象，而不是构造自身.
   4. this构造器调用必须是构造器的**第一句且最多只能有一句**，否则编译错误.

<br><br>

### 四、调用父类构造器：[·](#目录)
> Java构造对象的规则是：先保证父类部分初始化之后，再初始化子类部分.
>
>> 编译器强制要求子类构造器的第一句必须是调用父类构造器，使用super关键字调用（和this的形式一样）.
>>
>>> 同样可以用super**调用父类的各种重载构造器**.

<br>

- 父类构造器调用规则（即super构造器的调用规则）：
   1. 只能在构造器中调用.
   2. 只能是构造器中的第一句且最多只能有一句.
   3. 如果没有调用this构造器，如果没有调用super构造器则编译器会隐式在第一行放上一个super();调用.
   4. 如果第一句是this构造器调用，那么调用super构造器的工作就交给被掉的this构造器了.
      - 因此：
         1. this和super构造器不能同时出现.
         2. 以上是一个递归定义的过程.

<br>

- 示例：

```Java
class A {
    int a;

    // 如果是如下
    A() {
        // super();
        int a = 1;  // 规则3.隐式调用一个super();
    }

    // 如果是如下
    A(int a) {
        this();  // 规则4，this()的第一行必定是一个super构造器的调用
        this.a = a;
    }
}
```
