# final & 不可变类


###### 赋初值！！！使用这个专业术语比较好

<br><br>

## 目录

1. []()
2. []()

<br><br>

### 一、赋完初值后就再也不能改变的final变量：
> 凡是用final修饰过的变量（静态、非静态、**局部变量**）：
>
> 1. 一旦赋完初值后就再也不能改变（必须有初值才能使用）.
> 2. 只要在赋完初值后有任何修改的行为（用赋值运算符给它赋值）都将发生编译错误！

<br>

**1.&nbsp; final变量的细节特征：**

1. 必须赋初值后才能使用：JVM不会为final变量默认初始化（二进制0）
   - 具体描述就是：定义final变量之后对它进行的第一个操作必须是=赋值操作.
   - **否则编译报错.**
      1. 对于final成员数据：必须在构造器调用结束完毕之前完成赋初值（默认值处、初始化块、构造器三选一）.
      2. 对于final静态数据：必须在类加载完毕之前完成赋初值（默认值处、静态初始化块处二选一）.
      3. 对于final局部变量：必须在所在定义域内，第一次使用前完成赋初值.
2. final变量的定义和赋初值不须要同时进行，可以分开：
   - 例如：**final int a;**  int b = 1; System.out.println("hello"); **a = 10;**
3. 赋的初值不必是编译时就必须确定（常量），可以是运行时才能确定的值.
   - 这点跟C/C++的const有区别，const不仅要求定义的同时赋初值，并且初值必须是编译时确定的常量.
   - 例如：final long a = System.currentTimeMillis();
4. 赋初值之后变量值不能再修改（只读），否则编译报错：
   - 这里的修改**仅限于**赋值运算符对其重新复制，例如：**各种赋值运算符** 都行
      1. a = 10;
      2. a += 10;
      3. a >>= 3;
5. 只读的是**值**：
   1. 对于基本类型变量，就是内容只读.
   2. 对于引用类型，也是引用的值（指针的内容）只读，即**指向不能改变**.
      - **但还是能通过引用调用的方法去修改其指向对象的内容！**
      - 原理还是和基本类型一样的，都是值只读.
      - 例如：final R r = new R(10);
         1. r = new R(20);  // 编译错误，final引用的指向不能变
         2. **r.setValue(11);  // 正确，还是能通过引用调用的方法去修改内容的**

<br>

**2.&nbsp; final形参：** 即C++的const形参

```Java
// 不用赋初值，在传参的时候就是赋初值
public void func(final int a) {
  System.out.println(a);
  a = 10;  // 不得需改，编译错误！
}
```

<br><br>

### 二、final常量宏：
> 如果一个final变量满足以下两个条件：
>
> 1. 定义的同时赋初值.
> 2. 赋的初值可以在编译时就确定（是一个常量初值）.
>
>> 那么该变量在之后的使用中会被**替换成那个常量初值**.

<br>

```Java
String a = "lalahaha";
String b = "lala";
String c = "haha";
String d = b + c;
out.println(a == d); // false

String a = "lalahaha";
final String b = "lala";
final String c = "haha";
String d = b + c; // 被替换成"lala"和"hehe"两个常量了
out.println(a == d); // true
```

<br><br>

### 三、final方法 & final类：
> 1. 被final修饰过的方法**不能被子类覆盖**.
> 2. 被final徐试过的类**不能被继承**.
>
>> 违反两者直接编译错误.

<br>

- **注意：**
   1. private方法没必要用final修饰.
      - 因为private成员对子类不可见，子类即使“重写”，那也只是定义了一个新的子类方法而已.
         - 不会编译报错.
   2. final方法虽然不能被覆盖，但是**可以被重载**.
      - 重载是平行的，重写是垂直的；

<br><br>

### 四、不可变类：
    1) 不可变类是指创建该类的对象后，这些对象的数据成员都不能改变；
    2) 这种需求是普遍的，例如Java的8个包装器类型以及String类都是不可变类；
    3) 那该如何设计自己的不可变类呢？三原则：
         i. 数据成员都是private final的！这是显然的；
         ii. 只提供getter，不能提供setter！这也是显然的；
         iii. hashCode和equals应该根据数据成员计算得来，并且hashCode相等的情况下也要保证equals相等；
     4) 有了以上三原则就基本能保证设计的类是不可变的了；
！！什么叫做基本？难道这样还不能保证是不可变类吗？
！！诚然，如果数据成员都是Integer、String这些本身就是不可变类，那当然没有问题，但往往业务上你想包含的数据成员都是其它公司开发的类库中的类，而很多类本身设计时都是可变的，但你往往有得不到这些类库的源码，因此你无法通过改动源码的方式把这些类改成不可变类；
     5) 因此现在的问题是，如果你想把一个包含可变类对象的类设计成不可变类应该如何做呢？
          i. 其实思路很简单！无非就是从两个方面出发：
             a. 所有在类内部对该可变成员的访问一定要保证不能对其进行修改。这是显而易见的！根本不用说都应该能想到；
             b. 另外可能发生修改隐患的地方就是返回这个可变成员的地方了：如果一个方法返回的刚好就是这个可变成员，那么返回后在类的外部就完全有可能对该成员进行修改了（即返回数据成员也是一种暴露类的内部情况的一种情形）；
          ii. 因此需要做文章的地方就在于b.了；
          iii. 其实应对策略也很简单，你只要创建一个该成员的副本并返回就行了，这样的话外界拿到的仅仅是该成员的副本，对副本修改不会影响到原本；
     6) 示例：
class Test {
	private final StringBuilder name; // 故意用StringBuilder，因为它是一个可变类
	public Test(StringBuilder name) {
		this.name = name;
	}
	public StringBuilder getName() {
		return new StringBuilder(name); // 返回一个临时创建的副本，外界对副本的改变不会影响原本
	}
}
