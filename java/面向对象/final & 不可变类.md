# final & 不可变类

<br><br>

## 目录

1. [赋完初值后就再也不能改变的final变量]()
2. [final常量宏]()
3. [final方法 & final类]()
4. [不可变类]()

<br><br>

### 一、赋完初值后就再也不能改变的final变量：[·](#目录)
> 凡是用final修饰过的变量（静态、非静态、**局部变量**）：
>
> 1. 一旦赋完初值后就再也不能改变（必须有初值才能使用）.
> 2. 只要在赋完初值后有任何修改的行为（用赋值运算符给它赋值）都将发生编译错误！

<br>

**1.&nbsp; final变量的细节特征：**

1. 必须赋初值后才能使用：JVM不会为final变量默认初始化（二进制0）
   - 具体描述就是：定义final变量之后对它进行的第一个操作必须是=赋值操作.
   - **否则编译报错.**
      1. 对于final成员数据：必须在构造器调用结束完毕之前完成赋初值（默认值处、初始化块、构造器三选一）.
      2. 对于final静态数据：必须在类加载完毕之前完成赋初值（默认值处、静态初始化块处二选一）.
      3. 对于final局部变量：必须在所在定义域内，第一次使用前完成赋初值.
2. final变量的定义和赋初值不须要同时进行，可以分开：
   - 例如：**final int a;**  int b = 1; System.out.println("hello"); **a = 10;**
3. 赋的初值不必是编译时就必须确定（常量），可以是运行时才能确定的值.
   - 这点跟C/C++的const有区别，const不仅要求定义的同时赋初值，并且初值必须是编译时确定的常量.
   - 例如：final long a = System.currentTimeMillis();
4. 赋初值之后变量值不能再修改（只读），否则编译报错：
   - 这里的修改**仅限于**赋值运算符对其重新复制，例如：**各种赋值运算符** 都行
      1. a = 10;
      2. a += 10;
      3. a >>= 3;
5. 只读的是**值**：
   1. 对于基本类型变量，就是内容只读.
   2. 对于引用类型，也是引用的值（指针的内容）只读，即**指向不能改变**.
      - **但还是能通过引用调用的方法去修改其指向对象的内容！**
      - 原理还是和基本类型一样的，都是值只读.
      - 例如：final R r = new R(10);
         1. r = new R(20);  // 编译错误，final引用的指向不能变
         2. **r.setValue(11);  // 正确，还是能通过引用调用的方法去修改内容的**

<br>

**2.&nbsp; final形参：** 即C++的const形参

```Java
// 不用赋初值，在传参的时候就是赋初值
public void func(final int a) {
  System.out.println(a);
  a = 10;  // 不得需改，编译错误！
}
```

<br><br>

### 二、final常量宏：[·](#目录)
> 如果一个final变量满足以下两个条件：
>
> 1. 定义的同时赋初值.
> 2. 赋的初值可以在编译时就确定（是一个常量初值）.
>
>> 那么该变量在之后的使用中会被**替换成那个常量初值**.

<br>

```Java
String a = "lalahaha";
String b = "lala";
String c = "haha";
String d = b + c;
out.println(a == d); // false

String a = "lalahaha";
final String b = "lala";
final String c = "haha";
String d = b + c; // 被替换成"lala"和"hehe"两个常量了
out.println(a == d); // true
```

<br><br>

### 三、final方法 & final类：[·](#目录)
> 1. 被final修饰过的方法**不能被子类覆盖**.
> 2. 被final徐试过的类**不能被继承**.
>
>> 违反两者直接编译错误.

<br>

- **注意：**
   1. private方法没必要用final修饰.
      - 因为private成员对子类不可见，子类即使“重写”，那也只是定义了一个新的子类方法而已.
         - 不会编译报错.
   2. final方法虽然不能被覆盖，但是**可以被重载**.
      - 重载是平行的，重写是垂直的；

<br><br>

### 四、不可变类：[·](#目录)
> 是指其对象中的**一切内容**都不得修改的类（即只读类）.
>
>> **绝不是将所有数据成员用final修饰那么简单.**
>>
>>> 因为对于引用类型变量，即使被final修饰了也可以通过调用方法的方式修改内容.

<br>

**1.&nbsp; Java核心类库就提供了很多不可变类：** 因此可以放心使用

- 如Integer等包装器类、String等.

<br>

**2.&nbsp; 如何设计自定义的不可变类呢？**

- 首先要通通final.

1. 对于基本类型以及本身就已经是不可变类型的变量直接final修饰即可.
  - 基本类型final一下就改不了了.
  - 不可变类型的内容本身就是只读的，因此其引用final一下即可.
2. 对于可变类型数据成员：
  - 首先其引用final一下是不用说的.
  - 其次要看采取什么策略了.

<br>

**3.&nbsp; 可变类型数据成员对外要不可变应该采取的策略：**

1. 消极策略：
   1. 裸上不做任何包装.
   2. 在所在类的内部必须要在意识上避免对其内容做任何修改.
      - 但难免会存在一些疏漏，不小心修改了其内容.
2. 积极策略：对该不可变类进行一轮包装，包装在一个新类里
   1. 在新类里，该可变类型数据必须要private final.
   2. 对外只提供getter方法，隐藏掉所有setter方法.

<br>

**4.&nbsp; 可变类型数据成员的返回值难题：**

- 不管3.中采取什么策略，如果要将该数据作为方法返回值返回就又存在被修改内容的风险了.
   - 返回到外界后外界可以通过该引用（仍指向该可变成员）来修改其内容.
- 解决方法：返回该成员的副本即可.
   - 外界就算修改，那修改的也是这个副本，跟本体没有任何关系.

<br>

- 示例：

```Java
class Test {
	private final StringBuilder name; // 故意用StringBuilder，因为它是一个可变类
	public Test(StringBuilder name) {
		this.name = name;
	}
  // 隐藏setter，不提供setter方法
	public StringBuilder getName() {
		return new StringBuilder(name); // 返回一个临时创建的副本
                                    // 外界对副本的改变不会影响本体
	}
}
```
