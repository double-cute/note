# 基础和技巧

<br><br>

## 目录

1. [主程序入口main](#一主程序入口main)
2. [命令行参数](#二命令行参数)
3. [方法的参数传递机制：值传递](#三方法的参数传递机制值传递--)
4. [面向对象的标识符命名规范](#四面向对象的标识符命名规范)
5. [方法重载](#五方法重载)
6. [可变参数方法](#六可变参数方法)
7. [单例模式](#七单例模式)

<br><br>

### 一、主程序入口main：[·](#目录)
> 一个Java类想被JVM当成程序入口运行的前提条件是：
>
> - 里面**必须**要有一个**public static void main**方法.
>   1. 它将作为程序主入口.
>   2. 方法修饰、返回类型等必须严格和商数相同.

<br>

1. Java中的方法名可以任意取，因此private double main(Date d);这样的方法也是合法的.
  - 也就是说一个程序中的**多个类都可以拥有名字为main的方法**.
    - 甚至每个main方法的签名**都是public static void main也没关系**.
      - 这就意味着你用**JVM运行哪个类**，**就会把那个类的public static void main作为程序入口**.
2. 但不过**作为主程序入口**的main方法只能定义成：public static void main
  - 并且合法的方法签名可以是：
    1. main(除了单独一个String[]外的任意形参列表)
      - 虽然编译没错，但**会引发JavaFX运行时异常**，别问我为什么.
    2. 可以抛出任意类型的异常，随便抛，任性.
      - 不会有任何编译时和运行时错误.
    3. 但**最最标准的签名**是：**public static void main(String[] args);**

<br><br>

### 二、命令行参数：[·](#目录)
> 即Java应用程序入口的那个main方法的String[] args参数.

<br>

1. 命令行参数是从**程序名称之后开始算**的：java JavaApplicationName **arg0 arg1 arg2 ...**
  - **[arg0, arg1, ...]** 就是 **Java应用程序JavaApplication** 的命令行参数.
2. [arg0, arg1, ...]分别对应main形参args[0]、args[1]、...
  - 注意！参数的下标从0开始计.

<br>

**注意：**

- 命令行参数是**用空格作为分隔符**，**如果参数本身是包含空格的，则该参数应该用双引号""引起来**.
  - 以避免**其中的空格被当做参数分隔符**.

<br><br>

### 三、方法的参数传递机制：值传递  [·](#目录)
> Java的方法传参**全部采用值传递**.

<br>

- 这就意味着：
  - **基本类型**拷贝的是**真实值**，**引用类型**拷贝的是**指针变量的值**.

<br>

- 因此，swap方法不仅对基本类型无效，也对引用类型无效.
  1. 基本类型在swap中交换的是形参副本.
  2. 引用类型在swap中交换的也只是形参副本.
    - 两者都不影响方法外部的真实值和引用的指向.

<br><br>

### 四、面向对象的标识符命名规范：[·](#目录)

<br>

**1.&nbsp; 类、接口：**

  1. 由多个单词连缀而成.
  2. 单词之间**不要有分隔符**（直接连起来）.
  3. **每个**单词**首字母大写**，**其余小写**.

<br>

**2.&nbsp; 数据成员：**

  1. 应该是**名词**.
  2. 由多个单词连缀而成.
  3. 中间**不要有用分隔符**.
  4. **首字母小写**，**其余单词首字母大写**，其余小写.

<br>

**3.&nbsp; 方法：**

  - 应该**以英文动词开头**，其余规则**和数据成员相同**.

<br><br>

### 五、方法重载：[·](#目录)
> 重载在所有语言中的最一致的要求就是，**必须&至少** **方法名要相同** 才会有重载.

<br>

- Java方法重载的前提条件：**相同的方法签名**
  - 不同语言的方法签名不太相同.
    1. 像Swift把返回值类型也加到方法签名中.
    2. 而Java则不然.

<br>

- Java规定的方法签名内容：
  1. 方法名要相同：想都不用想的.
  2. 只要参数列表不同就形成重载，参数列表包括：
    1. 参数个数.
    2. 参数类型.
    3. **不考虑**（忽略）形参名.

<br>

- 为什么Java不将返回值类型作为重载依据？
  - 原因很简单：**Java允许不利用返回值调用一个方法**
  - 因此返回类型重载的方法定义会直接导致**编译报错**！！
    - 例如：

```Java
// 如果它俩能重载的话（实际直接编译报错）
int f();
String f();

String s = f();  // 虽然利用返回值时可以却别调用的是哪个版本
f(); // 但Java允许不利用返回值去调用一个方法，此时的歧义就无法解决了！
```

<br><br>

### 六、可变参数方法：[·](#目录)
> 即printf那样的参数个数不确定（可变）的方法.

<br>

**1.&nbsp; 定义语法：**

```Java
/**  
 *  即可变参数的类型必须写成type...
 *    - 表示传参的时该可变参数可以接受**≥0个**参数
 *
 *  - type和...之间可以有连续空格，但不建议加，这样可读性不好
 *  - 还有就是...必须加载类型和参数名之间，加载其它地方编译报错
 */
public void func(int a, String... args);
```

<br>

**2.&nbsp; 定义和使用规则：** 和其它编程语言规则相同

1. 必须作为**最后一个**参数.
2. **最多只能有一个.**

- 否则编译报错.
  - 毕竟违反这两个规定都会导致方法调用时**产生歧义**.
    - 这很容想明白.

<br>

**3.&nbsp; 可变参数在底层是用Java数组实现的，和数组是相互相兼容的：**

- type... 底层**恒等于** type[]

```Java
// 对于
public void func(int a, String... args);
// 可以这样调用
obj.func(5, new String[]{"abc", "def", "xyz"});  // 即传入相应类型的数组即可
```

<br>

- 注意**错误的调用方式：**

```Java
/** 1. 传入简化版的数组
 *    - 虽然从传参角度看没问题
 *    - 但编译器不支持这样的语法
 */
obj.func(5, {"abc", "def", "xyz"}); // 错误

/** 2. 连续传入多个数组
 *    - 记住：1个type... 很等于 1个type[]，不是1对多的关系，是1对1！
 */
obj.func(5, new String[]{"abc"}, new String[]{"xyz"});  // 错误
```

<br>

**4.&nbsp; 重载可变参数方法所产生的歧义不会被编译求察觉！！**

- 尽量**不要**重载可变参数方法.

```Java
// 对于一下两个
void test(int arg);
void test(int... args);

/**  
 *   和它俩的定义顺序无关
 *   - 即使歧义了也不会编译报错，可以正常运行
 *   - 只不过调用的永远都是test(int arg)的版本
 *
 *   因此如果两者实现差异较大，且完成的功能不同
 *   - 但你真正想调用的是后一个的话，那就会造成致命错误
 */
test(1); // 调用的是test(int arg)版本
```

- **排除**可变参数方法重载的**歧义**：
  - 调用时**使用数组传参**即可：test(new int[]{ 1 });

<br><br>

### 七、单例模式：[·](#目录)
> 单例类就是指该类**最多只能**创建**一个**对象（用各种技术手段去限制住这个条件）.
>
>> 通常需要使用到单例的原因：
>> - 要么就是为了**降低系统开销**.
>> - 要么这种类型的对象创建多个是木有任何意义的，最多要一个就行，例如：
>>   1. 窗口管理器.
>>   2. 假脱机打印设备.
>>   3. 数据引擎访问结点.
>>   4. 等等.

<br>

- 单例模式的**设计思路**：
  1. 考虑到 **静态数据成员在一个JVM进程中只会保存一份**.
    - 因此 **单例对象** 必须作为 **静态数据成员**.
  2. 首先，**构造器** 的访问肯定是受限的：**必须是private的**
    - 如果构造器都是public的话那么就可以随意构造，远远超出一个对象了.
  3. 即便是单例，外界还是要访问它的.
    - 考虑到：
      1. 封装的要求（数据成员必须private），因此单例对象也是private的，外界不能直接访问.
      2. 构造器也是private的，也不能通过构造器的返回值来访问对象.
    - 因此：
      - 必须提供一个public的**静态**方法来获取该单例对象.
        - 必须是**静态**方法，因为构造器是private，如果是对象方法的话，连对象都取不到何谈对象方法呢？

<br>

- 根据以上3原则给出单例模式设计模板：

```Java
class Singleton {
	private static Singleton instance;  // 原则1
	private Singleton() {} // 原则2
	public static Singleton getInstance() { // 原则3
		if (instance == null) { // 原则3，判空 & 一次性构造
			instance = new Singleton();
		}
		return instance;
	}
}    
```
