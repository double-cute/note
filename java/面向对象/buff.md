# 基础概念


<br><br>

## 目录

1. []()
2. []()

<br><br>

### 一、

### 4. 主程序入口main：

1. Java中的方法名可以任意取，因此private double main(Date d);这样的方法也是合法的.
2. 但不过**作为主程序入口**的main方法只能定义成：public static void main
  - 并且合法的方法签名可以是：
    1. main(除了单独一个String[]外的任意形参列表)
      - 虽然编译没错，但**会引发JavaFX运行时异常**，别问我为什么.
    2. 可以抛出任意类型的异常，随便抛，任性.
      - 不会有任何编译时和运行时错误.
    3. 但最最标准的签名是：public static void main(String[] args);

    ### 一、命令行参数：[·](#目录)
    > 即Java应用程序入口的那个main方法的String[] args参数.

    1. 命令行参数是从**程序名称之后开始算**的：java JavaApplication **arg0 arg1 arg2 ...**
      - **[arg0, arg1, ...]** 就是 **Java应用程序JavaApplication** 的命令行参数.
    2. [arg0, arg1, ...]分别对应main形参args[0]、args[1]、...
    3. 命令行参数是**用空格作为分隔符**，**如果参数本身是包含空格的，则该参数应该用双引号""引起来**，避免其中的空格被当做参数分隔符.

    3. 方法的参数传递机制：值传递
        1) Java的方法参数传递全部采用值传递；
        2) 基本类型直接创建器副本作为参数，对于引用类型（对象，只能用引用来访问它）也是值传递，参数仅仅就是指针的副本；
        3) 因此swap方法只对基本类型有效，但是对引用类型无效，因为在内部交换的仅仅是两个副本引用，并不影响外部真正的实参；

    4. 可变参数方法：
        1) 即printf那种参数个数不确定（可变）的方法；
        2) 定义语法：
             i. 可变参数的类型必须写成type...；
             ii. 例如：public void func(int a, String... args);
    ！！ 传参的时候可变参数可以接受0个或多个实参！！
        3) 规则：和其它语言中的可变参数的规定还是基本一致的
             i. 可变参数必须是最后一个参数；
             ii. 可变参数最多只能有一个；
    ！！违反这两个规定都会导致调用时产生歧义，很容想明白；
        4) 可变参数底层使用数组实现的！！
             i. 上面的public void func(int a, String... args);可以这样调用：obj.func(5, new String[]{"abc", "def", "xyz"});
             ii. 因为可变参数实质上使用数组实现的，但是这里不能传入多个数组（只能传一个）：obj.func(5, new String[]{"abc"}, new String[]{"xyz"});  // 错误！！！
        5) 尽量不要重载可变参数方法！！
             i. 原因是这样的，例子：test(int arg);  和  test(int... args);
             ii. 歧义发生在这样调用：test(5)，这样会调用test(int arg)，但由于两种方法执行内容可能相差很大，因此如果你想在只有一个参数时强制使用test(int... args)版本时就必须使用数组调用，test(new int[]{5});，但这样很麻烦；
             iii. 因此为了避免上述这种歧义的情况就尽量不要重载可变参数方法！！

1. 命名规范：
    1) 类：由多个单词连缀而成，单词之间不要分隔符，每个单词首字母大写，其余小写；
    2) 数据成员：应该是名词，多个单词连缀而成，首字母小写，其余单词首字母大写，其余小写，中间不要使用分隔符；
    3) 方法：应该以英文动词开头，命名规则和数据成员相同；

2. 方法重载：
    1) 重载在所有语言中的最基本要求是一致的，必须、至少要求方法名要相同才会有重载的可能；
    2) 重载的条件——方法签名：
         i. 不同语言的方法签名不太相同，像Swift把返回值类型也加入到了方法签名中了，而有些语言像Java就不是；
         ii. Java规定的方法签名：就只有参数列表（参数个数、类型，但是不管形参名，形参名忽略），只有参数列表不同才会形成重载（不包括返回类型和方法修饰）！
    3) 为什么不加入返回值类型呢？Java是这样解释的，如果参数列表相同但返回值类型不同的方法，Java是允许调用方法不利用返回值的（即单独调用方法，例如对于int f();可以int a = f(); 也可以f();这样调用），即如果出现f()这样的调用方式编译器就无法判断应该使用哪个重载版本，即发生歧义，因此会编译报错！所以Java不把返回值类型加入方法签名中；

    1. Java的常量池：
        1) 一般来说，常量对一个编程语言来说就是指编译时就可以确定的值，说白了就是字面值；
        2) 例如数字字面值5、1.3、5L、0xAFF，字符串字面值"lala"等；
        3) 和C/C++管理常量不同的是（C/C++直接将常量编译到代码段里了，例如b = val + 5就直接编译成add b, val, 5，这个5直接出现在代码段中），Java使用常量池来管理常量；
        4) Java常量池更加严谨和高效：
             i. 编译的时候先扫描出所有程序中用到的常量，然后把他们放在同一的一段内存空间中存放，即常量池；
             ii. 并且所有值相等的常量只保存一份（减少内存消耗），所有在代码中对常量的引用都链接到常量池中相应常量的地址；
        5) 示例：
    String s1 = "1234";
    String s2 = "12";
    String s3 = "34";
    String s4 = "12" + "34"; // 虽然是相加后的结果，但是相加的结果也是能在编译时确定的，就是等于"1234"，因此可以在常量池中找到
    out.println(s1 == s4);  // true
    out.println(s1 == new String("1234"));  // false，一个在常量池，一个在堆中
    out.println(s1 == s2 + s3);  // false，所有使用变量相加的结果都是编译时无法确定的（运行时确定），因此不会从常量池里找，而是直接new一个隐藏对象保存相加结果




    1. 单例模式的应用：
        1) 单例类就是指该类最多只能创建一个对象，不能创建超过一个的对象；
        2) 这样做的原因：要么就是为了降低系统开销，要么这种类型的对象创建了多个没有任何意义，最多只需要一个就行，例如窗口管理器、假脱机打印设备、数据库引擎访问结点；

    2. 单例模式的模板：
        1) 这种模式下构造器的使用肯定是受限的！因为不能让外界自由使用，否则就能创建多个对象了，因此构造器一定是private的！
        2) 由于只有静态数据成员只会保存一份（对象数据成员是跟随对象保存的，有几个对象就有几份对象数据成员），因此单例模式的单例对象也必须是静态的；
        3) 虽然构造器是private的，外界不能访问，但你尽管是单例，那这个单例外界还是需要使用的，否则没有任何意义，因此必须要提供若干静态方法来访问这个静态的单例对象；
        4) 模板就是根据上面这三条原则设计的：
    class Singleton {
    	private Singleton() {} // 私有的构造器

    	private static Singleton instance;  // 单例对象设置为静态，这样就只能保存一份了
    	public static Singleton getInstance() { // 使用静态方法来访问该单例对象
    		if (instance == null) {
    			instance = new Singleton(); // 自己内部是可以访问私有的构造器的
    		}
    		return instance;
    	}
    }
