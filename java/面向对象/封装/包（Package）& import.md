



4. 包——package：
    1) 为了解决命名冲突，和C++使用命名空间不一样的是，Java使用包来管理类库；
    2) 只要在.java源文件的第一个非注释行放置代码：package 包名;
！！这就把该源文件下的所有类都归到该包中了，其中package是关键字，专门用于定义包；
！！package语句一个源文件中最多只能有一句；
    3) 包名的命名规范：
         i. 应该全部是小写字母；
         ii. 用多个有意义的单词用.连缀而成，中间不要有其它分隔符；
         iii. 例如：package com.lirx;    // 该包就是com.lirx
    4) 完整的类名：
         i. 一个类的完整类名应该是包括包路径在内的；
         ii. 例如：类Person位于包com.lirx下，那么Person的完整类名应该是com.lirx.Person；
         iii. 在任何地方都可以使用类的完整类名（包路径）来表示该类；
         iv. 一个类所在的包就相当于该类的命名空间了，就是用来防止命名冲突的；
    5) javac自动产生包目录结构：
         i. 使用javac -d dir Xxx.java后会直接在dir目录下产生和package定义的包路径一样的文件结构；-d指定编译生成的字节码应该放在哪个目录下！
         ii. 例如上面的com.lirx.Person的源文件使用javac -d . Person.java编译后，会在当前目录下生成一个/com/lirx/Person.class的目录结构；
         iii. Java规定：位于包中的类，在文件系统中也必须与包层次结构相同的目录结构！
              a. 原因很简单，因为Java程序就是一个个类，一般一个源文件就代表一个类，在程序中需要用包路径来防止命名冲突，那么在文件系统中同样为了防止命名冲突，使用目录结构就再合适不过了，因此两者统一起来了；
              b. 并且Java还规定，如果.class在文件系统中的目录结构和package定义的不符，那就无法在程序中使用这个类！！使用时运行时无法通过，表示找不到该类，也就是说文件目录结构必须和package定义的包路径完全相符才能正常使用程序！！！！
              c. 其实javac的-d选项除了可以指定生成项目所在的目录之外还有另一个功能，就是自动根据package语句生成相应的包目录结构！如果没有-d选项则不会生成宝目录结构，这样的类将无法使用，除非自己手动检录目录来符合package定义的包目录结构才行！
！！因此一个良好的习惯就是使用-d选项来编译Java源文件！
          iv. 注意package的包路径和文件系统的包目录结构之间的关系：
               a. 是现有package定义的包路径才有包目录结构的！！
               b. 即包目录结构必须符合包路径才行！！
               c. 并不是你先建立包目录结构包路径才生效的！加入你先建立了一个目录结构：com/lirx/Person.class，而编译时Person.java中并没有package语句，那么Person的完整类名就是Person而不是com.lirx.Person，包路径始终是由package语句定义的！
    6) 使用Java运行带有包路径的类：
         i. 必须在包路径的根目录下使用命令"java 包路径名"才行；
         ii. 例如：包路径（目录结构）为dir/com/lirx/Person.class，其包路径名为com.lirx.Person，那么就必须在dir目录下使用命令java com/lirx/Person才行！！
         iii. 不能在其它目录下运行该命令，也不允许直接java Person，必须要有完整的包路径！

5. 用包来管理项目：
    1) 包除了可以防止命名冲突外还可以进行项目管理；
    2) 由于包本身即是一种树状结构（目录结构），因此具有天然地项目管理的优势；
    3) 包的标准的命名规范：公司域名的倒写.项目名.模块名.组件名
！！由于软件公司众多，即是包路径很长也很难保证命名不会冲突，但是网站域名绝对是唯一的，因此用域名的倒写能保证命名绝对不会发生任何冲突！！！
    4) 例如一个完整的包路径类名：com.lirx.ebay.submit.hint.Toolbar
！！其中com.lirx是公司域名的倒写，ebay表示一个电子购物网站的项目，submit表示网站的提交模块，hint表示提交模块中的一个自动提示组件（也是一个包），而Toolbar.class就是组件中的一个类，表示工具栏这个类；

6. 在同一个包中可以省略包路径，在不同包中必须使用完整的包路径：
    1) 包路径一般都很长，每次使用类名都写完整的包路径将会是一件非常麻烦的事，而且代码显得非常臃肿；
    2) Java允许在同一个包中使用包中类可以省略包路径而直接使用类名！！
    3) 但是要注意的是！这个规则不包括具有父子关系的包结构！
         i. 例如包A包含包B，那么在包A的某个类中使用包B的某个类还是必须的用完整的路径名而不能省略包路径！！
         ii. 因为虽然目录结构上具有父子关系，但它们仍然是两个不同的包！！
         iii. 因此，只要是不同的包就必须用完整的包路径！！！

7. 使用import导入包：
    1) 包内的类使用时可以省略包路径，而包外的类想省略包路径就必须使用import语句来导入包了；
    2) import语句必须位于package语句之后和类定义之前！
    3) 导入语法：
         i. 导入单个类：import 类的完整包路径;   // 例如import java.util.Date;
         ii. 导入包中的全部类：import 包名.*;  // *表示通配符，表示包下的所有类
！！注意！*只能表示所有类，但并不能代表子包！！*并不能同时导入子包中的所有类！！
    4) 使用被导入的类时可以省略包路径，直接使用类名就行了；
    5) 极端情况：例如java.util包中有个Date，而java.sql包中也有个Date，现在这两个类都要使用，即使import了也无法省略包路径了，因为一个Date是无法判断出使用的是哪个包下的，因此在这种情况下就不能省略包路径了；
    6) 静态导入：
         i. 在JDK 1.5后允许导入类的静态成员和方法了，语法是：import static 导入内容;
         ii. 不带static的import只能导入类的对象部分，不能导入静态成员，如果想使用类的静态成员时省略包路径就必须使用import static导入；
         iii. 导入语法：
              a. 导入某一个具体的静态成员：import static 包路径.成员名;   // 成员可以是静态变量也可以是静态方法（方法就只要写个方法名就行了）
！！例如：import static java.utils.sort;  // 就只导入了utils的静态方法sort
              b. 导入一个类的所有静态成员（同时包括变量和方法）：import static 包路径.*;
！！同样*表示一个包中的所有静态成员，并不能代表其子包！！
          iv. 典型应用：import static System.*;   // 然后既可以直接在程序中写out.println(..)之类的了
