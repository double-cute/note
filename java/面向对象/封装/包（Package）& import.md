# 包（Package）& import
> 为了**解决命名冲突**，和C++使用命名空间不一样的是，Java使用包来管理类库.
>
>> 1. Java要求所有类都必须放在包中.
>> 2. 在代码中使用任何类都需要加上包名前缀.
>>    - 除非**事先用import语句导入包**才可以省略前缀使用一个类.
>> 3. 包就是Java中类的**命名空间**.
>>
>>> 除了基本类型没有包（命名空间）外，其它所有Java类（引用类型）都必须放在包中管理.
>>>
>>> - **包中存放的单位是类.**

<br><br>

## 目录

1. []()
2. []()

<br><br>

### 一、用package关键字指定代码中类所属的包：
> 只要在.java源文件的**第一个非注释行上**放置语句：**package 包路径;**
>
>> - 编译器就会把 **该源文件中** 定义的 **所有类** 都 **归到该包中**.
>>    - 编译出来的Xxx.class类在使用时必须加上包路径前缀，例如：
>>    - java com.example.Xxx  // 要在com/目录的上一级目录中运行该命令
>> - 源文件中**最多只能有一句**package.

<br>

**1.&nbsp; 包路径的命名规范：**

1. 全部小写.
2. 多个有意义的单词用"."连缀而成.
3. 中间不要有其它分隔符.

- 例如：package com.lirx;

<br>

**2.&nbsp; 完整的类名要有包路径：** 全限定类名

> 完整的类名称为**全限定类名**.

- 例如：类**Person**位于包**com.lirx**下，那么Person的完整类名应该是**com.lirx.Person**
- **在任何地方都可以使用全限定类名.**
   - 不管有没有import过，使用全限定类名一定不会错！
   - 只不过import后可以省略包路径而已.

<br><br>

### 二、在没有import时包路径的省略规则：
> 包路径一般都很长，为了不使代码臃肿应该能省略就省略.

<br>

- 省略规则描述：在**同一个包中可以省略**包路径，在不同包中必须使用完整的包路径：
  - 同一个层级的包中，各类相互使用可以省略包路径而直接使用类名.
  - **但不包括父子关系的包！**
     - 例如包A包含包B（目录结构是A/B/...），但包A和包B还是两个不同的包.
     - 这就意味着，**包A中除了包B之外的其它一切** 要使用包B中的类都必须使用全限定类名.

<br><br>

### 三、用包来组织和管理项目：包路径命名规范
> Java的包路径除了可以防止命名冲突外还可以有效地行使项目组织和管理的功能.
>
>> 包路径本身就对应了一种目录结构.

<br>

- 包路径命名的国际规范：**公司域名的倒写.项目名.模块名.组件名**
   - 毕竟软件庞大起来完全有可能导致项目名、模块名、组件名同时冲突.
   - 因此就想出了将域名倒写放在包路径里的方法.
      - 毕竟域名在全世界范围内是唯一的，这就从源头上解决了明明冲突的问题.
   - 其次是这个规范的思路是，**从大到小分解一个项目**，最小到达组件的级别.

<br>

- 示例：com.company.ebay.submit.hint.Toolbar
   1. com.company是公司域名.
   2. ebay是项目名，表示一个购物网站.
   3. submit是一个提交系统.
   4. hint是一个组件，起到提示作用.
   5. Toolbar.class是该组件中的一个类.

<br><br>

### 四、包路径到文件系统的映射：

    5) javac自动产生包目录结构：
         i. 使用javac -d dir Xxx.java后会直接在dir目录下产生和package定义的包路径一样的文件结构；-d指定编译生成的字节码应该放在哪个目录下！
         ii. 例如上面的com.lirx.Person的源文件使用javac -d . Person.java编译后，会在当前目录下生成一个/com/lirx/Person.class的目录结构；
         iii. Java规定：位于包中的类，在文件系统中也必须与包层次结构相同的目录结构！
              a. 原因很简单，因为Java程序就是一个个类，一般一个源文件就代表一个类，在程序中需要用包路径来防止命名冲突，那么在文件系统中同样为了防止命名冲突，使用目录结构就再合适不过了，因此两者统一起来了；
              b. 并且Java还规定，如果.class在文件系统中的目录结构和package定义的不符，那就无法在程序中使用这个类！！使用时运行时无法通过，表示找不到该类，也就是说文件目录结构必须和package定义的包路径完全相符才能正常使用程序！！！！
              c. 其实javac的-d选项除了可以指定生成项目所在的目录之外还有另一个功能，就是自动根据package语句生成相应的包目录结构！如果没有-d选项则不会生成宝目录结构，这样的类将无法使用，除非自己手动检录目录来符合package定义的包目录结构才行！
！！因此一个良好的习惯就是使用-d选项来编译Java源文件！
          iv. 注意package的包路径和文件系统的包目录结构之间的关系：
               a. 是现有package定义的包路径才有包目录结构的！！
               b. 即包目录结构必须符合包路径才行！！
               c. 并不是你先建立包目录结构包路径才生效的！加入你先建立了一个目录结构：com/lirx/Person.class，而编译时Person.java中并没有package语句，那么Person的完整类名就是Person而不是com.lirx.Person，包路径始终是由package语句定义的！
    6) 使用Java运行带有包路径的类：
         i. 必须在包路径的根目录下使用命令"java 包路径名"才行；
         ii. 例如：包路径（目录结构）为dir/com/lirx/Person.class，其包路径名为com.lirx.Person，那么就必须在dir目录下使用命令java com/lirx/Person才行！！
         iii. 不能在其它目录下运行该命令，也不允许直接java Person，必须要有完整的包路径！





7. 使用import导入包：
    1) 包内的类使用时可以省略包路径，而包外的类想省略包路径就必须使用import语句来导入包了；
    2) import语句必须位于package语句之后和类定义之前！
    3) 导入语法：
         i. 导入单个类：import 类的完整包路径;   // 例如import java.util.Date;
         ii. 导入包中的全部类：import 包名.*;  // *表示通配符，表示包下的所有类
！！注意！*只能表示所有类，但并不能代表子包！！*并不能同时导入子包中的所有类！！
    4) 使用被导入的类时可以省略包路径，直接使用类名就行了；
    5) 极端情况：例如java.util包中有个Date，而java.sql包中也有个Date，现在这两个类都要使用，即使import了也无法省略包路径了，因为一个Date是无法判断出使用的是哪个包下的，因此在这种情况下就不能省略包路径了；
    6) 静态导入：
         i. 在JDK 1.5后允许导入类的静态成员和方法了，语法是：import static 导入内容;
         ii. 不带static的import只能导入类的对象部分，不能导入静态成员，如果想使用类的静态成员时省略包路径就必须使用import static导入；
         iii. 导入语法：
              a. 导入某一个具体的静态成员：import static 包路径.成员名;   // 成员可以是静态变量也可以是静态方法（方法就只要写个方法名就行了）
！！例如：import static java.utils.sort;  // 就只导入了utils的静态方法sort
              b. 导入一个类的所有静态成员（同时包括变量和方法）：import static 包路径.*;
！！同样*表示一个包中的所有静态成员，并不能代表其子包！！
          iv. 典型应用：import static System.*;   // 然后既可以直接在程序中写out.println(..)之类的了
