# 表的创建、修改、删除
> 主要包含create、alter、drop、truncate语句.

<br><br>

## 目录

1. []()
2. []()

<br><br>

### 一、DDL & 数据对象：[·](#目录)
> 即Data Definition Language，即数据定义语言，操作的对象是 **数据库对象**，主要用来 **定义数据对象**.
>
>> 但为了记忆方便，通常将DDL的操作对象范化为数据表，但其实 **数据表只是8大数据对象之一**.

<br>

- 8大数据对象，大致可以分为4大类：

<br>

1. 存储的数据（表）：
   - 1. table表：普通用户表.
   - 2. metadata：数据字典，即元数据表(metadata table)，也称为系统表.
2. 数据关系（约束）：
   - 3. constraint约束：即数据校验规则，可以保证数据的完整性和一致性.
   - 4. index索引：用于提高查询效率.
3. 查询结果（临时数据）：
   - 5. view视图：一条select语句脚本，用于显示临时查询结果.
4. 代码：
   - 6. function函数：一次小规模计算，可返回结果.
   - 7. procedure存储过程：一次大规模的作业流程，不能返回结果，但结果可以通过输出参数返回.
   - 8. trigger触发器：事件的监听/响应.

<br>

- 可以看到DDL操作的都是 **抽象模型**，而不是具体的数据项.
   - 具体的数据项由DML语句来操作.

<br><br>

### 二、创建表：create table  [·](#目录)
> 创建表其实是定义表的属性结构，是一种抽象模型.
>
>> 表结构涵盖了：
>>
>> 1. 多少列.
>> 2. 列的数据类型、约束.
>> 3. 表的存储机制.
>> 4. 等等.
>>
>>> **并不插入实际的数据.**
>>>
> - 所有在数据库中建的用户表都可以在 **元数据表information_schema.TABLES** 中被记录.
>    - 这是系统数据库中的系统表.

<br>

**1.&nbsp; 定义语法：**

```SQL
create table [if not exists] [模式名.]表名
(
    列名1 类型 [其它属性和约束],
    列名2 类型 [其它属性和约束],
    ...
) [存储机制定义];
```

<br>

**2.&nbsp; [if not exists]：**

- 正常情况下不允许重复建表，如果已存在则会拒绝建表.
- 加上if not exists选项的话就表示如果已存在就不建表，从而不会报错.

<br>

**3.&nbsp; 列定义之间用逗号','隔开，最后一列的定义后不加逗号.**

<br>

**4.&nbsp; 表的存储机制：**

- MySQL支持两种存储机制：
   1. MyISAM：一种早期的存储机制，对事务支持不够好.
   2. InnoDB：提供良好的事务控制和安全机制.
      - 事务是J2EE最重要的特性，因此通常推荐使用InnoDB机制.
      - 5.0以上版本的MySQL默认开启的就是InnoDB表存储机制.
- 可以在建表语句最后使用 **ENGINE选项** 显式指定表的存储机制：
   1. ENGINE=MyISAM
   2. ENGINE=InnoDB

<br><br>

### 三、子查询建表：create table as  [·](#目录)
> 即利用另一个select查询的结果来建表.
>
>> 本质上等价于 **将一个视图建成一张实实在在的表（具有存储空间）**.
>>
>> - 但语法上又不支持直接将视图转化成表.

<br>

- 语法：

```SQL
create table [if not exists] [模式名.]表名
as
  select查询
;

-- 示例：
create table IF NOT EXISTS test_table
as
  select Name, Age from stu_table
;
```

<br>

1. 不仅完全继承select结果的列数、类型.
2. 同时也完全复制了一遍行.
   - 即 **表结构** 和 **表数据项** 通通复制.

<br><br>

### 四、默认值约束 & 数据类型：[·](#目录)

<br>

**1.&nbsp; 默认值约束：**

- 为列指定默认值，这样在insert行时可以不指定该列的值默认使用预设的值.

```SQL
列名 类型 [其它约束] default 默认值

-- 示例：
stu_name varchar(255) default 'Peter'
```

<br>

**2.&nbsp; 数据类型：**

- 所有MySQL支持的数据类型均可从下面的引用参考处查阅：
   - [http://www.runoob.com/mysql/mysql-data-types.html](http://www.runoob.com/mysql/mysql-data-types.html)

<br><br>

### 五、修改表结构：alter table  [·](#目录)
    1) 使用alter关键字，其格式为：alter table 表名 选项;
    2) 具体怎么修改表结构关键就在这个选项上，注意：这里能修改的仅仅是表的结构，即属性（列）的数据类型、默认值、约束等等，但是不能改变表中的数据；
！！因此alter table的作用对象是表的结构而不是表中的数据；
    3) 增加字段（属性/列）：使用add选项，增加大于1列用括号括起来，只增加一列则不用，格式如下
add
(
    增加列1 类型 [其它属性和约束] [first|after 列名（插入到哪列之后）],
    增加列2 类型 [其它属性和约束] [first|after <span style="font-family: Arial, Helvetica, sans-serif;">列名（插入到哪列之后）],</span>
    ...
);
！只增加一列可以不用括号；
！！如果是first表示插入到第一列，“after 列名”表示插入到“列名“所在的列之后，什么都不写表示简单地追加到最后一列；
    4) 如果数据表里已经有数据了，则加完这一列之后该列的值必定为空，因此此时决不能将这列指定为非空（NOT NULL），因为两者逻辑冲突，会直接报错，除非该表还没有任何数据，或者为改列定义默认值；
    5) 修改已有的列（字段/属性）：add是无中生有，而modify则用来修改已有的列（数据类型、约束等，所有都能修改，就是列名不能修改），并且一次只能修改一列，不能同时修改多列（标准SQL规定的，但是有些数据库实现允许同时修改多列，比如Oracle，但是MySQL还是执行了SQL的标准），格式如下
<pre name="code" class="sql">modify 要修改的列的列名 新的数据类型 [新的属性以及约束] [first|after 要插在之后的列名];
！！可以看到修改的不仅仅可以是数据类型、属性约束等，也开改变改列的位置哟！！
    6) 虽然标准SQL不支持修改列名，但是通常修改列名是广泛需求的，因此MySQL提供了change选项，该选项作用和modify完全一样，只不过多了一个修改列名的功能，格式如下：
modify 要修改的列的列名 新的数据类型 [新的属性以及约束] [first|after 要插在之后的列名];
！就多了一个参数而已，即第三个参数是新的列名；
！change选项不是标准SQL语法，而是MySQL自己提供的；
    7) 删除列：drop 列名;
！！只支持一次删一列，不能一次删多列；
    8) 修改表名：标准SQL不支持修改表名，但MySQL还是提供了这个功能，选项格式是：rename to 新表名;
！！可以看到，标准SQL并不提倡修改列名和表名，希望创建时就确定而不要后期再改动，原因很简单，因为一旦名称发生改变，那么所有依赖数据库的应用程序可能也需要修改，这就加大了维护的难度
    9) 修改表结构并非总能成功，因为修改必须符合原有的规则和约束，否则系统会因数据不完整而拒绝修改，从而报错！
！！因此尽量在设计表的时候就确定表的结构，后期再改变表的结构将会非常被动（产生大量连带效应）；

5. 删除表：
    i. 使用drop关键字，格式：drop table 表1[, 表2, ...];
    ii. 可以看到支持一次删除多个表；
    iii. 删表总是可以成功的，删除后表结构、表中的所有数据、所有的索引和约束也统统删除；

6. 删除表中的数据但不删除表结构——truncate：
    i. 格式：truncate 表名;
    ii. 该SQL语句仅仅删除了表中的全部数据，但是仍保一张空的该表，同时保留表的结构；
    iii. 在没有truncate语句之前是使用delete来逐条删除表中的数据达到该目的，因此为了方便达到该目的（减少编程工作量）就提供了truncate语句；
    iv. 在MySQL5.0.3之前，truncate底层只是简单调用delete，因此和delete效率一样，但是在这之后大大优化了truncate，因此现在truncate总比delete要高效；
