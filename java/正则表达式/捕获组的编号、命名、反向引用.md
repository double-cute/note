# 捕获组的编号、命名、反向引用

<br><br>

## 目录

1. [捕获组及其编号](#一捕获组及其编号)
2. [捕获组的命名](#二捕获组的命名)
3. [普通捕获组/命名捕获组的混合编号问题](#三普通捕获组命名捕获组的混合编号问题)
4. [捕获组的反向引用](#四捕获组的反向引用)

<br><br>

### 一、捕获组及其编号：[·](#目录)
> 之前讲过，捕获组就是 **匹配到的内容** 按照 **( )** 划分成的若干组.

<br>

- **捕获组的个数**等于**( )出现的个数**.
  - 例如(ab)(cd(ef))就有3个捕获组.

<br>

- **捕获组编号规则：**
  1. **从1开始计.**
  2. 从左往右按照左括号(出现顺序从小到大编号，例如：

![](assets/matcher_group_number.png "捕获组编号规则")

<br><br>

### 二、捕获组的命名：[·](#目录)
> 如果捕获组的数量非常多，那用数字进行编号将非常混乱.
>
>> 毕竟数字本身没有实际意义，很难帮助记忆每个捕获组的功能.
>>
>>> 因此Java 7开始支持对捕获组命名，通过命名访问或者记忆一个捕获组**更加直观和符合逻辑**.

- 命名语法：**(?\<自定义名\>expr)**
  - 其中外围的 **( )** 定义了一个捕获组，这就不用多说了.
  - 在 **( )** 中必须以 **?\<自定义名\>** 起头表示对该 **( )** 定义的捕获组进行命名.
    - 不以这个起头会引发引擎编译错误.

<br>

- 是对 **?\<自定义名\>** 后的整个expr表达式（即捕获组命名）.
  - 例如：**(?<date>\\d{2}-(\\d\\d))**，date是对整个 **\\d{2}-(\\d\\d)** 的命名，并不是对紧接的 **\\d{2}** 命名.
  - 是对整个 **( )** 内容命名（以 **( )** 为单位整体命名）.

<br><br>

### 三、普通捕获组/命名捕获组的混合编号问题：[·](#目录)
> 如果表达式中的所有捕获组都是命名捕获组的话，编号规则和普通的相同（左括号从左向右编号）.

- 两类捕获组混合出现时的编号规则：
  1. 先**忽略掉命名捕获组**，对普通捕获组按照**左括号从左向右编号**.
  2. 接着再对命名捕获组按照**左括号从左向右继续编号**.

![](assets/matcher_group_number_int_name.png "普通和命名捕获组编号规则")

<br><br>

### 四、捕获组的反向引用：[·](#目录)
> 捕获组的作用就是为了在正则表达式内部或者外部（Java方法中）访问它.
>
>> 这样的访问就称为**反向引用**.
>>
>>> 可以通过**编号**或者**命名**对捕获组反向引用.

**1. 在正则表达式内部引用捕获组：**
         i. \X：X是一个十进制数，X的范围必须落在捕获组编号范围之内，该表达式就匹配X号捕获组所匹配到的内容；
         ii. 从上面的描述可以看出，\X匹配的内容是必须X号捕获组匹配成功之后才能确定的！
         iii. 例如：([ab])\1，匹配aabbcc的结果是aa和bb，\1的内容必须要让1号捕获组捕获后才能确定，如果1号捕获的是a那么\1就是a，1号捕获到了b那么\1就是b；
    4) 正则表达式外部引用：就是用Matcher对象的start、end、group查询匹配信息时，使用捕获组编号对捕获组引用（int group）；

    3) 命名捕获组的反向引用：
        i. 正则表达式内引用：\k<捕获组名称>
！例如：(?<year>\d{4})-\k<year>可以匹配1999-1999
        ii. 外部引用：Matcher对象的start、end、group的String name参数指定要查询的捕获组的名称；
