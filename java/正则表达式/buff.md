
> 由于正则表达式需要先编译再执行，因此也是一种**特殊的编程语言**，只不过这门语言内容精简、仅仅用来描述匹配模式串的动作而已，非常简单.
>
>> 但由于不同编程语言所支持的**正则表达式引擎各不相同**，因此在**语法上有所差异**. 这里我们只介绍Java正则表达式引擎所支持的语法规则.

### 一、关键字符和普通字符：

- **普通字符：** [A-Za-z0-9]
  1. 就像编程语言的**非关键字**，用途广泛.
  2. 只不过在正则表达式中就用来**匹配该字符本身**.
  3. 因此也称为**纯文本字符**.


<br>

- **关键字符：**
  1. 也是称为特殊字符，具有特殊意义.
  2. Pattern可以将其编译成特定的匹配动作函数组，诸如\*、()等.
    - **如果想匹配关键字符所代表的纯文本，则需要转义，例如：\\\*表示纯文本的'*'.**

<br><br>

i. \：转义字符，用于转义紧跟在它后面的下一个字符，使其具有特殊含义；
ii. ()：标记子表达式的开始和结束，即用()括起来的部分就是一个子表达式；
### 二、匹配单个字符：

<br>

#### 1. 纯文本字符：

| 字符类型 | 表示方法 | 注意事项 |
| --- | --- | :---: |
| 普通字符（已讲过，相对于关键字符）| A-Z、a-z、0-9 | 不包含关键字符<br>关键字符要么**转义**<br>要么用其**ASCII或者Unicode**编码表示（**下述**）|
| ASCII码表示 | 八进制：\0XX<br>十六进制：\0xXX | ASCII范围是[0, 128)<br>因此两者**最多只有两位**（XX）<br>但不到两位的**可以缺省一位**<br>十六进制A-F用**大写更美观**（小写当然也行）|
| Unicode表示 | \uXXXX | **必须是**十六进制形式<br>4位**一位都不能缺省**<br>ASCII表示可以缺省<br>A-F大写更美观 |

<br>

#### 2. 常用的控制字符：

| 控制符 | 意义 |
| --- | --- |
| \t | 制表 |
| \n | 换行 |
| \r | 回车 |
| \a | 蜂鸣（报警）|
| \cX | 表示组合控制符Ctrl+X<br>X是普通字符（大小写任意）<br>例如\cM就表示Ctrl+M |

<br>

#### 3. 一个范围内的单字符：中括号[]表达式

| 匹配类型 | 表达式 | 说明 |
| --- | --- | --- |
| 枚举 | [zkm] | 匹配z、k、m中的任意一个 |
| 连续范围 | [a**-**f] | 匹配a - f之间的任意一个字符（**包括边界**）<br>**右边界一定要大于左边界**<br>否则Pattern编译报错 |
| 并 | a-cm-p | [a-c]和[m-p]的并集<br>其实枚举也是一种特殊的并<br>（每个范围都只有一个字符而已） |
| 交 | a-z**&&**b-d | [a-z]和[b-d]的交集<br>结果等于[b-d] |
| 脱（非）| [^abc]、[^a-f] | 表示非a、b、c的任意一个字符<br>表示非a-f的任意一个字符 |
| 嵌套 | [a-m&&[def]] | 等于[d-f] |
| 复杂表达式 | [a-z&&[^bc]] | 等于[ad-z] |

- **关于脱字符^的特别说明：**
  1. ^必须是**[]中的第一个字符**才表示**非运算**，即**脱字符的含义**.
    - 如果不是第一个，那么就会被当做纯文本的'^'看待！
    - 例如：[a^b]就表示匹配a、^、b三个中的任意一个.
  2. 脱字符非的是**后面紧跟的`整个`表达式**！
    - 例如：[^abc]表示(非[abc])而不是(非a)并上([bc]).
  3. **注意：** 不要用^构造复杂表达式
    - 以下的表达式将不起任何作用.
      - 即**直接无效，没有匹配功能，直接导致错误**.
    - 因此，^后面**只能跟单纯的枚举和范围运算**，例如[^azh]、[^a-h]等.

| 非法形式 | 举例 |
| --- | --- |
| ^后面跟一个[ ]表达式 | ^[a-d] |
| ^后面跟一个交并补运算 | ^a-cf-h、^a-z&&c-h、^^a-c |

<br>

#### 4. 单字符通配符：匹配的是一个字符哟！一个哟！

| 形式 | 匹配内容 |
| --- | --- |
| . | 除了\r、\n之外的其它任意字符 |
| \d | 数字，digit，[0-9] |
| \D | 非数字，[^0-9] |
| \s | 空白（空白、制表、换行、回车、换页等），space |
| \S | 非空白 |
| \w | 单词字符，[A-Za-z0-9_]，注意**包括一个下划线'_'** |
| \W | 非单词字符 |

<br><br>

### 三、重复：重复的是前面紧邻的子表达式
> 所有表达式中不能有任何空格，否则引擎编译错误.
>
>> 例如{n,m}写成{n, m}就错了！
>>
>>> 还有就是范围边界不能有负数，例如{-1,5}就错了.

| 语法形式 | 说明（重复次数） |
| --- | --- |
| \* | ≥ 0 |
| + | ≥ 1，常用\w+匹配一个单词 |
| ? | 0或1 |
| {n} | 刚好n |
| {n,} | ≥ n |
| {n,m} | [n, m] |

<br>

- **贪婪模式和勉强模式：** 解决重复次数的歧义问题
  - 典型的歧义情况：如果x{2, 3}去匹配xxxx，既可以匹配xx，也可以匹配xxx，因此存在歧义.
    - 但任何编程语言（包括正则表达式引擎）都是**不允许有任何歧义**的，因此必须有**彻底消除歧义**的机制.
    - **记住！歧义就是低级错误！是彻彻底底的错误！**
  - 正则表达式的**重复次数匹配模式**：
    1. 贪婪模式：匹配**最多**，即使已经匹配上了，还要继续往下匹配，知道无法匹配为止.
      - 上面匹配的结果就是xxx.
    2. 勉强模式：匹配**最少**，遇到第一个匹配上的就停止，立马保存输出.
      - 上面的匹配结果就是xx.
      - 因此**勉强模式下，\*只匹配0个，+只匹配1个，?只匹配0个，而{ }只匹配下限**.
  - 例如：ab.\*zz去匹配abcxxzzsfewzzq，贪婪模式结果是abcxxzzsfewzz，勉强模式结果是abcxxzz.

<br>

- Java正则表达式引擎对两种模式的支持：
  - **默认情况下是`贪婪模式`.**
  - 勉强模式必须**在重复次数字符后加一个?**
    1. ??，勉强模式的?
    2. \*?，\*?就表示勉强模式的\*
    3. { }?，勉强模式的{ }

<br>

6. 匹配起始和结尾：锚
    1) ^：脱字符，匹配主串的开头，即必须以^后面紧跟的子表达式为开头，例如^abc可以匹配abcxxx，group的返回结果是abc
    2) $：锚字符，匹配主串的结尾，即必须以$前面紧跟的子表达式结尾，例如abc$可以匹配qqqxxabc，group的返回结果是abc
    3) 组合锚点：例如，^book.*end$可以匹配所有以book起始以end结尾的子串
    4) 脱字符必须作为模式串的起始，锚字符必须作为$模式串的结束，否则将不会起到任何作用！！
！例如，abc^xq并不能匹配abcxquuu，而abc$zx并不能匹配abczxddd！！

7. 匹配单词边界：boundary
    1) \b：前面紧邻的子表达式必须是单词的边界（单词之间用空白符分隔），例如：ok\b可以匹配"book lala"中的book的ok，但不能匹配"books lala"，group返回的也是ok
    2) \B：前面紧邻的子表达式必须“不是”单词的边界，例如：ok\B可以匹配"books lala"中的books的ok，但不能匹配"book lala"，group返回的也是ok

8. 或运算：|
    1) 表示指定两项（表达式）之间任选一项，即或运算；
    2) 例如a|b等于[ab]，(public)|(private)就表示这两个单词任意匹配一个，但最好不要写成public|private，这可能表示匹配publicrivate或者publiprivate，有些引擎就会判定歧义；
！！良好的习惯：自己不确定是否产生歧义的时候就加一下()变成子表达式，一目了然，而且可以避免错误！！

9. 所有特殊字符的纯文本形式都必须转义！
    1) 像.、^、$、\、|、[、]、{、}、(、)等特殊字符，如果想表示其纯文本形式，都必须使用\转义；
    2) 例如\(就表示纯文本的'('字符；

10. 在Java源代码中编写正则表达式：
    1) 由于正则表达式使用的是自己的字符，而Java源代码也有自己的字符，这就会导致两者之间发生一些不可避免的冲突；
    2) 最大的冲突就是\，正则表达式中\就是一个字符（特殊字符），而Java中要表示纯文本的\也需要转义，即用\\来表示纯文本的\；
    3) 而Java源代码中编写的正则表达式对于Java源代码来说应该是纯文本，这就意味着，Java源代码中编写的正则表达式中的\都必须要用\\来表示；
    4) 例如：正则表达式\w在Java源码中编写就必须写成\\w，比较麻烦
！小结：所有在Java源码中编写的正则表达式中的\都必须用\\表示，如果你觉得上面的原理看着头晕，那就记住这句简单的小结即可，无脑使用；
！！即先正常写好正则表达式，然后把里面所有的\换成\\即可；
    5) 一般为了避免这种麻烦的事情，都是先在程序外部的配置文件中写好正则表达式，然后在程序中读取、编译并使用，这就避免了两者字符集的冲突了；
