# Java正则表达式语法
> 由于正则表达式需要先编译再执行，因此也是一种**特殊的编程语言**，只不过这门语言内容精简、仅仅用来描述匹配模式串的动作而已，非常简单.
>
>> 但由于不同编程语言所支持的**正则表达式引擎各不相同**，因此在**语法上有所差异**. 这里我们只介绍Java正则表达式引擎所支持的语法规则.

<br><br>

## 目录

1. [关键字符和普通字符](#一关键字符和普通字符)
2. [转义](#二转义)
3. [匹配单个字符](#三匹配单个字符)
4. [重复：重复的是前面紧邻的子表达式](#四重复重复的是前面紧邻的子表达式--)
5. [匹配前后缀：脱和锚](#五匹配前后缀脱和锚--)
6. [匹配单词边界](#六匹配单词边界)
7. [子表达式 & 或运算](#七子表达式--或运算)
8. [在Java源代码的字符串中编写正则表达式：硬编码风格不推荐！](#八在java源代码的字符串中编写正则表达式硬编码风格不推荐-)

<br><br>

### 一、关键字符和普通字符：[·](#目录)

- **普通字符：** [A-Za-z0-9]
  1. 就像编程语言的**非关键字**，用途广泛.
  2. 只不过在正则表达式中就用来**匹配该字符本身**.
  3. 因此也称为**纯文本字符**.

<br>

- **关键字符：**
  1. 也是称为特殊字符，具有特殊意义.
  2. Pattern可以将其编译成特定的匹配动作函数组，诸如\*、()等.
    - **如果想匹配关键字符所代表的纯文本，则需要转义，例如：\\\*表示纯文本的'*'.**

<br><br>

### 二、转义：[·](#目录)
> 所有关键字符想要匹配其纯文本字符本身都要经过转义才行.

- 关键字符有：

| 字符 | 说明 |
| --- | --- |
| . | 单字符 |
| ^ | 脱 |
| $ | 锚 |
| \ | 转义 |
| \| | 或 |
| [] | 范围单字符 |
| + | 重复 |
| * | 重复 |
| ? | 重复 |
| {} | 重复 |
| () | 子表达式 |

<br><br>

### 三、匹配单个字符：[·](#目录)

<br>

#### 1. 纯文本字符：

| 字符类型 | 表示方法 | 注意事项 |
| --- | --- | :---: |
| 普通字符（已讲过，相对于关键字符）| A-Z、a-z、0-9 | 不包含关键字符<br>关键字符要么**转义**<br>要么用其**ASCII或者Unicode**编码表示（**下述**）|
| ASCII码表示 | 八进制：\0XX<br>十六进制：\0xXX | ASCII范围是[0, 128)<br>因此两者**最多只有两位**（XX）<br>但不到两位的**可以缺省一位**<br>十六进制A-F用**大写更美观**（小写当然也行）|
| Unicode表示 | \uXXXX | **必须是**十六进制形式<br>4位**一位都不能缺省**<br>ASCII表示可以缺省<br>A-F大写更美观 |

<br>

#### 2. 常用的控制字符：

| 控制符 | 意义 |
| --- | --- |
| \t | 制表 |
| \n | 换行 |
| \r | 回车 |
| \a | 蜂鸣（报警）|
| \cX | 表示组合控制符Ctrl+X<br>X是普通字符（大小写任意）<br>例如\cM就表示Ctrl+M |

<br>

#### 3. 一个范围内的单字符：中括号[]表达式

| 匹配类型 | 表达式 | 说明 |
| --- | --- | --- |
| 枚举 | [zkm] | 匹配z、k、m中的任意一个 |
| 连续范围 | [a**-**f] | 匹配a - f之间的任意一个字符（**包括边界**）<br>**右边界一定要大于左边界**<br>否则Pattern编译报错 |
| 并 | a-cm-p | [a-c]和[m-p]的并集<br>其实枚举也是一种特殊的并<br>（每个范围都只有一个字符而已） |
| 交 | a-z**&&**b-d | [a-z]和[b-d]的交集<br>结果等于[b-d] |
| 脱（非）| [^abc]、[^a-f] | 表示非a、b、c的任意一个字符<br>表示非a-f的任意一个字符 |
| 嵌套 | [a-m&&[def]] | 等于[d-f] |
| 复杂表达式 | [a-z&&[^bc]] | 等于[ad-z] |

- **关于脱字符^的特别说明：**
  1. ^必须是**[]中的第一个字符**才表示**非运算**，即**脱字符的含义**.
    - 如果不是第一个，那么就会被当做纯文本的'^'看待！
    - 例如：[a^b]就表示匹配a、^、b三个中的任意一个.
  2. 脱字符非的是**后面紧跟的`整个`表达式**！
    - 例如：[^abc]表示(非[abc])而不是(非a)并上([bc]).
  3. **注意：** 不要用^构造复杂表达式
    - 以下的表达式将不起任何作用.
      - 即**直接无效，没有匹配功能，直接导致错误**.
    - 因此，^后面**只能跟单纯的枚举和范围运算**，例如[^azh]、[^a-h]等.

| 非法形式 | 举例 |
| --- | --- |
| ^后面跟一个[ ]表达式 | ^[a-d] |
| ^后面跟一个交并补运算 | ^a-cf-h、^a-z&&c-h、^^a-c |

<br>

#### 4. 单字符通配符：匹配的是一个字符哟！一个哟！

| 形式 | 匹配内容 |
| --- | --- |
| . | 除了\r、\n之外的其它任意字符 |
| \d | 数字，digit，[0-9] |
| \D | 非数字，[^0-9] |
| \s | 空白（空白、制表、换行、回车、换页等），space |
| \S | 非空白 |
| \w | 单词字符，[A-Za-z0-9_]，注意**包括一个下划线'_'** |
| \W | 非单词字符 |

<br><br>

### 四、重复：重复的是前面紧邻的子表达式  [·](#目录)
> 所有表达式中不能有任何空格，否则引擎编译错误.
>
>> 例如{n,m}写成{n, m}就错了！
>>
>>> 还有就是范围边界不能有负数，例如{-1,5}就错了.

| 语法形式 | 说明（重复次数） |
| --- | --- |
| \* | ≥ 0 |
| + | ≥ 1，常用\w+匹配一个单词 |
| ? | 0或1 |
| {n} | 刚好n |
| {n,} | ≥ n |
| {n,m} | [n, m] |

<br>

- **贪婪模式和勉强模式：** 解决重复次数的歧义问题
  - 典型的歧义情况：如果x{2, 3}去匹配xxxx，既可以匹配xx，也可以匹配xxx，因此存在歧义.
    - 但任何编程语言（包括正则表达式引擎）都是**不允许有任何歧义**的，因此必须有**彻底消除歧义**的机制.
    - **记住！歧义就是低级错误！是彻彻底底的错误！**
  - 正则表达式的**重复次数匹配模式**：
    1. 贪婪模式：匹配**最多**，即使已经匹配上了，还要继续往下匹配，知道无法匹配为止.
      - 上面匹配的结果就是xxx.
    2. 勉强模式：匹配**最少**，遇到第一个匹配上的就停止，立马保存输出.
      - 上面的匹配结果就是xx.
      - 因此**勉强模式下，\*只匹配0个，+只匹配1个，?只匹配0个，而{ }只匹配下限**.
  - 例如：ab.\*zz去匹配abcxxzzsfewzzq，贪婪模式结果是abcxxzzsfewzz，勉强模式结果是abcxxzz.

<br>

- Java正则表达式引擎对两种模式的支持：
  - **默认情况下是`贪婪模式`.**
  - 勉强模式必须**在重复次数字符后加一个?**
    1. ??，勉强模式的?
    2. \*?，\*?就表示勉强模式的\*
    3. { }?，勉强模式的{ }

<br>

- **注意：** 匹配的是重复符前面**紧邻**的子表达式，**不是整个表达式**
  - 例如：
    1. ok[xy]+可以匹配"okxxyyPokyyxx"中的"okxxyy"和"okyyxx".
    2. (ok[xy])+才能匹配"okxokyokyokx"中的"okx"、"oky"、"oky"、"okx".

<br>

### 五、匹配前后缀：脱和锚  [·](#目录)

- 脱：^prefix
  - 检查**整个主串**是否**以prefix表达式**作为**前缀**，如果是则保存下该前缀.
  - **必须^作为整个表达式的开头** 才有匹配前缀的功能.
    - 如果放在中间则完全失效.
      - 例如"ab^dc"表达式**完全没用**，**丧失匹配功能**，^也**并不代表其纯文本字符本身**.
      - **不像中括号[]表达式中，如果^不是开头还可以代表其纯文本字符本身.**

<br>

- 锚：suffix$
  - 检查**整个主串**是否**以suffix表达式**作为**后缀**，如果是则保存下该后缀.
  - 同样的规则：
    1. 必须以$作为表达式的结尾，才会有匹配后缀的功能.
    2. **放在中间完全丧失匹配功能**，也不代表$纯文本字符本身！

<br>

- **注意：**
  - ^检查的前缀是^后的**整个表达式**，$检查的后缀是$前的**整个表达式**.
  - 例如：^(book)[abc]是检查是否以(book)[abc]一整个作为前缀，同样(book)[abc]$检查的是是否以(book)[abc]这一整个作为后缀.

<br>

- **组合锚点：** 检查首尾匹配
  - 即 **^prefix...suffix$** 的形式，同时检查**一整个主串**是否以prefix作为前缀、以suffix作为后缀、以...作为中间部分.
  - 例如："^hello.+bye$"可以匹配"hello, my friend, bye".

<br><br>

### 六、匹配单词边界：[·](#目录)
> 即boundary，\\b匹配单词边界，\\B匹配非单词边界.
>
>> 两者匹配的都是前面的整个正则表达式.
>>
>>   - 例如：(book)@[a-e]\\b匹配的就是一整个(book)@[a-e]，而不是紧邻的子表达式[a-e].


- expr\\b：检查主串中是否有**以expr表达式作为单词边界**的部分，如果有就保存expr匹配到的内容.
  - 例如：ok\\b可以匹配"book lala"中"book"的"ok"，但不能匹配"books lala"中"books"的"ok".
- expr\\B：匹配**非边界**.
  - 上例中可以匹配"books lala"中"books"的"ok"，但不能匹配"book lala"中"book"的"ok".

<br><br>

### 七、子表达式 & 或运算：[·](#目录)

- **用()定义子表达式：**
  - (expr)中被()包裹的(expr)一整个作为子表达式，将作为一个整体看待.
  - **()的结合性最强，跟任何其它编程语言一样.**
  - 凡是不确定是否应该加()的都加上()绝对没错！！

<br>

- 或运算：**expr1|expr2**
  - 表示两个表达式任选一，只要有一个匹配上即可，具有**短路**特性.
  - 示例：
    1. a|b 等于 [ab]
    2. abc|def 等于 abcef或abdef   // 一定要注意，是|邻接（**紧** 邻）的表达式
    3. (private)|(public) 等于 private或public   // 这就对了

<br><br>

### 八、在Java源代码的字符串中编写正则表达式：硬编码风格不推荐！ [·](#目录)
> Java是一门编程语言，而正则表达式也是一门编程语言.
>
>> 那么在Java源码字符串中以**硬编码**的方式编写正则表达式源码就遇到了**双重转义**的问题.

- 典型案例：
  - 如果按照正则表达式的语法写一个匹配一个单词的表达式因该是：\\w+
  - 但是现在要将这个表达式显式写在Java字符串常量中，如：String regex = "\w+";
    - 由于Java常量字符串中的\\纯文本本身也需要转义，因此就必须写成：
    - String regex = "\\\\w+";

<br>

- 编写窍门： **用System.out.print测试结果**
  1. 先按照标准正则表达式语法写出想要的正则表达式.
  2. 然后再观察其中哪些字符在Java常量字符串中须要转义的，再进行一轮转义即可.
    - 即用System.out.print打印2.的结果应该和1.一模一样！
- 就拿上面的例子：
  1. 先写出想要的表达式（标准正则表达式语法）：\\w+
  2. 发现\\字符在Java常量字符串中须要转义，再对其进行一轮转义即可：\\\\w+
    - 即System.out.println("\\\\w+")的结果应该是\\w+

<br>

- 由于须要额外的一轮转义，因此这种硬编码的方式编写正则表达式非常不提倡！
  - 非常容易出错！
  - 推荐方式：**通过配置文件注入**
    - 将正则表达式写入配置文件（无需额外转义）.
    - Java程序从配置文件中读取正则表达式（从外界依赖注入）.
