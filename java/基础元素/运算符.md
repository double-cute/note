# 运算符

<br><br>

## 目录

1. [模除运算%](#一模除运算)
2. [i++](#二i)
3. [赋值运算符](#三赋值运算符)
4. [比较运算符](#四比较运算符)
5. [逻辑运算符](#五逻辑运算符)
6. [三目运算符](#六三目运算符)
7. [位操作](#七位操作)
8. [运算符优先级总览](#八运算符优先级总览)

<br><br>

### 一、模除运算%：[·](#目录)

- 模除的本质：a % b = a - (a / b) * b

<br>

- 也就是说：**%运算依赖于除法运算/**，所以完全可以当做/运算来理解%的一些细节问题
  1. %支持浮点运算，结果可以是浮点数.
  2. 0或者0.0 % 非0数等于0.
  3. 如果b为0或者0.0，则不管a是什么，结果都是NaN.
    - 因为无法定义0乘以无穷大的结果：(a / 0.0) * 0.0是无穷大×0，结果无法确定.

<br><br>

### 二、i++：[·](#目录)

#### 强调一：可以用于`浮点数`
1. 只能用于基本数值类型，**但boolean不能用！**
2. 基本类类型中整型和浮点型都能使用，左右都是+1或者-1.

<br>

#### 强调二：Java的自加自减采用`中间变量缓存机制`
- **自加自减的中间变量缓存机制** 详细解读：
  - 如果把自加自减（i++、++i、i--、--i）看成一个表达式的话，那么这个**表达式的值是一个临时变量**！！
  - 规则是：按照操作顺序进行
    1. i++：{ temp = i; i = i + 1; return temp; }
    2. ++i：{ i = i + 1; temp = i; return temp; }

**案例1：**

```Java
i = i++;

// 等于
i = {
    temp = i;
    i = i + 1;
    return temp;
}
// 因此最终的i的值木有变化
```

<br>

**案例2：**

```Java
i = 0;
i = i++ + ++i + ++i + ++i;

// 等于
i = { temp = i; i = i + 1; return temp; } +
    { i = i + 1; temp = i; return temp; } +
    { i = i + 1; temp = i; return temp; }
  = 0 + 2 + 3 + 4
  = 9;
// 注意+的结合顺序是从左往右的！
```

<br>

#### 强调三：不要揣测C/C++的自加自减规则！没有用！
1. C/C++的自加自减最好单独用，不要像Java一样放在复杂表达式中！
2. C/C++的自加自减并不是严格的中间变量缓存机制！
  - 因此会出现各种奇葩的现象，可以看汇编代码，各种乱加lea指令.
  - 所以C/C++的自加自减就单独使用吧.

<br><br>

### 三、赋值运算符：[·](#目录)
> Java的赋值表达式是有值的.

1. Java的赋值运算符包括**普通的赋值运算符=**以及**复合赋值运算符+=、^=、>>>=** 等.
2. Java赋值表达式的值**等于运算符右边被赋的值**.
  - 例如：a = b = c = 5;
  - 在连续应用赋值运算符时也要注意，操作符左侧的操作数必须是变量！
    - 例如：a += 5 += 3;  // 错误！先计算5 += 3时发现5是常量而不是变量，但a += b += 3就对了
3. 结合性是**从右往左的**.
4. 赋值运算符的**优先级**在所有类型的运算符中**最最低**.

<br>

#### 复合赋值运算符`不检查类型冲突`：因为复合赋值运算符的本质是一种`位运算`

- 不像普通赋值运算符=，普通的=会检查两边的类型是否匹配，例如：short s = 5; s = s + 3; // 错误！s + 3是int，和short不兼容
  - 复合算符+=、^=、>>>=等不检查，例如：short s = 5;
    1. s += 5L;
    2. long d = 10L; s /= d;
    3. s -= 5.321f;
  - 以上都是正确的！！！

<br>

- 因为复合算符的本质是一种位运算，其算法过程是：
  1. 先无脑提取算符右边值的二进制位.
  2. 然后无脑地根据算符本身的规则用右边的二进制位修改算符左边变量内存空间的二进制位.
- 因此，在复合算符的眼里，**两边都是二进制位，根本无视类型**，这也是Java不完全面向对象的一点.

<br>

- 小结：复合算符的优缺点
  - 优点：很明显，二进制操作的效率极高，在高性能场合一定要积极使用复合算符.
    - **像for循环之类的变量迭代部分应该尽量用复合算符（i += 1，而不是i++）.**
  - 缺点：不检查类型，发生溢出等错误的风险需要开发者自己承担.

<br><br>

### 四、比较运算符：[·](#目录)
>> instanceof属于比较运算符！！
>
> 违反以下规则**通通都会在编译时报错**.

1. 基本类型不能和引用类型比较.
2. boolean类型不能喝其它任何类型比较，**只能和自己做等值比较（==）**，也不能做大小比较.
3. 引用类型之间的等值比较==比较的其实是**指向的对象的地址**.
  - 并且，**只有具有继承关系的两个引用之间能用==进行比较**，否则不行（**直接变异报错**）.
  - 引用类型之间最多只能进行==比较.
  - 这是Java强类型特点的完美体现（**只有继承关系的才能比较指针可以减少很多不必要的错误检查过程**）.

<br><br>

### 五、逻辑运算符：[·](#目录)

1. Java逻辑运算符严格规定，**两边的操作数必须都是布尔类型的！！** 否则会编译报错！
  - 这就告别了C/C++的各种浪了！很好，很赞！
2. 多了非简洁与&和非简洁或|：
  - 相对的，原来的&&和||是简洁与和简洁或.
  - 简洁形式的会短路，**第一个操作数的结果可能会短路掉发生在第二个操作数上的副作用！**
  - 非简洁形式的不会短路，两个操作数必定都会计算，因此不用担心发生在第二个操作数上的副作用被短路掉.
3. 由于**布尔类型和其他任何类型在运算上都是互斥的（即不兼容）**，所以Java完美地解决了一个问题：
  - **&和|两侧的值如果都是布尔类型的，那么就是简洁与/或.**
  - **&和|两侧的值都是整型的，那么就是按位与和按位或.**
    - 这避免了两种类型的操作符相混淆，比较符号相同，但意义不同.

<br><br>

### 六、三目运算符：[·](#目录)
> ? : 算符的一些注意点.

1. 结合性是**从右往左**的.
2. 一定要注意**自动类型提升的问题**！！！
  - 普通情况：xxx? 10.9: 5;  // 10.9和9之间发生自动类型提升，如果得到的是9，也会转换成double的9.0！！
    - 即使用System.out.println输出也是9.0！！
  - char类型和其它类型混合：
    1. char类型的变量或常量（**常量的话只能用Unicode表示**）和**其他任何类型**的**变量**混合，都将被提升为数值而非字符：可以通过print输出检查
      - 示例：char ch = 'a'; byte b = 10;
        1. true? ch: b;  // 97
        2. true? 'a': b; // 97
        3. true? 'a': 10.5; // 97.0
      - 小结：只要是和变量混合，那就变成普通整型来看待.
    2. char类型的变量或常量和int常量混合则结果是char型：
      - 示例：接上例
        1. true? ch: 5; // a
        2. true? 'a': 10;  // b
      - **当且仅当和int常量混合时才有这回事儿：**
        1. true? ch: 5L; // 97
        2. true? 'a': .52; // 97.0
  - 总结地将，就是：三目运算符中，char变量或常量和兼容窄化的int常量混合时最终类型变成char.

<br><br>

### 七、位操作：[·](#目录)

1. 只能应用于整型，不能应用于浮点型，否则会编译报错！！
2. !是逻辑运算符，不是位操作符！！不要停留在C/C++的思维了！！

<br>

- 关于<<、>>、>>>：
  1. **如果左操作数小于int（byte、short、char），那么会先把左操作数自动提升为int，而最终表达式的类型也是int.**
    - 例如：byte b = 5; short s = b >> 1;  // 错误！b >> 1是int，和short不兼容
  2. 如果表达式的值确定为int，那么**右操作数会先模除32**再进行位移.
    - 即：5 >> 32 == 5 >> 0;  5 >> 33 == 5 >> 1;
  3. 如果表达式的值确定为long（左操作数位long即可），那么**右操作数会先模除64**再进行位移.
    - 即：5L >> 64 == 5L >> 0; 5L >> 65 == 5L >> 1;
- <<就是单纯的左移，右末位补0.
- >>是**有符号**右移，符号位补**原有的符号位**.
- >>>是**无符号**右移，符号位补0.

<br><br>

### 八、运算符优先级总览：[·](#目录)

1. 最强的毋庸置疑是()
2. 接下来是单目：++、~、!
3. 再接下来是强制类型转换(type).
  - 所以要注意：(int)~a和~(int)a的区别.
4. 算数运算符（\*、/、%优先级一样）> 位移运算符 > 比较运算符 > 位操作 > 逻辑运算符 > 三目 > 赋值
