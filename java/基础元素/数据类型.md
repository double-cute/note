# 数据类型和运算符

<br><br>

## 目录

1. []()

<br><br>

### 一、编译时类型&运行时类型的概念：

- 编译时类型：**也针对常量**
  1. 就是你在源代码中**手敲上去的**变量**声明类型**！！
  2. 具体说，变量的编译时类型**在声明变量时确定**.
  3. 任何一个Java变量（不管是基本类型还是引用类型）都具有**唯一确定**的编译时类型（在声明变量的一瞬间就确定了）.

```Java
Person p = new Person();  // p的声明类型是Person，因此p的编译时类型永远都为Person
Student s = new Student();  // Person是Student的父类
p = s;  // 发生辈分提升，但p的编译时类型永远都为Person，Student是p的运行时类型
int a = 5;  // 很显然a的编译时类型为5，但不过int这种基本类型的变量是不存在运行时类型的
```

- 如何确定**一个表达式的编译时类型**：例如a + i + 15L
  - 编译器的计算方法是：
    1. 先列出所有项各自的编译时类型.
    2. 再找出最宽的类型.
    3. 对其余类型自动做类型提升作为整个表达式的最终编译时类型.
  - 上例如果是a、i、15L分别是short、double、long的话，由于double > long > short，因此会自动将short和long提升为double型，因此最终表达式的编译时类型是double.

<br>

- 运行时类型：
  1. 只有引用类型变量才会有.
    - 而且，**所有** 引用类型变量都必定会有自己的运行时类型.
  2. 具体是指，引用变量**所指向**的内存对象的**源**编译时类型.
    - 由于在程序运行中，一个引用变量的指向可能会不停变化，所以运行时类型可能会随着程序运行不停变化.
    - 因此是一个**动态**的概念.
  3. 查看一个引用变量的运行时类型使用**getClass()** 方法即可.


```Java
Person p = new Person();  // p的编译时类型为Person，此时的运行时类型是Person
Father f = new Father();
Son s = new Son();  // 继承关系是Person -> Father -> Son
p = f;  // 此时p的运行时类型是Fahter

f = s;  // 先让f套一层son对象
p = f;  // 经过2层的指向，p的运行时类型其实是Son（即指向的内存对象的源编译时类型）
        // 千万不要看f的编译时类型，一定要看f指向的对象的编译时类型.
        // p.getClass()的结果是Son.
```

<br><br>

### 一、强类型语言的定义：
> Java是个典型的强类型语言.
>
>> 强类型语言简单的说就是**在编译时就能确定所有变量类型的语言**.

- 因此，强类型语言的严格定义：
  1. 所有变量必须**先声明后使用**.
    - 声明就是指声明变量的**编译时类型**.
  2. 变量只能接受**编译时类型与之匹配**的值.
    - 这里的匹配是指：是或的关系
      1. 类型完全相同.
      2. 可以自动窄化转换（基本数值类型的隐式自动类型提升）.
      3. 类继承中辈分提升（子类引用赋给父类引用）.

<br><br>

### 二、Java数据类型总览：

- Java数据类型：
  - 引用类型：面向对象的体现
    - 包括**类、接口、数组**这仅有的**3种**.
  - 基本类型：**Java的非面向对象特征就是基本数据类型导致的**
    1. 布尔类型：boolean
    2. 数值类型：
      1. 整型：byte、int、short、long
      2. 浮点型：float、double
      3. 字符型：**特殊的整型**，**2字节** 的无符号整型，char

<br>

- Java数据类型的作用：其实在Java中，只要是个量（**不管是常量还是变量**）就必须有编译时类型的
  1. **显式声明** 变量的**编译时类型**.
    - 显式是指手动敲上去的声明类型，比如：int a = 5;  // 这个int就是显式声明的编译时类型
  2. **隐式声明** 常量的**编译时类型**.
    - 由于常量都是**直接写出值来的**，并不能直接显式写出其编译时类型.
    - 比如：15L其实就是隐式声明了一个编译时类型为long的常量（long这个类型并不能显式写出来），仿佛是显式声明"long 15".

<br><br>

### 三、整型常量的表示：
> 补充：补码的表示
>
>> 1. 正数的补码等于其原码.
>> 2. 反码等于原码的最高位不变，其余位求反.
>> 3. 负数的补码等于其反码+1.

- 就用一个**整数**来表示，但这个**整数**的形式可以是多样的：
  1. 十进制：最常见，如15
  2. 八进制：0开头，如0563
  3. 十六进制：0x开头，如0xFFC8
  4. 二进制：0b开头，如0b10010101

<br>

- 如何确定整型常量的编译时类型：
  1. int：默认为一个**整数**，比如直接一个56、0xF7等的编译时类型就是int.
  2. long：**整数** 再加上一个L后缀，比如56L、0b1011L等的编译时类型就是long.
  3. byte、short、char**木有**自己的常量表示法，Java规定，**必须且只能** 用int的表示法赋值：
    - 例如：byte b = 12; short s = 0x5F; char c = 50;
    - 其实12、0x5F、50的类型是int，类型虽然冲突，但是是允许的.
      - 但Java编译器**不允许溢出，如果数值过大溢出会直接编译错误**.
      - 必须允许，毕竟short、byte没有自己的常量表示法.
      - **不能用long的表示法对byte、short、int进行赋值，这算类型冲突.**
  4. 对于八进制、十六进制、二进制表示的，如果位数不足自己的编译时类型那不足的高位都一律默认用0补齐：
    - 例如：byte b = 0b11101;  // 默认为byte b = 0b00000000000000000000000000011101，0b11101是int型，所以是32位

<br>

- 整型常量的溢出以及异常使用：全部都会在编译时检查出来并报错
  - 无非就是两种情况：
    1. 常量自己超出了本身的编译时类型范围.
    2. 超出了赋值变量的编译时类型范围.

```Java
586843960834963049;    // 错误！常量不能单独出现

// 变量的编译时类型溢出
byte b = 123456;   // 错误！123456超出了byte的范围

// 常量的编译时类型溢出
char c = 23923522342352352;  // 错误！23923522342352352是int型的，但是超出了int的范围，不要误认为是超出了char的范围，因为常量类型溢出的错误在先！！！
int a = 586843960834963049;  // 错误！586843960834963049是int型的，但超出了int的范围
long a = 586843960834963049;  // 同上
long a = 586843960834963049L;  // 正确
long a = 23489234583495834958293852938528525L;  // 错误！23489234583495834958293852938528525L是long型的，但是超出了long的范围
```

<br>

- Unicode运算符：一种特殊的**整型常量获取方式**
  - Java采用的是Unicode编码，一个字符2个字节.
  - 'a'中的''就是Unicode运算符，会将a这个字符转换成其Unicode码（一个整数）.
  - 其得到的整数值是**int类型**的！！！
    - 但是大小一定是0~65536，所以**可以放心的给char、int、long赋值，但给byte赋值时要注意可能会溢出**.
    - 例如：char c = 'a'; byte b = '0'; short s = 'a';

<br><br>

### 四、

| 数据类型 | 长度（字节）| 范围 | 常量表示方法（隐式声明编译时类型） |
| --- | --- | --- | --- |
| 引用类型 | 4 | - | null（空指针，任何引用类型都具有的常量）|
| boolean | 1 | true、false | true、flase |
| byte | 1 | -128 ~ 127 | 整数 |
| short | 2 | -3w2 ~ 3w2 | 整数 |
| char | 2 | 0 ~ 65535的无符号整型 | 整数 |
| int | 4 | -21开头10位数 ~ 21开头10位数 | 整数 |
| long | 8 | -很大 ~ 很大 | 整数L |
