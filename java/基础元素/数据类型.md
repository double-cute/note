# 数据类型

<br><br>

## 目录

1. [编译时类型和运行时类型的概念](#一编译时类型和运行时类型的概念)
2. [强类型语言的定义](#二强类型语言的定义)
3. [Java数据类型总览](#三java数据类型总览)
4. [整型常量的表示](#四整型常量的表示)
5. [浮点型常量的表示](#五浮点型常量的表示)
6. [常量表示法总结](#六常量表示法总结)
7. [常量的下划线分隔](#七常量的下划线分隔)
8. [布尔型](#八布尔型)
9. [Java各个数据类型的长度以及大小范围总结](#九java各个数据类型的长度以及大小范围总结)
10. [自动类型转换](#十自动类型转换)
11. [常量池](#十一常量池)

<br><br>

### 一、编译时类型和运行时类型的概念：[·](目录)

- 编译时类型：**也针对常量**
  1. 就是你在源代码中**手敲上去的**变量**声明类型**！！
  2. 具体说，变量的编译时类型**在声明变量时确定**.
  3. 任何一个Java变量（不管是基本类型还是引用类型）都具有**唯一确定**的编译时类型（在声明变量的一瞬间就确定了）.

```Java
Person p = new Person();  // p的声明类型是Person，因此p的编译时类型永远都为Person
Student s = new Student();  // Person是Student的父类
p = s;  // 发生辈分提升，但p的编译时类型永远都为Person，Student是p的运行时类型
int a = 5;  // 很显然a的编译时类型为5，但不过int这种基本类型的变量是不存在运行时类型的
```

- 如何确定**一个表达式的编译时类型**：例如a + i + 15L
  - 编译器的计算方法是：
    1. 先列出所有项各自的编译时类型.
    2. 再找出最宽的类型.
    3. 对其余类型自动做类型提升作为整个表达式的最终编译时类型.
  - 上例如果是a、i、15L分别是short、double、long的话，由于double > long > short，因此会自动将short和long提升为double型，因此最终表达式的编译时类型是double.

<br>

- 运行时类型：
  1. 只有引用类型变量才会有.
    - 而且，**所有** 引用类型变量都必定会有自己的运行时类型.
  2. 具体是指，引用变量**所指向**的内存对象的**源**编译时类型.
    - 由于在程序运行中，一个引用变量的指向可能会不停变化，所以运行时类型可能会随着程序运行不停变化.
    - 因此是一个**动态**的概念.
  3. 查看一个引用变量的运行时类型使用**getClass()** 方法即可.


```Java
Person p = new Person();  // p的编译时类型为Person，此时的运行时类型是Person
Father f = new Father();
Son s = new Son();  // 继承关系是Person -> Father -> Son
p = f;  // 此时p的运行时类型是Fahter

f = s;  // 先让f套一层son对象
p = f;  // 经过2层的指向，p的运行时类型其实是Son（即指向的内存对象的源编译时类型）
        // 千万不要看f的编译时类型，一定要看f指向的对象的编译时类型.
        // p.getClass()的结果是Son.
```

<br><br>

### 二、强类型语言的定义：[·](目录)
> Java是个典型的强类型语言.
>
>> 强类型语言简单的说就是**在编译时就能确定所有变量类型的语言**.

- 因此，强类型语言的严格定义：
  1. 所有变量必须**先声明后使用**.
    - 声明就是指声明变量的**编译时类型**.
  2. 变量只能接受**编译时类型与之匹配**的值.
    - 这里的匹配是指：是或的关系
      1. 类型完全相同.
      2. 可以自动窄化转换（基本数值类型的隐式自动类型提升）.
      3. 类继承中辈分提升（子类引用赋给父类引用）.

<br><br>

### 三、Java数据类型总览：[·](目录)

- Java数据类型：
  - 引用类型：面向对象的体现
    - 包括**类、接口、数组**这仅有的**3种**.
  - 基本类型：**Java的非面向对象特征就是基本数据类型导致的**
    1. 布尔类型：boolean
    2. 数值类型：
      1. 整型：byte、int、short、long
      2. 浮点型：float、double
      3. 字符型：**特殊的整型**，**2字节** 的无符号整型，char

<br>

- Java数据类型的作用：其实在Java中，只要是个量（**不管是常量还是变量**）就必须有编译时类型的
  1. **显式声明** 变量的**编译时类型**.
    - 显式是指手动敲上去的声明类型，比如：int a = 5;  // 这个int就是显式声明的编译时类型
  2. **隐式声明** 常量的**编译时类型**.
    - 由于常量都是**直接写出值来的**，并不能直接显式写出其编译时类型.
    - 比如：15L其实就是隐式声明了一个编译时类型为long的常量（long这个类型并不能显式写出来），仿佛是显式声明"long 15".

<br><br>

### 四、整型常量的表示：[·](目录)
> 补充：补码的表示
>
>> 1. 正数的补码等于其原码.
>> 2. 反码等于原码的最高位不变，其余位求反.
>> 3. 负数的补码等于其反码+1.

- 就用一个**整数**来表示，但这个**整数**的形式可以是多样的：用符号{INT}代表
  1. 十进制：最常见，如15
  2. 八进制：0开头，如0563
  3. 十六进制：0x开头，如0xFFC8
  4. 二进制：0b开头，如0b10010101

<br>

- **如何确定整型常量的编译时类型：**
  1. int：默认为一个{INT}，比如直接一个56、0xF7等的编译时类型就是int.
  2. long：{INT}再加上一个L后缀，比如56L、0b1011L等的编译时类型就是long.
  3. byte、short、char**木有**自己的常量表示法，Java规定，**必须且只能** 用int的表示法赋值：
    - 例如：byte b = 12; short s = 0x5F; char c = 50;
    - 其实12、0x5F、50的类型是int，类型虽然冲突，但是是允许的.
      - 但Java编译器**不允许溢出，如果数值过大溢出会直接编译错误**.
      - 必须允许，毕竟short、byte没有自己的常量表示法.
      - **不能用long的表示法对byte、short、char、int进行赋值，这算窄化类型冲突.**
        - 但用int常数来表示byte、short、char也是一种窄化，因此叫做**窄化兼容**.
  4. 对于八进制、十六进制、二进制表示的，如果位数不足自己的编译时类型那不足的高位都一律默认用0补齐：
    - 例如：byte b = 0b11101;  // 默认为byte b = 0b00000000000000000000000000011101，0b11101是int型，所以是32位

<br>

- **溢出以及异常使用：全部都会在编译时检查出来并报错**
  - 无非就是两种情况：

    1. 常量超出了**自己本身的编译时类型**范围.
      - char c = 23923522342352352;  // 错误！23923522342352352是int型的，但是超出了int的范围，不要误认为是超出了char的范围，因为常量类型溢出的错误在先！！！
      - int a = 586843960834963049;  // 错误！586843960834963049是int型的，但超出了int的范围
      - long a = 586843960834963049;  // 同上（int范围的益处，而不是long）
      - long a = 586843960834963049L;  // 正确
      - long a = 23489234583495834958293852938528525L;  // 错误！23489234583495834958293852938528525L是long型的，但是超出了long的范围

    2. 超出了**兼容类型**的编译时类型范围.
      - byte b = 123456;   // 错误！虽然兼容窄化，但123456的大小超出了byte的范围

    3. 窄化类型冲突（排除了兼容窄化的情况下）
      - int -> byte、short、char（是**兼容窄化，没有冲突**，但需要注意兼容类型溢出问题，即2.的问题）
      - long -> byte、short、int（窄化类型冲突）
        - 例如：byte b = 1L;  short s = 2L;  int i = 3L;  // 都是窄化类型冲突错误

    4. 常量不能单独出现：
      - 586843960834963049;  // 错误！常量不能单独出现

<br>

- Unicode运算符：一种特殊的**整型常量获取方式**
  - Java采用的是Unicode编码，一个字符2个字节.
  - 'a'中的''就是Unicode运算符，会将a这个字符转换成其Unicode码（一个整数）.
  - 其得到的整数值常量的编译时类型是**int类型**的！！！
    - 但是大小一定是0~65536，所以**可以放心的给char、int、long赋值（窄化兼容），但给byte赋值时要注意可能会溢出**.
    - 例如：char c = 'a'; byte b = '0'; short s = 'a';

<br><br>

### 五、浮点型常量的表示：[·](目录)
> 有且仅有两种表示法：十进制点表示法和科学计数法.

1. 十进制点表示法：这里用符号{POINT_DEC}代表
  - 特点是**必须**有小数点：
    1. 完整形式：5.12
    2. 省略点后：5.  ==  5.0
    3. 省略点前：.5  ==  0.5
2. 科学计数法：**只能用来表示浮点型，不能表示整型**
  - 形式是：{POINT_DEC}e{DEC}
    - {DEC}表示纯的十进制数，**不能用二进制和十六进制表示法**.
      - **八进制表示法会默认省略前缀0，仍然看成十进制数表示，例如：5.12e053中的指数053并不是八进制数53，而是十进制数53！！**
  - 示例：.34e12、5.e10、8.2e-3、-.11e-6

<br>

- **如何确定浮点型常量的编译时类型：**
  - double：默认情况下（没有任何后缀）.
  - float：加上后缀f.

<br>

- **溢出以及异常使用：全部都会在编译时检查出来并报错**

  1. 常量超出了**自己本身的编译时类型**范围.
    - double d = 52343453498573985.5f;  // 错误！52343453498573985.5f本身的编译时类型是float，但其大小超出了float的上限
    - float f = 23.e255;  // 错误！23.e255的编译时类型是double，但其大小已经超出了double的上限，并不是double -> float的错误，因为这个错误在先

  2. 窄化类型冲突：double -> float属于窄化类型冲突
    - float f = 5.0;  // 错误！

  3. 正负无穷大：
    - 非0的正负数除以0（**必须保证结果是浮点数的前提下**）将得到±Infinity
      - 比如：5/0.0、-1.0/0、3.1/0.0  // 必须保证结果的编译时类型为浮点型而不是整型
      - **但不能是0/0，因为5/0的结果是整型的，整型除0会直接跑出除零异常.**
    - Infinity和Inifity相等，-Infinity和-Infinity相等.

  4. 非数：
    - 0/0.0、0.0/0、0.0/0.0（必须保证结果的编译时类型是浮点型），将得到Nan.
    - NaN不与任何数**包括自己**相等.

<br><br>

### 六、常量表示法总结：[·](目录)

- 整型常数{INT}表示：二进制、八进制、十六进制省略的高位默认用0补齐！

| 进制 | 举例 |
| --- | --- |
| 普通的十进制 | 无任何前缀，34、53 |
| 二进制 | 0b10110101 |
| 八进制 | 注意前缀0，07354（前缀0后的数不能大于7）|
| 十六进制 | 0xffc9 |
| **Unicode** | 'a' |

- 整型常数体现编译时类型：

| 被赋值变量的类型 | 表示法 | 常量编译时类型 | 形式 |
| --- | --- | --- | --- |
| byte | {INT} | int | 兼容窄化（必须通过赋值体现）|
| short | {INT} | int | 兼容窄化（必须通过赋值体现）|
| char | {INT} | int | 兼容窄化（必须通过赋值体现）|
| int | {INT} | int | 标准 |
| long | {INT}L | long | 标准 |

- 浮点型常数{FLOAT}表示：

| 表示方法 | 符号 | 举例 | 说明 |
| --- | --- | --- | --- |
| 十进制点 | {POINT_DEC} = {DEC}. 、 .{DEC} 、 {DEC}.{DEC} | 3. 、 -.5 、 5.3 | 必须有点 |
| 科学计数法 | {POINT_DEC}e{DEC} | -.54e-17 | 指数部分必须是纯十进制整数，前置0不会被当做八进制 |
| 正负无穷 | ±Inifity | Float/Double.POSITIVE_INFINITY/NEGATIVE_INFINITY，也可以用非0除以0.0得到 | 和自己相等 |
| 非数 | Nan | 0.0 / 0.0 | 和任何数包括自己都不相等 |

- 浮点型常数体现编译时类型：

| 表示法 | 常量编译时类型 |
| --- | --- |
| {FLOAT}f | float |
| {FLOAT} | double |

<br><br>

### 七、常量的下划线分隔：[·](目录)
> 可以在常量的任意位置加下划线分隔，以免较长的常量阅读起来困难.

- 示例：

```Java
int a = 0b1000_1010_11;
float b = 3.11_3e2_3;
```

<br><br>

### 八、布尔型：[·](目录)

- Java严格控制boolean类型的使用，以避免犯C语言那样因为各种不严谨所导致的软件危机，主要体现在如下方面：
  1. boolean**不能和其它任何基本类型之间进行转换**（强转也不行）！！
  2. if、else if、while、do while、for、（? : 三目运算符）的条件判断部分的值的类型必须且**只能是boolean，不和其它基本数据类型兼容**！！

<br><br>

### 九、Java各个数据类型的长度以及大小范围总结：[·](目录)

- 可以通过基本类型的包装器类型的SIZE域查看：
  - Character.SIZE / 8   // 单位是二进制位的个数，除以8得到字节数
  - Double.SIZE
  - Boolean没有，不同平台不同.

| 类型 | 长度（字节）| 范围 |
| --- | --- | --- |
| byte | 1 | -128 ~ 127 |
| short | 2 | -3w2 ~ 3w2 |
| char | 2 | 0 ~ 65535 |
| int | 4 | -21开头的十位数 ~ 一样 （21亿当量）|
| long | 8 | -92开头的19位数 ~ 一样 （92G当量）|
| float | 4 | 很大 |
| double | 8 | 超大 |
| boolean | 未知（一般是1字节）| 根据普通平台的极其自然长度来定 |

<br><br>

### 十、自动类型转换：[·](目录)
> 这里的自动类型转换只针对基本数值类型.

- 从小到大的顺序为：

byte -> short -> int(<- char) -> long -> float -> double

- 注意：
  1. **体系中没有boolean.**
  2. char和short是平行的，byte可以自动赋值给short，但不能赋给char（类型冲突）.

<br>

- 基本数据类型和字符串进行连接（+）：
  1. 任何基本数据类型（包括boolean）和字符串（String）类型进行+连接后都会被提升成String类型.
  2. 单纯的将基本数据类型转化成字符串表示可以和空字符串""进行连接.
    - 例如：5 + ""; 或者 "" + 5;
  3. 再进行多值连续连接时需要注意**基本类型数据连续连接**的问题.
    - 其实是由+运算符的从左至右结合顺序导致的
    1. "abc" + 5 + 3  ==  abc53  
    2. 5 + 3 + "abc"  ==  8abc
    3. "abc" + 5 + 3 + "ok"  ==  abc53ok
    4. **'a' + 7 + "abc"  ==  104abc   // 'a' + 7先做整数相加**

<br>

- 表达式中的自动类型提升：
  1. 整个表达式最终的编译时类型一定是范围最大的那个类型.
  2. 一定要先看表达式各个项的计算先后顺序，否则容易出错！
    - 例如：**8.3 * (5 / 6)  ==  0   // 先做5/6，但这是int相除，结果是0**
  3. 注意整型中的兼容窄化和表达式混合运算的错误问题：
    - 典型的例如：
      - short a = 5; short b = a - 2;  // a(short)、2(int)，因此a - 2的编译时类型为int，int赋给short发生错误！
      - 因此只能强制类型转换：short b = a - (short)2;或者short b = (short)(a - 2);

<br><br>

### 十一、常量池：[·](目录)
> .java中所有出现的常量在编译后都会保存在**常量池**中，常量池**位于.class文件中**，**以硬编码的形式存储在代码段的起始部分**.

- 常量池保存常量的规则就一句话：所有的常量都会**只保存一个唯一的副本**于常量池中
  1. 常量包括：null、1.5f、0xff32L、"abc"、'a'、'a' + 7.0等常量或者**常量表达式**.
  2. 唯一性：String a = "abc"; String b = "abc"; a == b; // true，"abc"唯一（不会保存多个副本）
  3. **常量表达式也是一种常量：String a = "abc"; String b = "a" + "bc"; a == b; // true，常量表达式的值是能唯一确定的，因此结果肯定也只保存唯一的一份.**
