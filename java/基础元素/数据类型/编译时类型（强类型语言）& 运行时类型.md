# 编译时类型（强类型语言）& 运行时类型
> - 编译时类型是**编译器肉眼直接看出**的变量的类型，编译时就确定，永远不会改变，是**静态**的.
>   - 强类型编程语言就是根据**编译时类型的检查严格程度**来定义的.
> - 运行时类型编译器则无法判断出，随着程序运行可以**动态**变化.

<br><br>

## 目录

1. [编译时类型]()
2. [运行时类型]()
3. [强类型语言的定义]()

<br><br>

### 一、编译时类型：[·](#目录)

- 编译时类型：**也针对常量**
  1. 就是你在源代码中**手敲上去的**变量**声明类型**！！
  2. 具体说，变量的编译时类型**在声明变量时确定**.
  3. 任何一个Java变量（不管是基本类型还是引用类型）都具有**唯一确定**的编译时类型（在声明变量的一瞬间就确定了）.

```Java
Person p = new Person();  // p的声明类型是Person，因此p的编译时类型永远都为Person
Student s = new Student();  // Person是Student的父类
p = s;  // 发生辈分提升，但p的编译时类型永远都为Person，Student是p的运行时类型
int a = 5;  // 很显然a的编译时类型为5，但不过int这种基本类型的变量是不存在运行时类型的
```

- 如何确定**一个表达式的编译时类型**：例如a + i + 15L
  - 编译器的计算方法是：
    1. 先列出所有项各自的编译时类型.
    2. 再找出最宽的类型.
    3. 对其余类型自动做类型提升作为整个表达式的最终编译时类型.
  - 上例如果是a、i、15L分别是short、double、long的话，由于double > long > short，因此会自动将short和long提升为double型，因此最终表达式的编译时类型是double.

<br>

- **编译时类型概念中最重要的一点：** 决定引用可以调用的方法
  - 一个引用的编译时类型决定了它能调用什么方法.
   - 一个引用**只能调用它的编译时类型的方法，不能调用它运行时类型的方法**.
  - 例如：Son extends Father，那么Father f = new Son()了以后，**f只能调用Father类的方法，不能调用Son类的方法**
- 编译时类型总结成一个词就是：**所见即所得**
  1. 编译器编译器，什么叫做编译器，就是**只管编译不管运行**！
  2. 编译时看到一个类型有什么方法，那么这个编译时类型的引用就只能调用这些方法，即使它的运行是类型不是这个.

<br><br>

### 二、运行时类型：[·](#目录)

1. 只有引用类型变量才会有.
  - 而且，**所有** 引用类型变量都必定会有自己的运行时类型.
2. 具体是指，引用变量**所指向**的内存对象的**源**编译时类型.
  - 由于在程序运行中，一个引用变量的指向可能会不停变化，所以运行时类型可能会随着程序运行不停变化.
  - 因此是一个**动态**的概念.
3. 查看一个引用变量的运行时类型使用**getClass()** 方法即可.


```Java
Person p = new Person();  // p的编译时类型为Person，此时的运行时类型是Person
Father f = new Father();
Son s = new Son();  // 继承关系是Person -> Father -> Son
p = f;  // 此时p的运行时类型是Fahter

f = s;  // 先让f套一层son对象
p = f;  // 经过2层的指向，p的运行时类型其实是Son（即指向的内存对象的源编译时类型）
        // 千万不要看f的编译时类型，一定要看f指向的对象的编译时类型.
        // p.getClass()的结果是Son.
```

<br><br>

### 三、强类型语言的定义：[·](#目录)
> Java是个典型的强类型语言.
>
>> 强类型语言简单的说就是**在编译时就能确定所有变量类型的语言**.

<br>

- 因此，强类型语言的严格定义：
  1. 所有变量必须**先声明后使用**.
    - 声明就是指声明变量的**编译时类型**.
  2. 变量只能接受**编译时类型与之匹配**的值.
    - 这里的匹配是指：是或的关系
      1. 类型完全相同.
      2. 可以自动窄化转换（基本数值类型的隐式自动类型提升）.
      3. 类继承中辈分提升（子类引用赋给父类引用）.
