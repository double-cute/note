# 基本类型的包装器类型
> Java的不完全面向对象就是由于基本类型造成，为了弥补这个不足之处，Java为所有基本类型都做了面相对象包装，设计了各自的包装器类型.
>
>> Java之所以还提供8种基本类型主要是为了照顾C开发者的习惯以推广这门语言.
>>
>>> 8种基本类型对应的包装器类型分别是：**Boolean、Byte、Short、Character、Integer、Long、Float、Double**.

<br><br>

## 目录

1. []()
2. []()
3. []()

<br><br>

### 一、自动装箱：
> JDK 1.5之前，**基本类型数据** 和 **包装器类型数据** 之间相互转换、赋值非常麻烦，需要各种麻烦的步骤.
>
>> 但现在Java提供了自动装箱/拆箱功能，大大简化了这个过程.

<br>

- 自动装箱的概念：
  - 可以直接将基本类型数据的变量或常量赋值给对应的包装器类型数据.
    - 底层会自动隐式地包装成包装器类型数据，例如，Integer a = 5;

<br>

- **自动装箱时的编译时类型检查非常严格！**
  1. 常量 赋值给 包装器类型变量：
    1. 窄化兼容仍然有效.
    2. 越过窄化兼容层次后（**大于char之后**）必须严格遵循**=两边编译时类型完全一样**的准则.
      - **完全没有向上兼容的概念.**
      - 例如：
        1. Long l = 5L; // 正确
        2. Long l = 5; // 错误，右边包装后编译时类型为Integer，和左边不符.
  2. 基本类型变量 赋值给 包装器类型变量：
    - 完全严格遵循**=两边编译时类型完全一样**的准则，
      - **完全没有向上兼容的概念.**
  3. 其本质是：**引用类型** 赋值给 **引用类型**，因此类型检查严格
    - 会先将**=右边**提升为**其编译时类型对应的包装器类型**再赋值给右边.

- 测试代码：

```Java
byte bb = 1;
short ss = 1;
char cc = 1;
int ii = 1;
long ll = 1L;
float ff = 1.1f;
double dd = 1.1;

Byte b = 5;  // 常量赋值支持窄化兼容
	b = bb;
Short s = 11;  // 常量赋值支持窄化兼容
	s = ss;
	s = b;  // 错误！变量赋值不支持向上兼容！
	s = bb; // 错误！
Character c = 6;
	c = cc;
	c = bb;  // 错误！

// 从兼容转化开始，所有的一切都必须严格遵从编译时类型完全相同的原则
// 不支持向上兼容
  // 精确地讲是，面向对象的数值类型没有向上兼容这一说

	c = b;  // 错误！
	c = s;  // 错误！
Integer i = 20;
	i = b;  // 错误！
Long l = 30L;
	l = 20; // 错误！
	l = i;  // 错误！
	l = b;  // 错误！

Float f = 5.5f;
	f = 5;  // 错误！
	f = 5.5;  // 错误！
	f = b;  // 错误！
Double d = 5.5;
	d = 5;  // 错误！
	d = 5.5f;  // 错误！
	d = f;  // 错误！
```

<br>

- **自动装箱的原理（步骤）：**
  1. **先检查**=右边到左边是否满足**窄化兼容**.  （窄化兼容的条件是，左边为Byte、Short、Character，右边是int常量）
    - 如果满足，先将左边的常量（窄化转换右边一定是常量）自动隐式转换为左边的包装器类型.
    - **即满足就顺利完成赋值.**
  2. 如果不满足，则先检查右边常量或变量的编译时类型，然后将其转化为编译时类型对应的包装器类型.
    - 即**右边自动提升为自己本身对应的包装器类型**.
  3. 接着赋值，如果类型不一致则发生类型冲突报错（编译时错误）.
    - 例如：Byte b = 5;
      1. 5 -> byte符合窄化兼容条件.
      2. 5 -> Byte(5) -> b
    - 例如：Byte b = i;
      1. i -> b不符合窄化兼容条件.
      2. i(int) -> Integer(i).
      3. Integer <-> Byte类型不相同，编译报错！
    - 例如：Double d = 5.5f;
      1. 5.5f -> double不符合窄化兼容条件.
      2. 5.5f(float) -> Float(5.5f)
      3. Float <-> Double类型不相同，编译报错！
    - 例如：**Object o = 5;**
      1. 5(int) -> Integer(5)
      2. **Integer -> Object兼容！正确！**

<br><br>

### 二、自动拆箱：
> 就是将包装器类型变量赋值给基本类型变量.

- 由于其底层实质是：**基本类型** 赋值给 **基本类型**
  1. 先将=右边的包装器类型变量自动隐式转化成其对应的基本类型.
  2. 然后再将其赋给左边的基本类型变量.

<br>

- 由于是最终转化成了基本类型对基本类型的赋值，因此**支持向上兼容**.
  - 例如：float f = new Integer(5);  // 正确！右边先转化为int(5)，而int -> float是向上兼容的

<br>

- 但注意：**检查的是编译时类型，而不是运行是类型！！！！**
  - 拆箱是根据=右边内容 **自己本身的编译时类型** 拆箱成对应的基本类型.
  - 并没有强大到根据自己本身的运行时类型拆箱成对应的基本类型，这必须要由开发者自己决定.

```Java
Object o = 5;
int i = o;  // o的编译时类型是Object，由于编译器笨，不知道o的运行是类型，因此无法拆箱成int
```

<br>

- 只要是**发生赋值的地方**都可以发生**自动装箱和拆箱**，特别是在方法传参时：

```Java
void func(int a);   // obj.func(new Integer(5));  自动拆箱
void func(Integer a);  // obj.func(5);  自动装箱
```

<br>

### 三、有了包装器类型就可以应用instanceof了：

```Java
Object o = 5;
if (o instanceof Integer) {
	int a = (Integer)o;  // 根据运行时类型强转是需要开发者自己手动决定的
}
```

- 再次强调，不允许直接int a = o;
  - 因为：**重要的事情再重复一遍！**
    - 拆箱是根据=右边内容 **自己本身的编译时类型** 拆箱成对应的基本类型.
    - 并没有强大到根据自己本身的运行时类型拆箱成对应的基本类型，这必须要由开发者自己决定.
      - 即使其运行时类型到=左边的赋值是满足条件的，也不行.
  - 报错的理由是：
    1. o的编译时类型是Object，而a的编译时类型是int，Object无法自动拆箱成Integer，因为无法判断o的运行时类型是否为Integer.
    2. 因此最终的结论是编译时类型冲突，Object -> int转化失败.

<br><br>

6. 数值型的大小比较：用符号比较、用包装器类型的静态工具方法比较
    1) 用符号比较：即>、<、>=、<=比较运算符对数值型（基本类型、包装器类型）比较；
         i. 符号两边可以是任意数值型的基本类型或包装器类型，两种类型可以混用；
         ii. 例如：5.5 > new Integer(5)等；
         iii. 比较运算符的规则：如果两边有包装器类型，那就先自动拆箱成基本类型，然后再进行比较；
         iv. 我们都知道，比较运算符是可以混合比较各种类型的数值的（比如double和int比，byte和char比等等）；
     2) 由于符号比较比较混乱，允许混合类型比较，但有时需要在类型严格匹配的情况下进行比较使代码更加严谨，而各个包装器类型都提供了一个compare静态工具方法，可以保证在类型一致的情况下进行比较：
          i. 原型：public static int Type.compare(type x, type y);
          ii. x<y返回-1，x == y返回0，否则返回1；
          iii. Type是包装器类型，type是Type对应的基本类型；
          iv. 由于自动拆箱，因此也可以传包装器类型；

7. 相等比较：
    1) 直接用包装器对象的equals方法比较完全没有任何问题，通常更推荐用这种方法比较，不会出现任何错误；
    2) 使用==比较：
         i. 如果==一边是基本类型一边是包装器类型，那么包装器类型会自动拆箱成其对应的基本类型进行比较；
！！在这种情况下就变成了纯的基本类型之间的比较，而基本类型的==比较是允许混合类型的，因此允许这样写：6.0 == new Integer(6);
！！实质比较的是基本类型数值；
         ii. 如果==两边都是包装器类型，那就是纯引用类型之间的==比较了，那==比较的是两者的地址（是否指向同一个对象）；
             a. 和instanceof一样，两边的编译类型至少要具有父子关系才行，不能离谱到任意类型，比如new String() == new Date()，这两者用脚趾头想都是不可能相等的，因此直接编译报错！
             b. 由于是比较两者的地址，因此像这样的比较返回的是false：new Integer(5) == new Integer(5)，因为是两个不同的对象，地址不同；
             c. 但是由于自动装箱的存在可能会出现一些令人费解的意外：
Integer a = 5;
Integer b = 5;
out.println(a == b); // true

Integer x = 128;
Integer y = 128;
out.println(x == y); // false
！！这其实是由自动装箱的算法决定的：由于-128-127（char范围）的整数太常用了（根据经验），因此Integer在静态初始化代码中创建了一块缓存，将-128-127包装成Integer存在这个缓存中，如果是通过自动装箱并且范围是-128-127得到的Integer就直接指向该缓存中的对象，因此上面两个符合这个标准，所以指向的是缓存区的同一个对象，而后两个由于128超出了这个范围，所以相当于使用new重新创建了两个对象，因此地址不同，比较结果为false；
！！这个道理告诉我们，包装器对象之间的相等比较一定要用equals对象方法！！！


3. 包装器的构造器、字符串和数值之间的相互转换：
    1) 包装器的构造器有两个版本：
         i. Type(type val);   // 以基本类型作为参数来构造相应的包装器类型
         ii. Type(String val);  // 将一个字符串解析成相应的包装器类型
！例如：Integer a = new Integer(5);  Integer a = new Integer("5");
！！其实，以基本类型作为参数来构造隐含了另一种重载版本，由于自动拆箱的存在，你可以用包装器类型对象来构造另一个包装器对象，因为从Type -> type是自动拆箱的过程，例如：
Integer a = new Integer(new Integer(5));  // 并不是Java重载了一个接受包装器类型的构造器版本，而是自动拆箱的原因，会先将Integer(5)拆箱成5，然后调用Integer(int val)构造器来构造！
    2) 包装器的字符串参数版本其实就是一个将字符串转化成数值类型的方法，而各个包装器类型也提供了一个静态方法用于将字符串解析成基本数据类型：
public static type Type.parseType(String val); // type指代基本类型
！例如：public static int Integer.parseInt(String val);  // 使用，int a = Integer.parseInt("5");
！！注意，使用构造器解析得到的是包装器类型，使用parse静态工具方法解析得到的是基本类型；
！！！要根据需要的返回值的类型（是包装器类型还是基本类型）来决定使用哪种解析方式；
    3) 同理String也提供了一系列静态方法将基本类型数据解析成字符串：valueOf方法
         i. 常用的单数据解析：public static String.valueOf(type val);  //  type指代基本类类型
！例如：public static String.valueOf(int val); // 使用，String s = String.valueOf(5);
         ii. 将char数组连接成字符串：public static String.valueOf(char[] data[, int offset, int count]);
    4) 其实最简单的数值转换成字符串的方法：
         i. 所有的包装器类型都重写了toString方法，因此toString可以直接得到解析后的字符串；
         ii. 基本类型支持自动装箱；
         iii. 以上两点就决定了数值类型转换成字符串类型可以这样转换：和一个字符串相加即可！
！！例如：
Integer a = new Integer(5);  a + "";   // 调用toString后相加
int a = 5;  ->  a + "";   // 以下两个都是先将a自动装箱成包装器类型，然后调用toString后相加
5 + "";

4. 数值型和字符串型相互转化的方式总结：
    1) 数值  ->  字符串：
         i. 基本类型  ->  字符串：String.valueOf
         ii. 包装器类型   ->  字符串：还是String.valueOf，因为可以自动拆箱
         iii. 通用方法：将数值和""相加即可（两种类型都适用）
    2) 字符串  ->  数值：
         i. 字符串   ->  基本类型：Type.parseType
         ii. 字符串  -> 包装器类型：包装器类型的构造器
