# 常量的编译时类型、表示、存储（常量池）
> - Java数据类型总览：
>   - 引用类型：面向对象的体现
>     - 包括**类、接口、数组**这仅有的**3种**.
>   - 基本类型：**Java的非面向对象特征就是基本数据类型导致的**
>     1. 布尔类型：boolean
>     2. 数值类型：
>       1. 整型：byte、int、short、long
>       2. 浮点型：float、double
>       3. 字符型：**特殊的整型**，**2字节** 的无符号整型，char

<br><br>

## 目录

1. [不管是变量还是常量都有确定的编译时类型](#一不管是变量还是常量都有确定的编译时类型)
2. [整型常量的表示](#二整型常量的表示)
3. [浮点型常量的表示](#三浮点型常量的表示)
4. [常量表示法总结](#四常量表示法总结)
5. [常量的下划线分隔](#五常量的下划线分隔)
6. [常量池](#六常量池)

<br><br>

### 一、不管是变量还是常量都有确定的编译时类型：[·](#目录)
> Java数据类型的作用：其实在Java中，只要是个量（**不管是常量还是变量**）就必须有编译时类型的

<br>

1. **显式声明** 变量的**编译时类型**.
  - 显式是指手动敲上去的声明类型，比如：int a = 5;  // 这个int就是显式声明的编译时类型
2. **隐式声明** 常量的**编译时类型**.
  - 由于常量都是**直接写出值来的**，并不能直接显式写出其编译时类型.
  - 比如：15L其实就是隐式声明了一个编译时类型为long的常量（long这个类型并不能显式写出来），仿佛是显式声明"long 15".

<br><br>

### 二、整型常量的表示：[·](#目录)
> 补充：补码的表示
>
>> 1. 正数的补码等于其原码.
>> 2. 反码等于原码的最高位不变，其余位求反.
>> 3. 负数的补码等于其反码+1.

<br>

- 就用一个**整数**来表示，但这个**整数**的形式可以是多样的：用符号{INT}代表
  1. 十进制：最常见，如15
  2. 八进制：0开头，如0563
  3. 十六进制：0x开头，如0xFFC8
  4. 二进制：0b开头，如0b10010101

<br>

- **如何确定整型常量的编译时类型：**
  1. int：默认为一个{INT}，比如直接一个56、0xF7等的编译时类型就是int.
  2. long：{INT}再加上一个L后缀，比如56L、0b1011L等的编译时类型就是long.
  3. byte、short、char**木有**自己的常量表示法，Java规定，**必须且只能** 用int的表示法赋值：
    - 例如：byte b = 12; short s = 0x5F; char c = 50;
    - 其实12、0x5F、50的类型是int，类型虽然冲突，但是是允许的.
      - 但Java编译器**不允许溢出，如果数值过大溢出会直接编译错误**.
      - 必须允许，毕竟short、byte没有自己的常量表示法.
      - **不能用long的表示法对byte、short、char、int进行赋值，这算窄化类型冲突.**
        - 但用int常数来表示byte、short、char也是一种窄化，因此叫做**窄化兼容**.
  4. 对于八进制、十六进制、二进制表示的，如果位数不足自己的编译时类型那不足的高位都一律默认用0补齐：
    - 例如：byte b = 0b11101;  // 默认为byte b = 0b00000000000000000000000000011101，0b11101是int型，所以是32位

<br>

- **溢出以及异常使用：全部都会在编译时检查出来并报错**
  - 无非就是两种情况：

    1. 常量超出了**自己本身的编译时类型**范围.
      - char c = 23923522342352352;  // 错误！23923522342352352是int型的，但是超出了int的范围，不要误认为是超出了char的范围，因为常量类型溢出的错误在先！！！
      - int a = 586843960834963049;  // 错误！586843960834963049是int型的，但超出了int的范围
      - long a = 586843960834963049;  // 同上（int范围的益处，而不是long）
      - long a = 586843960834963049L;  // 正确
      - long a = 23489234583495834958293852938528525L;  // 错误！23489234583495834958293852938528525L是long型的，但是超出了long的范围

    2. 超出了**兼容类型**的编译时类型范围.
      - byte b = 123456;   // 错误！虽然兼容窄化，但123456的大小超出了byte的范围

    3. 窄化类型冲突（排除了兼容窄化的情况下）
      - int -> byte、short、char（是**兼容窄化，没有冲突**，但需要注意兼容类型溢出问题，即2.的问题）
      - long -> byte、short、int（窄化类型冲突）
        - 例如：byte b = 1L;  short s = 2L;  int i = 3L;  // 都是窄化类型冲突错误

    4. 常量不能单独出现：
      - 586843960834963049;  // 错误！常量不能单独出现

<br>

- Unicode运算符：一种特殊的**整型常量获取方式**
  - Java采用的是Unicode编码，一个字符2个字节.
  - 'a'中的''就是Unicode运算符，会将a这个字符转换成其Unicode码（一个整数）.
  - 其得到的整数值常量的编译时类型是**int类型**的！！！
    - 但是大小一定是0~65536，所以**可以放心的给char、int、long赋值（窄化兼容），但给byte赋值时要注意可能会溢出**.
    - 例如：char c = 'a'; byte b = '0'; short s = 'a';

<br><br>

### 三、浮点型常量的表示：[·](#目录)
> 有且仅有两种表示法：十进制点表示法和科学计数法.

<br>

1. 十进制点表示法：这里用符号{POINT_DEC}代表
  - 特点是**必须**有小数点：
    1. 完整形式：5.12
    2. 省略点后：5.  ==  5.0
    3. 省略点前：.5  ==  0.5
2. 科学计数法：**只能用来表示浮点型，不能表示整型**
  - 形式是：{POINT_DEC}e{DEC}
    - {DEC}表示纯的十进制数，**不能用二进制和十六进制表示法**.
      - **八进制表示法会默认省略前缀0，仍然看成十进制数表示，例如：5.12e053中的指数053并不是八进制数53，而是十进制数53！！**
  - 示例：.34e12、5.e10、8.2e-3、-.11e-6

<br>

- **如何确定浮点型常量的编译时类型：**
  - double：默认情况下（没有任何后缀）.
  - float：加上后缀f.

<br>

- **溢出以及异常使用：全部都会在编译时检查出来并报错**

  1. 常量超出了**自己本身的编译时类型**范围.
    - double d = 52343453498573985.5f;  // 错误！52343453498573985.5f本身的编译时类型是float，但其大小超出了float的上限
    - float f = 23.e255;  // 错误！23.e255的编译时类型是double，但其大小已经超出了double的上限，并不是double -> float的错误，因为这个错误在先

  2. 窄化类型冲突：double -> float属于窄化类型冲突
    - float f = 5.0;  // 错误！

  3. 正负无穷大：
    - 非0的正负数除以0（**必须保证结果是浮点数的前提下**）将得到±Infinity
      - 比如：5/0.0、-1.0/0、3.1/0.0  // 必须保证结果的编译时类型为浮点型而不是整型
      - **但不能是0/0，因为5/0的结果是整型的，整型除0会直接跑出除零异常.**
    - Infinity和Inifity相等，-Infinity和-Infinity相等.

  4. 非数：
    - 0/0.0、0.0/0、0.0/0.0（必须保证结果的编译时类型是浮点型），将得到Nan.
    - NaN不与任何数**包括自己**相等.

<br><br>

### 四、常量表示法总结：[·](#目录)

<br>

- 整型常数{INT}表示：二进制、八进制、十六进制省略的高位默认用0补齐！

| 进制 | 举例 |
| --- | --- |
| 普通的十进制 | 无任何前缀，34、53 |
| 二进制 | 0b10110101 |
| 八进制 | 注意前缀0，07354（前缀0后的数不能大于7）|
| 十六进制 | 0xffc9 |
| **Unicode** | 'a' |

- 整型常数体现编译时类型：

| 被赋值变量的类型 | 表示法 | 常量编译时类型 | 形式 |
| --- | --- | --- | --- |
| byte | {INT} | int | 兼容窄化（必须通过赋值体现）|
| short | {INT} | int | 兼容窄化（必须通过赋值体现）|
| char | {INT} | int | 兼容窄化（必须通过赋值体现）|
| int | {INT} | int | 标准 |
| long | {INT}L | long | 标准 |

- 浮点型常数{FLOAT}表示：

| 表示方法 | 符号 | 举例 | 说明 |
| --- | --- | --- | --- |
| 十进制点 | {POINT_DEC} = {DEC}. 、 .{DEC} 、 {DEC}.{DEC} | 3. 、 -.5 、 5.3 | 必须有点 |
| 科学计数法 | {POINT_DEC}e{DEC} | -.54e-17 | 指数部分必须是纯十进制整数，前置0不会被当做八进制 |
| 正负无穷 | ±Inifity | Float/Double.POSITIVE_INFINITY/NEGATIVE_INFINITY，也可以用非0除以0.0得到 | 和自己相等 |
| 非数 | Nan | 0.0 / 0.0 | 和任何数包括自己都不相等 |

- 浮点型常数体现编译时类型：

| 表示法 | 常量编译时类型 |
| --- | --- |
| {FLOAT}f | float |
| {FLOAT} | double |

<br><br>

### 五、常量的下划线分隔：[·](#目录)
> 可以在常量的任意位置加下划线分隔，以免较长的常量阅读起来困难.

<br>

- 示例：

```Java
int a = 0b1000_1010_11;
float b = 3.11_3e2_3;
```

<br><br>

### 六、常量池：[·](#目录)
> .java中所有出现的常量在编译后都会保存在**常量池**中，常量池**位于.class文件中**，**以硬编码的形式存储在代码段的起始部分**.

<br>

- 常量池保存常量的规则就一句话：所有的常量都会**只保存一个唯一的副本**于常量池中
  1. 常量包括：null、1.5f、0xff32L、"abc"、'a'、'a' + 7.0等常量或者**常量表达式**.
  2. 唯一性：String a = "abc"; String b = "abc"; a == b; // true，"abc"唯一（不会保存多个副本）
  3. **常量表达式也是一种常量：String a = "abc"; String b = "a" + "bc"; a == b; // true，常量表达式的值是能唯一确定的，因此结果肯定也只保存唯一的一份.**
  4. 但**变量表达式的结果就是重新new出来的**，不再是常量了！
    - 因为变量的运算在运行时已经不可能由编译器控制了（运行时）.

```Java
String s1 = "1234";
String s2 = "12";
String s3 = "34";
out.println(s1 == s2 + s3);  // false
```
