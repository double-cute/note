# 简洁迭代的只读数据视图

7. Collection保存的是引用——注意事项3（重申）最好不要保存可变数据：
    1) 这里需要指出的是不管是Set还是Map，即所有的Collection保存的全都是引用（只能保存对象类型数据，即使直接存放基本类型，也会被自动隐式地包装成相应的包装器类型）；
    2) 因此像很多返回查找到的元素的方法（first、last等），返回的都是集合重元素的引用，如果你通过该引用修改了那个元素，那么就意味着集合中相应的元素也被修改了！
    3) 正式因为这个问题，集合中最好不要保存可变数据，因为你在集合外的修改会影响到集合内；
    4) 最致命的就是这样的修改会破坏集合本身的规则：由于修改可能会导致集合元素的hashCode、equals、compareTo/Comparator等结果的改变，但是这种改变并不会调整元素在数据结构中的位置，这可能会导致严重的错误！
    5) 这之前讲过，在这里（SorteSet中）例子就是：集合[1, 2, 3, 4]，如果你通过查找的方式获取了3的引用，并在集合外修改成了5，那么原集合就变成了[1, 2, 5, 4]，并不会因为这种修改而更新排序，这就违背了SortedSet排序的原则，可能会在后面的逻辑中出现非常致命的错误！
    6) 因此，如果你强行想修改元素同时也不想破坏集合原有的结构规则，那通用的方法就是：
        i. 先获取想修改的元素；
        ii. 删除该元素；
        iii. 将修改后的元素再重新加入集合；
！！按照这个顺序就可以保持原有的结构规则了！即“拿出来”修改，然后再“放回去”；

- 传统forEach代码块是一种**只读视角**：
  - 具体地说就是**不能在forEach代码块中**编写任何**修改集合元素的语句**，否则直接抛出**运行时异常**.
    1. 首先，ele只是一个**临时**的接受集合元素的变量，修改它**不会影响原来的集合**.
    2. 最后，这里说的**修改集合元素的语句**是指那些**强行的、暴力的、直接的**修改语句，特指**直接通过集合对象修改集合内容**，例如：
  - 强行修改会抛出**并发修改异常[ConcurrentModificationException]** .
    1. 传统forEach底层采用**并发（并行化）遍历**，因此存在并发冲突问题.
    2. 而**Java集合框架都是单线程的**.
      - Java**单独提供了一套并发（多线程）集合框架**，后面会详细讲解.
    3. 因此在并发条件下只能进行只读操作，不能进行修改操作.

```Java
// 直接运行时异常ConcurrentModificationException
for (type ele: list) {
	list.remove(...); // 强行通过list（集合对象）修改集合内容
    list.get(1).setValue(...);  // 也是强行通过集合对象修改集合内容
    list.add(...);  // 一样
}
```


<br>

- **3.&nbsp; .forEach(Consumer)同样是并发只读视角：**
  1. ele临时变量无法改变集合内容.
  2. 强行暴力修改集合内容抛出 **[ConcurrentModificationException]** 异常.

### 四、简洁迭代的只读数据视图原理：[·](#目录)

<br>

**1.&nbsp; 为什么Java中的各种`简洁迭代`过程都要求是 `只读数据视图` 的？**

- 简洁迭代（**传统forEach、.froEach(Consumer)、Iterator&forEachRemaining**）最突出的优点就是**代码形式简洁**.
  1. 一旦涉及到修改集合内容的操作都会使迭代的过程复杂（代码量也随之上升）.
  2. 因此Java在设计理念上要求：
    1. **简洁迭代就只读，简洁得纯粹**.
    2. 如果想修改集合内容，进行**复杂的迭代**，那就使用**普通的for、while、do-while**吧！
      - Java直接**把这个理念作为规则对待**，因此冷静地接受吧，不要骚气了.

<br>

**2.&nbsp; 只读数据视图原理：**

1. 先将被迭代的集合**锁定住**.
  - 锁住的意思就是不能修改了（只读）.
2. 再创建一个该集合的临时副本（即视图，视图的意思就是一张照片，并不是照片中的本人）.
3. **简洁迭代遍历的其实就是这个临时副本.**
  - 那既然原数据被锁定了（只读），为什么不直接遍历原数据呢？
    1. 这样可以兼容并发遍历（多线程）.
    2. 由于每个线程遍历都需要维护自己的位置指针.
    3. 而一个副本一个指针刚好满足这样的要求.
4. 使用**多线程框架中的集合允许对这个视图进行修改，最终将视图的修改更新进原数据**.
  - 因此多线程集合允许对集合进行修改.
  - 而单线程版本不允许.
    - **单线程集合在简洁迭代时对视图修改也不允许！**

<br><br>


### 三、集合的天敌：可变元素  [·](#目录)
> 如果随意**改变集合中元素的内容**，就可能**导致该元素位置信息的紊乱**.

<br>

**1.&nbsp; 原因很简单：**

- 虽然元素**内容改变**了，但其本身在集合中的**物理位置没有改变**.
- 但由于内容改变了，依赖内容计算的**hashCode、equals等决定物理位置的信息值**也随之**改变**.
- 这就导致实际 **物理位置**和**位置信息** 不匹配而发生 **信息错位**，从而导致致命的错误.

<br>

**2.&nbsp; 以HashSet为例：**

```Java
class R {
	int val;
	public R(int val) {
		this.val = val;
	}
	@Override
	public int hashCode() {
		return val;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}

		if (obj != null && obj.getClass() == R.class) {
			R another = (R)obj;
			return this.val == another.val;
		}

		return false;
	}
	@Override
	public String toString() {
		return String.valueOf(val);
	}

}


HashSet<R> hs = new HashSet<>();

// op1
hs.add(new R(5));
hs.add(new R(-3));
hs.add(new R(9));
hs.add(new R(-2));

// -2 -3 5 9

Iterator<R> it = hs.iterator();

// op2
R first = it.next();
first.val = -3;
// -3 -3 5 9

// op3
hs.remove(new R(-3));
// -3 5 9

// op4
hs.contains(new R(-3));  // false
hs.contains(new R(-2));  // false
```

- op1：4个add

| 桶编号 | 内容 |
| --- | --- |
| -2 | -2 |
| -3 | -3 |
| 5 | 5 |
| 9 | 9 |

- op2：first.val = -3

| 桶编号 | 内容 |
| --- | --- |
| -2 | **-3**（原来是-2）|
| -3 | -3 |
| 5 | 5 |
| 9 | 9 |

- op3：hs.remove(new R(-3));
  - hashCode找到桶(-3)，再找equals(-3)
  - 因此删掉了**第2个**桶.

| 桶编号 | 内容 |
| --- | --- |
| -2 | **-3** |
| ~~-3~~ | ~~-3~~ |
| 5 | 5 |
| 9 | 9 |

- op4：
  1. hs.contains(new R(-3)); // -3的桶找不到，false
  2. hs.contains(new R(-2)); // -2的桶能找到，但里面装的内容是-3，equals返回false

| 桶编号 | 内容 |
| --- | --- |
| -2 | **-3** |
| 5 | 5 |
| 9 | 9 |

- **可以看到混乱至极.**

<br>

**3.&nbsp; 总结：**

- 不仅是HashSet，还有很多需要hashCode、equals以及其它（甚至自定义）方法计算物理位置的集合.
  1. 要么存放只读元素.
  2. 如果存放的是可变元素，那也尽量不去修改（严格地说应该是禁止修改）其中元素的内容.

<br><br>
