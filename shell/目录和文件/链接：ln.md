# 链接：ln
> - Linux文件系统中有2种链接文件：
>    1. 硬链接：**多个硬链接指向同一个inode**.
>       - 实质是为同一个inode多添加一个文件名.
>       - **硬链接不是文件，仅仅就是一个文件名**.
>    2. 软链接：等价于Windows中的快捷方式.
>       - 专门创建一个文件，其内容是其指向的项目的路径名.
>       - 也就是说 **软连接就是一个单独的快捷方式文件**.
>
>> - 使用cp和ln命令都能创建链接.


<br><br>

## 目录

<br>

- coreutils: /bin/ln

<br>

1. [硬链接](#一硬链接)
2. [软链接](#二软链接)
3. [创建链接时强制覆盖选项：-f](#三创建链接时强制覆盖选项-f--)

<br><br>

### 一、硬链接：[·](#目录)

<br>

**1.&nbsp; 创建硬链接：只能针对文件创建，不能针对目录创建**

| 命令 | 说明 |
| --- | --- |
| ln 源文件 创建出来的硬链接 | - |
| ~~cp -l 源文件 创建出来的硬链接~~ | 同上（等价）|

<br>

**2.&nbsp; 硬链接的本质：基于ext文件系统inode的冗余文件名**

<br>

1. 创建的只是一个文件名，不占用新的inode.
   - **和源文件名指向同一个inode.**
2. ls -l的第2列就是指该项目所指向的inode有多少个硬链接.
3. 因此**源文件其实也是一种硬链接**.

<br>

- 示例：

```Shell
$ ln test.txt ../a.txt
$ ls -irl test.txt ../a.txt
3280490 -rw-rw-r-- 2 ··· test.txt
3280490 -rw-rw-r-- 2 ··· ../a.txt
```

- 可以看到指向同一个inode，并且hard link数+1.
- 实质上上面ln命令的效果等价于：

```Shell
# 仅仅就是多了创建了一个文件名而已
$ vvim .
test.txt 3280490  
$ vvim ..
a.txt 3280490
# 目录实际上是一个文件，里面记录了其中各个项目所指向的inode
```

<br>

- 因此硬链接不增加inode，也基本不增加block.
   - 除非目录描述内容原来刚好沾满一个block，加了一个文件别名条目之后刚好需要增加一个block.
   - 可以用 **du -sb; df -i;** 查看增加硬链接和软链接后磁盘空间的变化来验证这一点.

<br>

**3.&nbsp; 硬链接的局限性：**

1. **不能跨文件系统：** 等价于不能在**不同挂载点之间**硬链接.
   1. 首先，如果是两种不一样的文件系统：一个是ext，另一个不是ext.
      - 很明显，硬链接是基于inode，而inode只有ext系统中才有.
         - 明显和其它文件系统不兼容.
   2. 其次，就算两个都是ext系统（但不在一个分区）也不行.
      - 虽然两个都是ext系统，但两个系统中的inode相互独立、互不干扰.
      - 因此链接出来的inode可能会重复！
2. **不能链接目录：**
   - 由于ext本身的限制，硬链接到目录会导致复杂度极其巨大.

<br>

**4.&nbsp; 操作硬链接：**

- 很显然，对任意一个硬链接的操作其实都是对它们指向的inode代表的源文件的操作.
   - 更何况inode不仅指向实际的源文件，也保存着文件的所有属性. （硬链接也可以改变源文件属性）
   - 因此，任何操作：修改内容、cp、mv、rm、属性修改等都和之前讲过的相同，没区别.
      1. 修改内容：修改inode指向的源文件block中的内容.
      2. cp：不是复制硬链接本身，和以前一样，就是复制出一个新的inode（以及新的block）.
      3. mv：仅仅是改名.
      4. 属性修改：修改硬链接指向的inode里记录的源文件属性.
- 只不过对于 **删除操作rm**，只有删掉最后一个剩下的硬链接后才会真正彻底删除源文件.
   - 每删一个硬链接，ls -l第2列就-1.

<br>

**5.&nbsp; 新建目录后硬链接数量的变化：**

> 例如：在dir/下新建一个test/目录.

1. 由于test/..也指向dir/，因此dir/的硬链接数+1.
2. 由于test/.也指向test/，因此新建的test/的硬链接数为2.
   - 总结：
      1. 新建目录的硬链接数必定为2.
      2. 新建目录后的上级目录硬链接数必定+1.

<br><br>

### 二、软链接：[·](#目录)

<br>

**1.&nbsp; 创建软连接：目录和文件都可以创建**

| 命令 | 说明 |
| --- | --- |
| ln -s 源项目 创建出来的软链接项目 | - |
| ~~cp -s 原项目 创建出来的软连接项目~~ | 同上（等价）|

- 特殊玩法：硬链接一个软链接，那结果也是个软链接，和被链接的软链接的inode相同.

```Shell
$ ln a.so-lnk b.so-lnk; ls -il;
4398562 ··· a.so-lnk -> ../source.txt
4398562 ··· b.so-lnk -> ../source.txt
```

<br>

**2.&nbsp; 软链接的本质：Windows快捷方式**

1. 额外创建除了一个新文本文件，记录了源文件的路径！因此：
   - 软连接占用了1个额外的inode. (ls -i就明白了)
   - ln -s ../a a.lnk 等价于 vvim a.lnk : ../a
      - 因此软连接必定会添加额外的inode和block.
      - 添加前后 **du -sb; df -i;** 一下即可验证.
2. ls -F中的 **@后缀链接文件** 指的就是软连接文件，而**不是硬链接文件**.
   - 硬链接就是普通文件，@链接文件（软连接文件）还会用特殊颜色高亮显示.
3. ls -l的最后一列（项目名）会指出软连接的指向（其实就是**vvim的内容**）.
   - 例如：a.lnk -> ../a

<br>

**3.&nbsp; 软链接的优势：** 正由于这么多优点导致软链接比硬链接使用更广泛.

1. 众所周知，快捷方式可以链接目录，因此 **软链接必定可以链接目录**.
2. rm删除软链接是安全的，只删除链接，不影响指向的终目标.
3. 由于软链接只是记录一条终目标路径名（字符串），因此可以跨文件系统.
   - 字符串跨平台，当然可以跨文件系统.

<br>

**4.&nbsp; 多重（嵌套）软链接：**

> 例如：ln -s a b; ln -s b c; ln -s c d;

- 原理是不变的，就是记录源目标的路径名.
   - 因此ls -l得到的是：b -> a, c -> b, d -> c.
- 但它们的终目标都是a，因此操作它们如果能产生作用，都是作用于a（终目标）.
- 断链问题：
   - 如果rm链上的某一个软链接，那么会影响后面的所有软链接（没有指向，找不到终目标）.
   - ls(-l)的时候会高亮警告（断点开始后面所有的软链接**全部警告**！）
   - 发出警告的依据是 **找不到终目标**，而不是 **找不到直接指向**.

<br>

**5.&nbsp; 对软链接的操作：**

<br>

1. 修改内容：修改的是终目标的内容，这是理所当然的，毫无疑问.
   - 快捷方式的最普遍用法.
2. 修改属性（权限）：修改的是 **终目标的属性**.
   - 软链接本身属性不变，权限永远是默认的777，永远无法改变.
3. mv：就是给软链接本身改名，不影响终目标.
4. rm：删除的是软链接本身，不会删除终目标. (**即使是rm -rf删除的也是链接本身**)
5. cp：如果复制的软链接指向的终目标是 (上面的操作对于终目标是文件和目录都成立)
   1. 文件：那复制的就是终目标文件.
      - 如果这种情况下想复制软链接本身，干脆就直接再创建一个软链接即可.
   2. 目录：
      - 首先，必须cp -r才能复制.
      - 其次，复制的仅仅就是软链接本身.
         - 不会递归复制源目录.
         - 其中的-r选项只是一种标志，并不是代表递归复制源目录.
      - 如果这种情况下想复制源目录本身，干脆就直接复制源目录.

<br>

- 对于软链接目录要特别提醒：一旦进入软链接目录后，那进入的就是真实的终目标目录了.
   - 在里面乱删东西会直接影响源真实目录中的内容.

<br><br>

### 三、创建链接时强制覆盖选项：-f  [·](#目录)
> 在创建链接（**硬链接、软链接都有效，ln、cp都有效**）使用.
>
>> - 即，创建出来的链接如果已存在（重名），则直接覆盖.
