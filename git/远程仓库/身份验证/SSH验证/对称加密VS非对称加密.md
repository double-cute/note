# 对称加密VS非对称加密
> 对称加密采用单秘钥，非对称加密采用双秘钥，后者更安全可靠.

<br><br>

## 目录

1. []()

<br><br>

### 一、加密、解密、加密算法、秘钥：

- 基本定义：
  1. x是明文，y是密文.
  2. 加密函数f满足：y = f(x)
  3. 解密函数F满足：x = F(y)

<br>

- 加密、解密：
  1. 加密就是让x变成y的过程，即加密函数f.
  2. 解密就是让y变成x的过程，即解密函数F.
- 加密算法：定义为**f->F**
    - 由加密函数指向解密函数.
    - 方向就表示用f加密，F解密.
- 可逆加密算法：
  - 如果解密函数也可以用来加密，并且解密函数加密后的密文可以用加密函数破解，那么这样的加密算法就是可逆的加密算法.
  - 即满足y = f(x), x = F(y)的基础上，**同时还满足** y = F(x), x = f(y)
  - 可逆加密算法定义为：**f<->F**
    - 关系是双向的，此时f和F不分彼此，都称为加解密函数.
- 不可逆加密算法：即f和F之间的关系是单向的
  1. 如果是f->F，那么f就是加密函数，F是解密函数.
  2. 如果是F->f，那么F就是加密函数，f就是解密函数.
- 在不知道加密算法时候可逆的情况下就直接用**f-F**表示一个加密算法：
  - \-表示两者关系未知.
  - 仅仅是笼统地表示这是一个加密算法罢了.

<br>

- 加密算法**可逆的条件**：那必定是明文x和密文y的**定义域完全相同**才行.
  - 例如：
    1. 如果f-F定义为一个二元一次方程x + y + 1 = 0
      - 即f(x) = -x - 1, F(y) = -y - 1
        - 发现x和y的定义域都是R，因此即可以f->F，也可以F->f，因此是一个双向的关系，即f<->F.
    2. 如果f-F定义为密表加密：
      - 即f(x) = x在《老人与海》中的(页, 行, 列)三元组，F(y) = 根据y这个三元组在《老人与海》中查到相应的x
        - 发现x是书中的字，y是三元组，两者类型不同，更别提定义域了，因此关系是不可逆的，只能是f->F.

<br>

- 秘钥：
  - 称为**secret key**，简称key，用k表示.
  - 定义是：加密算法f-F的**输入参数**.
  - 回顾上例：
    1. f<->F：x + y + 1 = 0
      - f(x) = -x - (**+1**), F(y) = -y - (**+1**)
      - 那么秘钥k就是+1，即k = +1，即只有知道方程的参数+1后才能正确地求x或y.
    2. f->F：密表《老人与海》加密
      - f(x) = x在**《老人与海》**中的(页, 行, 列)三元组，F(y) = 根据y这个三元组在**《老人与海》** 中查到相应的x
      - 那么密钥k就是**《老人与海》** ，即k = 《老人与海》，即只有知道到底是哪本书作为密表才能正确地加解密.
- 因此加密算法的总定义应该是：**[f:kf]-[F:kF]**
  1. kf就是函数f的输入参数，即f的密钥.
  2. kF就是函数F的输入参数，即F的密钥.
- 一般为了方便起见，加密算法还是笼统地定义为**f-F**，默认两者密钥分别为kf和kF了.

<br><br>

### 二、现代密钥机制以及加密攻击：

- 目前广泛采用的加密机制：
  - 往往加密算法是**公开的**.
    - 例如，这家网站本身就已经在证书上告诉大家该网站和浏览器通信使用的加密算法是AES或者是IDEA之类的，请大家事先给浏览器装好相关的加密算法实现软件.
  - 而密文在传输过程中也是暴露在外界的.
    - 这是必然的，明文加密后可以在网络上随意传输，骇客们可以随便拦截.
  - 而唯一不公开的就是通信双方的密钥了.
    - 骇客想破解密文必须要有解密函数的密钥才行.
    - 解密密钥就可以直接破解了.
    - 密钥就相当于门钥匙，如果小偷拿到了你家钥匙，那就呵呵了.

<br>

- 加密攻击：就是指破解密钥的行为
  1. 最简单粗暴的方式就是通过各种手段偷取解密密钥，有了密钥就可以直接破解密文（毕竟加密算法也是公开的）.
  2. 那没有密钥怎么办呢？
    - 就只能通过暴露在外界的密文样本、公开的加密算法和自己的聪明才智破解出密钥，然后再破解密文咯!

<br>

- 加密攻击的代价：
  - 就是指根据密文样本、公开的密钥算法来破解密钥的难度.
  - 难度包括是指能否在有限的时间和有限的步骤之内完成密钥的破解.

<br><br>

### 二、对称加密：
> 即kf = kF的加密算法[f:kf]-[F:kF]

- 上面例子中的加密算法都是典型的对称型加密算法：
  - 特别的，像上面的密表加密法是最最典型的对称型加密算法，如果用《老人与海》加密，那你用《天龙八部》解密肯定行不通.

<br>

- 对称加密最大的风险：通信时有直接传递秘钥的需求
  - 为了增加安全性，可能需要不停地更新秘钥，就拿上面的密表加密法来说：
    1. 假设当前使用的密表是《老人与海》，双方通信10次了以后觉得应该换一个密表了.
    2. 于是在第11次通信的时候会发送以下内容：以后我们用《天龙八部》作密表了.
      - 然后再用《老人与海》对上述消息加密发送给对方.
      - 对方用《老人与海》破译后就明白了一切.
    3. 在接下来的第12次（以及之后）通信时双方就改用《天龙八部》来加解密了.
- 可见，为了动态更新秘钥，可能会将更新后的秘钥放在通信内容中传递，这风险就很大了，设想：
  - 如果《老人与海》被破解出了，那么就可以破解出第11次通信的内容，然后就知道之后使用的新密表《天龙八部》了.
  - 接着之后所有的通信都能破译，即使再更换新的密表也不管用了.

<br>

- 对称加密安全性保证：
  1. 按照道理来说秘钥应该不见光，除了通信双方持有外不能给任何机会暴露给外界.
  2. 但身边人有偷取秘钥的风险，因此有更新秘钥的需求，这就导致新秘钥的传递.
    - 由于传递也是一种暴露秘钥的行为，因此存在一定风险.
    - 所以一定要保证传递秘钥过程的安全性.

<br>

- 对称加密的风险评估：
  1. 双人头风险：两个人持有密钥就要担心两个人泄露秘钥的风险.
    - 如果只有一个人持有秘钥的话只需要担心这一个人会不会泄露密钥，两个人双份风险.
  2. 密钥传递风险：传递密钥的过程存在风险.

<br><br>

### 三、非对称加密：公钥加密
> 即加密密钥**不**等于解密密钥的加密算法.
>
>> 即ke ≠ kd

- 减少双人头风险：公钥/私钥-双密钥钥
  - 为了避免两个人泄露密钥的的风险非对称加密机制采用公钥/私钥-双密钥的加密方式.
  - 公钥可以公开给所有人（直接暴露给外界），私钥要交由通信双方的一方来保管，并且不能公开（就像对称加密保护密钥那样保护好）.
  - 这样就泄露私钥的可能只存在于一个人身上，大大降低了双人持有密钥的风险.
