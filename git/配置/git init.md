# git init
> 在本地创建一个仓库.
>
>> 创建的特点就是**从无到有**.

<br><br>

## 目录

1. [git仓库的类型：工作库和裸库](#一git仓库的类型工作库和裸库--)
2. [创建空的仓库：git init](#二创建空的仓库git-init--)

| 命令 | 说明 |
| --- | --- |
| git init | 创建工作库：在当前目录中创建一个.git/ |
| git init wks | 创建工作裤：创建一个空的工作区wks，在其中初始化一个.git/ |
| git init **--bare** path/xxx.git | 创建裸库 |
| git config **core.bare** | 检查一个仓库是否是裸库（要在.git/中使用）|

<br><br>

### 一、git仓库的类型：工作库和裸库  [·](#目录)
> 工作库是指有工作区的版本仓库，而裸库是指没有工作区的版本仓库，它的.git/目录直接暴露在外界.

<br>

- 工作库：
  - 有工作区的版本库仓库.
  - 特点：**`.git/`版本控制目录直接包含在工作区根目录中.**
    - 最显著的特点：具有工作区，可以将工作区中新开发的内容更新到 `.git/` 版本控制目录中.
  - 命名的时候就以工作区的名称来命名这个版本库.
    - 例如：`proj/.git` 所定义的版本库，那我们可以将它称为 `proj.git` 版本库.
      1. .git后缀表明现在描述的是一个git版本库.
      2. 而前缀proj则是这个git版本库的名称.
    - 这个 `xxx.git` 只是一种版本库的称谓罢了，这样“叫它”比较方便，一目了然.

<br>

- 裸库：
  - **木有** 工作区的版本仓库.
  - 特点：**`.git/`版本控制目录直接暴露在外界，没有工作区.**
    - 由于没有工作区，所以 **不能在裸库上进行开发**.
      - 没有工作区自然就没有stage、git add、git commit一说了，因此必然不能在裸库上进行开发.
  - 由于没有工作区，因此命名成了问题，没法用工作区的名称来命名，因此裸库的命名方式直接是：**`仓库名.git`**
    - 即使它的.git/目录是暴露在外界的，也不会和其它裸库相混淆了.
- 那裸库不能用来开发那还能干啥呢？
  - 当然是 **作为远程托管仓库** 使用了，像GitHub上面托管的仓库都是裸库.
  - 即 **工作库用于本地开发，裸库作为远程托管**.
- 如何查看一个仓库是否是裸库：
  1. 先进入 `.git/` 目录.
  2. `git config core.bare`  # 返回true则表示是一个裸库
     - 其实直接通过目录的命名也可以一眼看出：`XXX.git/`肯定是裸库，`.git/`肯定是工作库

<br>

- 工作库和裸库作为远程仓库时的区别：
  1. 由于工作库有工作区，因此 **不能往工作库push，但是可以相互pull**.
     - push过去的内容可能会和对面的工作区相冲突.
        - 因此工作库之间不能相互push（如果push的时候git客户端检查对面的是工作库则会直接拒绝的）.
     - pull是一种自愿的行为，因此允许从对面的工作库pull代码.
  2. 而裸库没有工作区，因此可以随意往裸库push（前提是你要有权限），当然从裸库pull就更没问题了.
     - 没工作区因此不用考虑push过去的内容和“工作区”冲突的问题了.
     - 正因为如此，裸库常常作为远程托管仓库来应用.


<br><br>

### 二、创建空的仓库：git init  [·](#目录)

<br>

- 创建**工作库**：
  1. git init   \# 以当前目录作为工作区创建一个.git/版本控制目录
  2. git init 工作区目录（自己新命名）  \# 在当前目录下创建一个指定名称的工作区目录，然后在工作区根目录中创建一个.git/目录
    - 示例：git init MyWork
      - 会在当前目录下创建一个工作区 `MyWork/` 目录，并在 `MyWork/` 底下创建一个 `.git/` 目录.

<br>

- 创建**裸库**：git init **--bare** path/xxx.git
  - 例如：git init --bare test.git  \# 在当前目录下创建一个空的test裸库（test.git）
- 在GitHub页面上创建空的仓库底层使用的就是 `git init --bare` 命令.
