# 当前工作节点和当前工作分支（HEAD）
> 这是git版本控制的基础概念.
>> HEAD是版本库中的当前工作节点.

<br><br>

## 目录
1. [当前提交的stage节点应该插入到版本库的哪个位置？]()
2. [HEAD确定位置]()
3. [HEAD确定分支]()

| 内容 | 说明 |
| --- | --- |
| HEAD | 表示当前工作节点（git commit插入到HEAD节点后一个位置）|
| [OP: \*HEAD = SHA1(node)] | HEAD直接指向任意分支的任意节点（任意位置）|
| [OP: \*HEAD = &branch] | HEAD指向某分支的最新节点（即包含分支信息，也包含位置信息）|

<br><br>

### 一、当前提交的stage节点应该插入到版本库的哪个位置？  [·](#目录)
> 就是指git commit提交的节点应该插入到版本库的什么位置.

- 由两个信息确定插入的位置：
  1. 首先要确定插入到哪个分支上.
  2. 其次要确定插入到确定分支的哪个位置.
- 核心词：**分支**、**位置**.

<br>

- git commit默认将stage节点插入到**当前工作节点**处（即当前工作节点的**后面一个位置**）.
- 当前工作节点在git中用**HEAD**表示：
  1. HEAD是一种特殊的节点引用，表示版本库中的当前工作节点.
  2. git commit就将stage节点插入到HEAD的后一个位置.
- **因此**，HEAD必须要包含上述的两层含义来为git commit提供插入信息：**分支和位置**.

<br><br>

### 二、HEAD确定位置：[·](#目录)

- 由于HEAD的数据类型本身就是普通的节点引用（node类型），因此HEAD可以指向版本库中任意一个节点.
  - 准确地说是**任意分支**的**任意节点**.

<br>

- 具体实现：
  1. 由于git本身由C语言实现，因此这里的节点引用底层是节点指针.
  2. 引用值就是指针值，指针值就是节点地址值，在git实现中节点地址就是节点的提交ID，即SHA1编码.
  3. 因此可以通过**[OP: \*HEAD = 某节点的SHA1码]** 操作使HEAD指向任意节点.

<br><br>

### 三、HEAD确定分支：利用**分支引用**  [·](#目录)
> 上述HEAD确定位置的方法并没有确定HEAD指向哪个分支.
>> 也就是说现在的困难是如何让HEAD透露位置的**同时也能透露出分支信息**.

- 这个很好办：在git中**分支名**也是一种特殊的节点引用.
  - 分支名实际上是一种特殊的指针变量（节点引用变量，称为**分支引用**），在git中，它始终指向该分支名所代表分支的**最新**节点.
    1. master就指向名为“master”的分支的最新节点.
      - [OP: \*master = \*master^]就让master指向上一个节点了.
    2. branch_x就指向名为“branch_x”的分支的最新节点.

<br>

- 因此HEAD确定分支的**同时确定位置**的方法就是：**[OP: \*HEAD = &branch]**
  1. 就是让HEAD指向分支引用，由于分支引用属于具体分支，同时也指向具体节点（该分支的最新节点），因此HEAD也就同时包含分支和位置这两层信息了.
  2. 会发现HEAD的数据类型是一个复合指针类型，即是node*类型，也是node**类型.
    - [OP: \*HEAD = 某节点的SHA1码]中，HEAD是node*类型的.
    - [OP: \*HEAD = &branch]中，HEAD是node**类型的.
