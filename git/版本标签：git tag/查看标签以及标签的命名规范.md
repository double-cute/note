# 查看标签以及标签的命名规范
> 版本标签用于标识版本库中的节点，不仅见名知意而且引用时也非常方便.

<br><br>

## 目录

1. [什么是版本标签？](#一什么是版本标签)
2. [标签的命名规范](#二标签的命名规范)
3. [查看标签](#三查看标签)
4. [查看相对进度：git describe](#四查看相对进度git-describe--)

| 命令 | 说明 |
| --- | --- |
| git tag | 列出所有存在的标签 |
| -n | **额外** 显示标签的说明（没说明的显示提交说明）|
| -nx | **额外** 显示标签说明最多显示x行 |
| -l 筛选的正则表达式 | **额外** 用指定正则表达式筛选出满足要求的标签 |
| git log **--decorate** | **额外** 历史节点中有标签的节点再额外显示一下它的标签 |
| git describe [节点引用] | 查看指定节点（默认为HEAD）相对于最近标签（向前看）的距离（提交次数）|
| --always | **额外** 如果前面没有标签**则不报错**，只是显示指定节点的提交ID |

<br><br>

### 一、什么是版本标签：[·](#目录)

- 最直接的意思就是：给版本库中的节点取个别名
  - 例如：
    1. 给HEAD^^取个别名v1.2.3
    2. 给提交ID为6af9c2b的节点取个别名为v2.3-module
  - 上面的别名v1.2.3以及v2.3-module就是所谓的**版本标签**.
  - 后面就用“标签”作为“版本标签”的简称了.

<br>

- 标签的作用：
  1. 很显然，见名知意，让一个节点具有意义.
    - 比如v1.2.3表示这是这是第一个大版本的第二个补丁的第三次bug修复，这是一个正式版本.
    - 具体来讲，比如：
      1. v6.2.2表示：德拉诺之王（6.0） - 第二个补丁（黑石铸造厂） - 第二次bug修复.
      2. v7.1.5表示：军团再临（7.0） - 第一次升级（翡翠梦魇） - 第5个补丁（重返卡拉赞）.
  2. 标签也是一种节点引用，可以快速访问节点：
    - 和HEAD、master（分支引用）、节点提交ID等都属于节点引用.
    - 例如：git archive -o latest.zip v1.2.3
    - 只不过标签**只能**指向**节点**，**不能** 指向**分支**
      - 举例来讲：
        1. &v1.2.3的值只能是6fc34a这种节点提交ID，不能是master等分支引用.
        2. 即使对master、branche_name这种分支引用指向的节点建立标签，也是直接将该节点的节点ID赋给它.

<br><br>

### 二、标签的命名规范：[·](#目录)
> 只是一种建议，比较优秀，比较通用.

- 模板：<项目名称>-v<构架>.<主题>.<内容补丁>.<bug修复补丁>\-r<第几次β测试>
  1. 项目名称：即产品名称，比如wow
  2. 构架：即大版本号，整个项目构架、需求等的不同版本、资料片的版本.
    - 如v6，德拉诺之王
  3. 主题：即小版本号，表示当前的主题，主要功能.
    - 如v7.0只开放100-110升级，v7.1开放了大秘境和团本.
  4. 内容补丁：即小版本中增加的内容，即功能上的一些补充.
    - 如v7.1.2增加了“两个”史诗地下城，v7.1.3增加翡翠梦魇的史诗模式，v7.1.4增加了重返卡拉赞等.
  5. bug修复补丁：即一些小的bug修复.
    - 如v7.1.2.3表示v7.1.2版本下的第3次bug修复.
  6. β测试：即公测的次数.
    - 如wow-v7.1.2.5-r3表示wow-v7.1.2.5版本的第3次公测.

<br><br>

### 三、查看标签：[·](#目录)
> 标签是可以有标签说明的（当然也可以没有）.

1. git tag
  - 列出当前版本库中存在的**所有**标签.
    - **不管有没有标签说明，全部列出.**
  - 一行一个标签名，**不显示标签说明**.
2. -n选项：
  - 附加特效：**额外** 显示标签的标签说明.
    1. 如果标签有说明则显示说明.
    2. 如果没有标签说明的，则显示那个标签所在提交的**提交说明**.
  - -n[数字]：
    - 考略到有些标签说明特别长，可以跟个数字限制每个标签说明最多显示多少行.
3. -l选项：
  - 附加特效：**额外** 使用通配符筛选想要查看的标签.
  - 例如：git tag -l codec/v2*
    - 结果只列出以"codec/v2"开头的所有标签.
4. 组合使用：
  - 例如：git tag -n2 -l str/v1.2*
    1. 列出所有以"str/v1.2"开头的标签.
    2. 额外显示标签说明.
    3. 标签说明最多显示2行.

<br>

- git log的**--decorate**选项：
  - 如果历史提交有标签，则**额外显示它所对应的标签**.
  - 例如：git log --oneline --decorate
    - 634446e (HEAD -> master) test
    - a5455c0 (**tag: v8.8, tag: v7.2**) newb  # 这个节点打了两个标签
    - 9f9654e ma
    - ····

<br><br>

### 四、查看相对进度：git describe  [·](#目录)

- 背景：
  - 当你转手到一个新的有进度的工作时第一件要做的事应该就是看一下当前项目进展的什么程度.
   - 但这种进展肯定是**相对**的进展，不可能直接问“从0开始，总共做了哪些东西”，也许内容太多了，根本无法一一了解，因此必须要相对于某个参照点来了解进度.
     1. 当前处于哪个版本下？也就是**最近的**那个版本
       - 比如处于v1.2.3的版本下，那就明白了目前已经开发播放器的解码器部分.
     2. 相对于该最近版本已经提交了多少次了？
       - 比如已经在v1.2.3的版本上提交了5次了，那就意味着编码器的编写和测试已经基本完善了，接下来就是写写文档了.

<br>

- 查看相对进度的两个关键点：
  1. 最近版本：即最近的标签.
  2. 与最近版本之间的距离：即相对于最近标签提交过多少次了.

<br>

- 命令：**git describe [节点引用]**
  - 查看指定节点的相对进度.
  - 如果[节点引用不写]则默认为HEAD.
  - 输出结果：<最近标签>-<距离>-g<指定节点的提交ID>
    1. 最近标签：是**向前看**的
      - 例如：要查看的节点A位于v1.1和v2.2之间（假设v2.2在v1.1之后）.
        - 那么A的最近标签是v1.1，即使A和v2.2之间的距离比和v1.1之间的距离更近.
        - 这是必然的，因为相对进度是一种**时序包含**关系，A处于v1.1这个版本之下，A出现时v2.1还不存在.
    2. 距离：距离最近标签有多少次提交.
  - 例如：git describe f7065c
    - 结果为：v1.8-5-gf7065c
    - 表示f7065c节点距离最近的v1.8标签提交了5次.
  - 注意！该命令要求指定节点之前必须至少要有一个标签才行，否则会直接报错！
    - **会忽略轻量级标签：** 即使之前有轻量级标签也会忽略.
    - 为了防止报错，加**--always**选项即可.
      - **如果之前有标签则正常输出，如果没标签则只输出指定节点的提交ID.**
