# 合并：git merge
> 虽然其含义仅仅是**拿另一个节点和当前HEAD进行合并**，但却是**合并分支的一种重要手段**.

<br><br>

## 目录
1. [git merge的用法：合并节点？合并分支？](#一git-merge的用法合并节点合并分支--)
2. [合并的原理](#二合并的原理)
3. [合并冲突问题](#三合并冲突问题)
4. [同体冲突的解决](#四同体冲突的解决)
5. [树冲突的解决](#五树冲突的解决)
6. [亲自审查冲突的合并：git merge --no-commit 节点引用](#六亲自审查冲突的合并git-merge---no-commit-节点引用--)

| 命令 | 说明 |
| --- | --- |
| git merge 节点引用 | 将指定节点和HEAD合并**提交**到HEAD之后的一个位置 |
| git mergetool | 手动解决冲突的无脑工具 |
| git merge --no-commit 节点引用 | 制止git merge的自动提交（常用于逻辑冲突的解决）|

<br><br>

### 一、git merge的用法：合并节点？合并分支？  [·](#目录)

- 用法：git merge 节点引用 -m 合并提交的说明
  1. 将HEAD和指定节点合并成一个新节点.
  2. 将新节点git commit到HEAD之后（同时将HEAD往后挪一位到该新节点上）.
  3. 由于必须要提交结果，因此必须-m一下，否则强制打开vi让你合并提交说明.

<br>

- 重点：
  1. 最终合并到**HEAD所处的分支上**.
  2. 会**多出一个**合并提交.

<br>

- 合并的到底是节点还是分支？
  1. 直观上看，合并的就是两个节点，这也是git merge命令的本身实现.
  2. 在git log --graph上看，就是**被合并的节点**（git merge命令中的节点引用）和合并节点之间连了一条线.
  3. 实际上git merge命令并对**被合并节点**所在的分支做任何改变（不该变那个分支的分支引用所指向的节点），因此可以理解为：
    - 被合并节点的**分支**和HEAD所处的**分支**在那个位置**发生了一次合并**.
    - 即，实际上（**物理上**）仅仅是两个**节点的合并**.
      - 但在**逻辑上**，是两个**分支**在那个位置发生了**合并**，而被合并节点所处的分支没有发生任何变化！

<br>

- 合并节点的父节点：规则是
  - 合并之前的HEAD是合并节点的第1父节点.
  - 被合并节点是合并节点的第2父结点.

<br><br>

### 二、合并的原理：[·](#目录)

- 示例：
  1. HEAD和NODE进行合并（git merge NODE），其中HEAD和HEAD^是绝对时间点.
  2. HEAD和NODE都相对于HEAD^修改了a.txt、b.txt

<br>

- 详细步骤：
  1. 先回退到上一个节点：git reset --hard HEAD^（当前工作区、stage、HEAD都是HEAD^了）
  2. 接着用HEAD和NODE同时修改HEAD^工作区：同时用HEAD(a.txt, b.txt)和NODE(a.txt, b.txt)修改工作区中的HEAD^(a.txt, b.txt).
  3. 此时必然发生冲突，需要合并HEAD和NODE对HEAD^的共同修改：
    1. 刚好发现a.txt可以自动合并，于是在工作区中自动合并成新的a.txt（相对于HEAD^(a.txt)）并git add a.txt到stage中.
    2. 但发现b.txt无法自动合并（必须由用户手动自行合并）.
      - 于是，先在工作区中初步合并b.txt（肯定还是相对于HEAD^(b.txt)），初步是指可以自动合并的部分先合并掉.
      - 而那些无法自动合并的部分（HEAD和NODE同时修改了同一行的内容，而且修改结果还不一样等情况）就**先在合并后的b.txt中标记出来**.
        - 由于有了标记，用户就可以快速定位到冲突位置自行合并.
      - 由于没有合并成功，因此无法将b.txt添加到stage中，用户需要自行在工作区中完成合并.
  4. 分情况：
    1. 如果[3.]中b.txt可以自动合并（也会add到stage中），那么就直接提交stage中的合并结果.
    2. 如果[3.]中b.txt无法自动合并，就会终止git merge操作，保留[3.]的现场，接下来让用户在工作区中自行完成合并.
      - 完成合并后，自行**git add b.txt、git commit -m 合并提交说明**后实现git merge未完成的全部步骤.

<br>

- 重点强调：合并必定是**相对于HEAD^** 的，这是必然的.
  1. 如果是相对于HEAD的话就无需合并了，也不会发生冲突了.
  2. 必定是两个节点同时相对于一个节点做出修改才会有合并的需求！
  3. 时刻牢记，合并是相对于HEAD^的！

<br><br>

### 三、合并冲突问题：[·](#目录)

- git merge非常只能，可以对以下情况自动合并（无需自己手动合并）：假设合并两节点A和B
  1. 不同文件的修改：A只修改了a.txt，B只修改了b.txt，那么合并时
    - 用A(a.txt)覆盖B(a.txt)
    - 用B(b.txt)覆盖A(b.txt)
  2. 同一文件不同位置的修改：A只修改a.txt的5-10行，B修改了a.txt的100-120行，那么合并时
    - 对合并节点同时应用A、B的两种修改即可.
      - 但如果A、B都修改了a.txt的5-10行，那么git merge就无法判断最终是应用A的版本还是B的版本.
      - 此时就发生了**同体冲突**，不得不自己手动合并了.
  3. 不同文件的增删移：A将a.txt移动成了aa.txt，B将b.txt移动成了dd/b.txt，那么合并时同时应用两者的修改即可.
    - 但如果A、B移动的都是a.txt，那么git merge就无法判断应用谁的版本了.
    - 如果A、B移动的结果都是aa.txt（A把a.txt移成了aa.txt，B把b.txt也移成了aa.txt），那同样也无法自动合并了.
    - 对于增加、删除、移动文件都会碰到这样的问题.
    - 这类冲突称为**树冲突**，同样须要手动合并.

<br>

- 总结无法自动合并只能手动合并的冲突：
  1. 同体冲突：修改了相同文件的相同位置.
  2. 树冲突：文件增删移的before或after相冲突.
  3. 逻辑冲突：
    - 是一种非常危险的潜在冲突，它可以正常合并（没出现同体冲突和树冲突），但是逻辑上有bug，导致最终的程序bug，示例：
      1. 不同文件的修改没有发生冲突：A只修改了a.c，B只修改了b.c，但它们修改的是头文件的\#include包含，虽然合并没有问题，但头文件没有修改导致编译错误.
      2. 同一文件不同位置的修改：A只修改a.c的5-10行，B修改了a.c的100-120行，但这两个地方的修改在程序逻辑上是相互排斥的，5-10的执行必然导致100-120的不执行，因此也会发生bug.
      3. 等等其它.

<br>

- git mergetool命令：无脑解决冲突
  1. 一旦发生无法自动合并的冲突时git merge命令会报错.
  2. git提供了一个合并冲突解决工具（命令）：git mergetool
  3. 输入回车后会弹出一个界面，然后根据界面中的提示一步一步往下走完成冲突的合并，非常无脑.
    - 非常适合新手小白.

<br><br>

### 四、同体冲突的解决：[·](#目录)

1. 首先git merge会拒绝合并，并提示哪些文件无法自动合并.
2. 其次，**成功合并的部分会加入stage中**.
3. 无法自动合并的冲突文件保留在工作区中不加入stage.
  - 这些冲突文件无法自动合并的部分（那几行）会自动用"<<<<========>>>>"标记包裹起来，让你快速定位.
  - 自己手动完成冲突合并后将这些冲突文件git add一下在提交完成最终的合并.

<br><br>

### 五、树冲突的解决：[·](#目录)

1. 首先git merge会拒绝合并，并提示哪些文件发生了树冲突，举例来说：A(a.txt -> ma.txt)、B(a.txt -> mb.txt)
2. 其次，会把**冲突结果**和**修改之前的文件**全部放到stage中，也就是说stage中同时出现了三个文件a.txt、ma.txt、mb.txt
3. 接着自己手动决定如何合并冲突：
  1. 比如两者择其一（如果决定保留ma.txt），那么直接git rm a.txt mb.txt，然后git commit即可.
  2. 比如选择两者命名融合（最终文件为mab.txt），那么直接git mv ma.txt mab.txt; git rm a.txt mb.txt，最后git commit即可.
  3. 或者其它合并方法，自己手动解决.

<br><br>

### 六、亲自审查冲突的合并：git merge --no-commit 节点引用  [·](#目录)
> 单纯的“git merge 节点引用”命令在没有发生无法自动合并的冲突时会自动合并提交.

- 加上\-\-no\-commit选项之后会**强制制止最终的提交步骤**.
  - 但是如果发生无法自动合并的冲突时还是会提示的.
  - 仅仅就是阻止最终的提交操作而已，**自动合并的操作还是会执行的**.
- 执行之后，就可以查看工作区以及stage中的自动合并结果，并决定是否需要再手动合并.
  - 可以用各种git diff查看变化决定是否需要亲自手动合并.
  - 通常为了避免**逻辑冲突**都会采用这种手段.
