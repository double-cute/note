# 变基：git rebase
> 让一条分支接到另一个分支上从而减少分支数量、让历史瘦身，不至于在git log查看时由于分支过多而眼花缭乱.

<br><br>

## 目录

1. [问题背景：让历史瘦身](#一问题背景让历史瘦身--)
2. [git rebase的基础用法](#二git-rebase的基础用法)
3. [底层实现](#三底层实现)
4. [变基冲突与高效变基诀窍](#四变基冲突与高效变基诀窍)

| 命令 | 说明 |
| --- | --- |
| git rebase [--onto] 嫁接点 | HEAD分支和嫁接点分支融合（嫁接到嫁接点上）成HEAD分支 |
| git rebase **--continue** | 一次冲突解决后继续变基的cherry-pick过程 |
| git rebase **--abort** | 取消本次变基操作（**完全**复原到变基操作之前的状态）|

<br><br>

### 一、问题背景：让历史瘦身  [·](#目录)

- 频繁git merge所带来的后果：
  - 如果分支数量本身就很多，再频繁地git merge的话就会导致git log查看历史时眼花缭乱（各种连线绕来绕去）.
    - 在master主分支上这个问题尤为严重：很多分支最后都是要合并到主分支上的.

<br>

- 不合理的解决方法：
  - 第一反应可能是：直接删除合并过的分支不就行了吗？
  - 但这样做的缺点也是很明显的：删除分支会导致分支的提交历史丢失，未来将需要查阅的时候无从查起.

<br>

- git rebase命令应运而生：
  1. 既能减少分支数量（减少连线）.
  2. 又能保留分支的历史.

<br><br>

### 二、git rebase的基础用法：[·](#目录)

- 命令：git rebase [--onto] 嫁接点（节点）引用
  - 意义是：
    1. 先找到**基点**：当前HEAD和嫁接点的最近公共祖先节点.
      - 即HEAD所在分支和嫁接点所在分支离这两个点最近的那个重合点.
    2. 然后将(基点, HEAD]区间整个嫁接到嫁接点上.
      - 注意：区间是**左开右闭**的.
    3. 嫁接完成后两分支融合，并且融合成HEAD的分支.
    4. --onto可以省略，但是加上去后意义会更加明确，因此建议保留.

<br>

- 举例说明：
  1. branch(b1): &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; **a** -> b(b1的起始) -> c -> d(b1)
  2. branch(b2): ···· -> 1 -> 2 -> **a** -> x -> y -> z(HEAD->b2)
  3. git rebase d
    1. 嫁接点是d，基点是a（d和HEAD的最近公共祖先）.
    2. 嫁接结果是：
      - ~~branch(b1):~~ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; **a** -> b -> c -> d(b1) **-> x -> y -> z(HEAD->b2)**
      - branch(b2): ···· -> 1 -> 2 -> **a** ~~-> x -> y -> z(HEAD)~~
      - 等价于：branch(b2): ···· -> 1 -> 2 -> **a** -> b -> c -> d **-> x -> y -> z(HEAD)**
  4. 之所以叫“变基”，是因为：
    1. 变基前，b2的基点是a.
    2. 变基后，b2的基点变成了嫁接点d了.

<br>

- 以上例分析git rebase的效果：
  1. (基点, HEAD]会被整个**嫁接到（挪动到）** 嫁接点上.
  2. 两分支融合后嫁接点所在分支**消失**，统一变成原HEAD节点所在的分支.
    - 但嫁接点分支并不是删除了，还是指向d，只不过两分支融合在一条线上了.
    - git branch还是可以看到b1存在的.
  3. 最直观的效果就是在git log中两分支融合了，没有各种连线了.
    - 但是嫁接点的那个分支（上例就是b1）**不要删除**，以便未来查看b1历史时可以快速访问定位.

<br><br>

### 三、底层实现：[·](#目录)

> git rebase --onto 嫁接点

1. 将(基点, HEAD]临时保存为一个副本区间.
2. git reset --hard 嫁接点
  - 以上例来讲，会把HEAD->b2移到嫁接点上（HEAD和HEAD指向的分支引用连带移动）：[op: \*\*HEAD = &嫁接点引用]
  - 这步就将两分支融合了.
3. 最后将(基点, HEAD]一个个**cherry-pick**到HEAD上完成整个变基操作：

```java
for node in [1.]中保存的区间副本"(基点, HEAD]" {
    git cherry-pick node
}
```

- 原嫁接点所在的分支并未删除，还指着嫁接点，不要删除，以便未来查看该分支的历史.

<br><br>

### 四、变基冲突与高效变基诀窍：[·](#目录)

- 变基的冲突其实就是git cherry-pick时的合并冲突（git merge冲突），因此解决冲突的方法仍然是git merge解决冲突的方法.
- 只不过变基过程中有**连续多次的cherry-pick**，因此有可能会发生连续冲突解决的情况，但git rebase提供了解决连续冲突的机智：
  1. 某次cherry-pick时发生无法自动合并的冲突就会终止git rebase.
  2. 接着，解决该次冲突的流程和cherry-pick一样：提示冲突文件 -> 工作区解决冲突 -> git add到stage中
  3. 但接下来并不需要你自己提交（git commit），而是**git rebase --continue**即可，表示自动完成接下来的变基工作.
    - 其实就是继续cheryy-pick下去.
  4. 如果又遇到了须要手动解决的冲突，那么重复[1. ~ 3.]的步骤，知道完成所有的cherry-pick为止.
  5. 如果在某次冲突解决过程中发现，该冲突可能无法自己一个人解决，须要找别人商量后才能解决，但那个人现在没空，因此必须先放下此次变基做其它工作.
    - 这是可以使用**git rebase --abort**命令**取消**此次变基.
    - 该命令会恢复到**整个变基操作之前的状态**.

<br>

- 高效变基的诀窍：
  - 变基的复杂度和cherry-pick的次数正相关.
    - cherry-pick次数多，那么冲突解决的次数可能就多.
    - 有时冲突解决是非常令人头疼的活儿.
  - 因此提高效率的做法就是：**将短链嫁接到长链上**，通常的做法是
    1. 将master变基到其它分支上（master上几乎没有提交，仅仅用来合并其它分支）.
    2. 但最好还是看情况，灵活变基，例如[1.]
      - 如果刚好master是长链，而b1是短链，但既希望减少冲突解决次数又想融合为master分支，则可以：
        1. git checkout b1           # 切到b1准备短链嫁接到长链
        2. git rebase --onto master  # 此时融合成了b1
        3. git checkout master       # 回到HEAD->master，此时master还指向原来的基点
        4. git reset --hard b1       # 最后让master指向融合后的最新节点b1处
