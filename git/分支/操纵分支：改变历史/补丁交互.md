# 补丁交互
> 开源社会化的顶梁柱：开源项目的追随者都是通过提交补丁给项目管理者的方式参与开源项目的发展.

### 一、从打补丁的基本含义来理解补丁的本质：

- 打补丁的基本含义：
  - 字面意思就是：对代码进行一次**修改/更新（打补丁）** 从而变成另一个**已存在的版本**.
    - 思考打补丁的核心关键词：**已存在的版本**，举例说明：
      1. 官网出了一个最新的版本，然后要如何让本地升级成**和官网一样的最新版本**呢？
      2. 从官网下载一个**从当前版本到最新版本**的补丁.
      3. 打补丁后成功升级成**和官网一样的**最新版本了.
- 总结得到补丁的**一般定义**：即**补丁的本质**
  1. 补丁是一条**有向边**，从**源点** 出发 **指向** **终点**.
  2. 这条有向边所包含的信息是具有指向性的，即源点要变成和终点一样需要作出的改变.
    - 相对的，也等于终点相对于源点的变化.
  3. 源点只要**应用**补丁（也就是打补丁），就可以变得**和终点一模一样**.
    - 打补丁就是**源点**按照**补丁的描述**作出改变.

<br><br>

### 二、补丁在git版本控制中的定义和实现：
> 定义：一个节点要变成**和另一个节点完全一样**所要作出的改变.

- 源点和终点：版本库中的任意两个节点.
- 补丁：源节点想要变得**跟终节点完全一样**所要作出的改变
  - 实质其实就是**终节点和源节点之间的git diff结果**.
- 打补丁的**实现过程**：
  - 官方：
    1. 官方做了从版本A到版本B的升级.
    2. 然后官方以A->B（或者说B相对于A）的git diff结果作为A升级到B的补丁：A2B.patch
      - .patch是文本文件，内容为A->B的git diff输出.
  - 用户：
    1. 用户此时还处于版本A（工作区、stage、HEAD都是A的内容）.
    2. 用户从官方下载到了A2B.patch
    3. 用户根据A2B.patch的描述对工作区作出修改，接着将修改加入stage，最后提交到，使得当前HEAD的内容跟官网最新版本内容一致.

<br>

- 版本发布的两种方式：**用户git pull** 或者 **发布补丁**
  - 用户git pull：
    1. 官方发布最新版本（官方提交了一个最新的节点）.
    2. 然后用户直接git pull到本地即可.
  - 发布补丁：
    1. 官方发布最新版本（官方提交了一个最新的节点）.
    2. 官方做一个上一节点到最新节点的补丁.
    3. 用户下载补丁，然后打补丁，升级到最新版本.
- 两种方式的主要区别：
  1. 补丁的传播更加自由和不受限制：
    1. git pull要求用户必须使用git客户端才行，并且git pull产生流量更大.
    2. 补丁则仅仅就是一个.patch文本文件，可以随意自由地传播（可以用任意下载工具下载，不依赖git客户端）.
  2. git pull跟新：
    - 如果没有发生合并的的git pull（快进式pull）那么本地更新的节点的提交ID和远程最新节点的提交ID相同.
    - 如果是补丁更新的话，其实是在本地生成了一个新的提交，因此新节点的提交ID和远程最新节点的提交ID不同.
      - 就是此节点（本地最新节点）非彼节点（远程最新节点），因为**提交ID不同**，但是**内容完全相同**.
        - 对于强迫症的宝宝完全可以在打完补丁后再git pull一下（发生合并）.
        - 只不过合并时由于补丁更新和远程新节点对上一个节点的更新内容完全相同而发生自然合并.
        - 合并后本地和远程的最新节点提交ID也就相同了.

<br><br>

### 三、GitHub开源社会化编程的补丁交互：

- 开源社会化编程的特点和主要形态：
  1. 金字塔模式：
    - 最顶层的是项目的发起者（可能就只有一两个发起者）.
    - 接下来是项目的审核者（审核者通常也有可能是发起者），审核追随者提交的补丁或者push request，决定是否更新最终的版本库.
    - 底层是众多的追随者，自己研究项目代码，共同讨论和开发，将自己对代码的更新做成补丁提交给上层人员审核提交.
  2. 主要特点：只有核心人员才有项目的push权限
    - 这是必然的，如果任意追随者都有push权限，那版本库岂不是乱套了吗？谁想push就push.
    - 因此，为了实现人人都可参与的社会化编程目标，不得不采用金字塔模式.
  3. 虽然push request和提交补丁都可以方便追随者参与项目的发展，但补丁提交更加广泛，主要原因还是**补丁传播更方便、更通用**.

<br>

- GitHub补丁交互模式：
  - 之前介绍的“官方-本地”案例只是为了说明**补丁的定义**以及**补丁的生成和使用**的**基本实现**，这里介绍GitHub开元社会化编程的**补丁应用模式**.
  - 简单一句话描述：追随者将**自己的修改/更新**做成补丁提交给项目审核人员**审核**，审核通过将补丁**应用到官方版本库**中正式生效.

<br><br>

### 四、生成补丁的命令：git format-patch

- 之前讲过git的补丁其实完全可以用两个节点的git diff输出来表示，但这样做的最明显的缺点是：
  1. 只包含文件的diff信息，不包含补丁的作者信息以及A->B的提交说明.
    - 这非常不利于社会化编程：
      1. 审核者首先不知道补丁作者是谁、该怎么跟作者联系和讨论.
      2. 补丁没有说明，不能一眼就看出该补丁所作出的贡献主要是什么，需要专门花时间研究补丁内容来确定补丁的目的.
  2. git并没有提供节点和节点之间的diff命令.
    - 只提供了工作区-stage、工作区-节点、stage-节点的diff命令.

<br>

- 为此，git专门提供了git format-patch命令来生成补丁：
  1. 首先它生成的是**节点**到**节点**的补丁（diff信息）.
  2. 其次，补丁的内容比普通的git diff更加丰富和完整，可以看一下：
    - 假设是节点a到节点b的补丁，其中：
      1. a的内容是u.txt(1到3行分别是1、2、3、a)，b的内容是u.txt(多了一个4行，内容是b)
      2. b的提交ID是9e682..
      3. b的提交说明就是"b"

```
From 9e682aeb4be174a054c42cd08552a4475388315d Mon Sep 17 00:00:00 2001    # 终节点的提交ID，即b的提交ID
From: double-cute <zilengshan_109@163.com>    # 补丁的作者信息（user.name user.email）
Date: Wed, 14 Dec 2016 14:27:07 +0800    # 补丁的生成时间
Subject: [PATCH 2/3] b           # 补丁的主题（就是终节点b的提交说明），其中[PATCH]表示这是一个补丁
                                 # [2/3]表示这是补丁系列（共有3个不定）中的第2个补丁
                 # 可以看出git补丁完全就是电子邮件的格式，因此可以直接作为邮件发送出去！上面是邮件的头部，后面都是邮件的内容体
---  # 补丁内容总览，改变了哪些文件，以及共有多少行改动
 u.txt | 1 +
 1 file changed, 1 insertion(+)

diff --git a/u.txt b/u.txt    # 标准的git diff输出（a->b的diff信息），补丁的核心内容
index 43dd4cf..38be47b 100644
--- a/u.txt
+++ b/u.txt
@@ -1,3 +1,4 @@
 1
 2
 a
+b
--  # diff信息的结束，签名的起始
signature: Peter Parker(The Spider Man)   # 作者签名
                                          # 虽然发件人已经指明了作者信息，但也有可能不够完整
                                           # 因为作者有可能临时使用其它邮箱或者临时的git客户端导致发件人信息不能
                                           # 精确地确定作者身份
                                          # 而签名可以唯一标识作者身份，一般采用一些国际通用的签名标准（如RFC 3676等）
```

<br>

- git format-patch的一个重要特性：只能按照**时序**生成**相邻两节点**间的补丁
  - 举例来说，现在有提交：A -> B -> C
    1. 时序：是指只能生成生成较前的提交到生成较晚的提交的补丁.
      - 这里只能生成A->B的补丁，不能生成B->A的补丁.
    2. 相邻两节点：意思很明白了，呵呵
      - 这里是指只能生成A->B、B->C不能直接生成A->C，因为跨越了一个节点.
      - 如果想要得到A->C的补丁，就必须生成两个，分别是A->B和B->C.
        - 应用的时候先打A->B的，再打B->C的.
- 为什么不能生成任意两节点直接的补丁呢？
  - 其实这是git项目管理的科学性表现：
    1. 时序：这是必然的，补丁强调的是源到终的变化，即旧到新的变化，如果可以突破时序那也必然打破了项目开发的时间顺序逻辑.
    2. 相邻：是为了记录源到终的整个变化过程，如果直接忽略中间过程就无法再未来查看中间变化的历史信息，这很重要.
      - 比如可以从中间变化过程看出原作者当时思路的变化和发展，非常有利于继续深入开发.
  - 正因为此，git设计者如此限制了该命令的使用.

<br>

- 命令的具体用法：
  - git format-patch其实是一个**补丁系列**生成命令.
    - 由于它的时序和相邻性约束，它只能生成起点到终点的一系列时序且连续的补丁链.
    - 比如，提交A -> B -> C -> D，该命令如果以A作为起点D作为终点则会按照时序生成一个补丁系列：
      - A->B.patch、B->C.patch、C->D.patch
      - 这里的B->C.path就是这个系列的第2个补丁，即[PATCH 2/3]的意思，3表示这个系列共有3个补丁.
  - 说明：
    1. left、right、start、node都是节点引用.
    2. [left:left+1]表示left到left+1的补丁.
      - +n表示相邻的后n个节点，-n表示相邻的前n个节点.

| 命令 | 说明 | 区间（**都是左开右闭的**）|
| --- | --- | --- |
| git format-patch **left right** | 生成[left:left+1]...[right-1:right]的系列补丁 | (left, right] |
| git format-patch **start** | 生成[start:start+1]...[HEAD-1:HEAD]的系列补丁 | (start, HEAD] |
| git format-patch **-数字n node** | 生成[node-n:node-n+1]...[node-1:node]的系列补丁 | (node~n, node] |

- 特殊的：git format-patch start命令中，如果start所在的分支和HEAD所在分支不同
  - 则会以start和HEAD的最近公共祖先节点作为新的start来执行该命令：
    1. 令new_start=start和HEAD的最近公共祖先节点.
    2. 生成[new_start:new_start+1]...[HEAD-1:HEAD]系列补丁，即(new_start, HEAD]区间

<br>

- git format-patch命令会自动生成补丁的文件名，规则是：
  - [补丁编号+终点的提交说明:用-分隔].patch
    - 补丁编号体现了系列补丁的时序关系，0001表示第一个补丁，然后依次往后+1
    - 例如：a("commit a") -> b("add a line") -> c("add u.txt") -> d("the end")，括号中的是提交说明
      - 那么git format-patch a d的输出结果就是：
        1. 0001-add-a-line.patch
        2. 0002-add-u.txt.patch
        3. 0003-the-end.patch
    - 即补丁系列按照区间从左到右编号从0001开始+1

<br>

- **额外** 选项：

| git format-patch的额外选项 | 说明 |
| --- | --- |
| -o 补丁的输出目录 | 将生成的补丁放到指定的目录中去 |
| --signature=签名 | 添加签名 |
| --signature-file=签名文件 | 将签名写在一个文本文件中，然后让该命令读取文件内容作为签名<br>用于签名比较长的情况 |

- 示例：git format -o dir_pat --signature="Peter Parker" -5 pat_branch

<br><br>

### 五、打补丁的命令：git am

- 一次只打一个补丁：git am xxx.patch
  - 将xxx.patch**应用**到**当前HEAD**.
  - 打补丁的过程无非就是前面讲过的打补丁的原理，该命令会自动完成以下步骤：
    1. 按照.patch的内容修改当前工作区.
      - 这就要求打补丁前必须是clean的（工作区、stage、HEAD保持一致）.
    2. 将修改加入stage.
    3. 提交stage到版本库，**提交说明跟补丁中的提交说明一样**.

<br>

- **打补丁失败：**
  - 如果打补丁失败则该命令会报错，并告诉你哪个文件打补丁失败.
  - 打补丁失败的原因只有一种：.patch中描述的打补丁前的文件内容和你当前HEAD中的文件内容不一致
    - 例如：

- 补丁内容是：

```
--- a/u.txt
+++ b/u.txt
@@ -1,3 +1,4 @@
 1
 2
 a
+b
```

- 也就是说该补丁要求打补丁之前u.txt的内容必须为：

```
1
2
a
```

- 但如果你现在HEAD中u.txt的内容为：

```
1
2
aa
```

- 那就和补丁描述的不一致了，这就导致了补丁的失败，必须自己手动将第3行改为a才能成功应用补丁.
- 也就是说补丁其实描述的是两个状态之间的变化，必须两个状态和补丁描述的完全一致才能引用该补丁.
- 可以使用**git apply --check xxx.patch**命令事先检测一下该补丁能否成功应用在当前HEAD上.

<br>

- 一次性打系列补丁：git am 一个系列的补丁列表
  - 例如：
    1. 不使用通配符：git am 0001-a.patch 0003-c.patch 0002-b.patch
    2. 使用通配符：git am patchdir/\*.patch








  ===========++++++++++++


1.可以在网上自由传播的cherry-pick——补丁：

  a.之前更新远程仓库往往需要先pull再push，但设想，如果是一个超庞大的项目，真正的权威版本库的push权限只可能掌握在少数项目发起者或者管理者的手里：
    i.这就意味着可能百分之99%的普通参与者无权向权威版本库进行推送，那这样的话不就失去了开源社会化编程的意义了吗？
    ii.对于这种项目，普通参与者如果想贡献代码往往需要将自己的修改先发送给管理者审阅，审阅通过后再交由管理者进行最后的推送，这种管理方式非常科学
*.可以有效提高代码质量，同时也不会让权威版本库因为太多人的提交变得杂乱无章
    iii.但是这种组织方式最大的问题是参与者的代码修改应该如何审阅？首先肯定不能讲参与者自己完整的版本库推送给管理者来审阅
    iv.首先这样做非常麻烦，流量大，并且并且直接推送版本库的做法并不能让审阅者快速精确定位到你修改的内容
    v.因此补丁交互就应运而生了！

  b.之前讲过的git cherry-pick其实就是补丁的前生：
    i.每一次提交其实都是对上一版本代码所作出的修改，那么这种修改就可以形象地理解为上一个版本的补丁了
    ii.每次cherry-pick应用一个已有的提交其实就是打一次补丁
    iii.那cherry-pick的局限在于分拣只能在本地进行，不能将已有的提交直接cherry-pick到远程（作为补丁打到远程分支上）
    iv.基于这个需求，git就提供了一个补丁功能，允许将本地已有的提交构造成补丁文件，并且这种补丁文件可以在网上随意传播
    v.补丁文件中有对代码修改的详细说明，并且可以附以补丁功能的说明，审阅者可以根据这些信息快速高效地审阅
    vi.最重要的是git还提供了打补丁的功能，可以像cherry-pick一样把一个补丁应用到当前版本库中

  c.总结：补丁的特点
    i.等价于一个cherry-pick提交
    ii.可以随意传播，传递方便
    iii.补丁内容可以快速定位代码修改，并且具有功能描述信息
    iv.是社会化编程的利器


2.创建补丁：git format-patch -s

  a.git format-patch -s <commit-left>..<commit-right>
    i.将按照时间顺序提交的连续的left到right的提交打成补丁
    ii.-s是将作者的姓名添加到补丁说明中，这虽然没什么，但这是作者唯一露脸的机会，如果你不是那么无私的话还是报上姓名比较好
    iii.left和right中间的连续两点..是git命令中表示范围的操作符，类似中文的~  

  b.命令会为每个提交创建一个补丁，每个补丁的命名风格：
    i.会显示序号0001、0002等，序号作为前缀
    ii.补丁名其实就是提交说明的字符串将空格换成-
    iii.例如：git commit -m "fix info bug"转换成补丁就是0001-fix-info-bug.patch
*.最前面的序号按照left-right从左到右递减

  c.补丁其实是一个文本文件（脚本文件），可以用文本编辑器打开查看，里面有对代码修改的描述，git提供命令直接运行脚本来打补丁

  d.应用补丁（打补丁）：git am
    i.补丁创建完之后可以通过任何介质传递：邮件、U盘等等的一切
    ii.应用补丁：git am 补丁名.patch.mbox列表
    iii.am其实是apply mbox的缩写，因为最初git补丁的初衷就是用邮件来传递，而在Linux中邮件附件的格式都是.mbox
    iv.因此应用补丁的命令其实是直接将邮件附件.mbox格式的补丁先转码成正常.patch然后再应用补丁
    v.但考虑到可能很多人没有在控制台操作邮箱的习惯，其实邮箱客户端可能更好用，因此需要一些特殊处理
    vi.特殊处理后应用补丁命令变成：cat 补丁名.patch列表 | git am
*.应用一下管道即可
*.git am可以一次打多个补丁，打补丁的顺序按照补丁序号从小到大依次进行
    vii.示例：cat *.patch | git am
    viii.打补丁的过程其实就是一个个“cherry-pick”


2.变基rebase的实质——补丁：

  a.之前讲过的git rebase，是把(left, right]临时保存，在后面变基中一个个cherry-pick的

  b.而其实用的是补丁，因为补丁更加高效，它吧(left, right]创建成临时补丁（即一个补丁列表），然后变基时一个个git am上去
*.最后补丁打完后再将那个临时补丁列表删除
