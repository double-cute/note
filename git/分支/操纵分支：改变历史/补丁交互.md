# 补丁交互
> 开源社会化的顶梁柱：开源项目的追随者都是通过提交补丁给项目管理者的方式参与开源项目的发展.

### 一、从打补丁的基本含义来理解补丁的本质：

- 打补丁的基本含义：
  - 字面意思就是：对代码进行一次**修改/更新（打补丁）** 从而变成另一个**已存在的版本**.
    - 思考打补丁的核心关键词：**已存在的版本**，举例说明：
      1. 官网出了一个最新的版本，然后要如何让本地升级成**和官网一样的最新版本**呢？
      2. 从官网下载一个**从当前版本到最新版本**的补丁.
      3. 打补丁后成功升级成**和官网一样的**最新版本了.
- 总结得到补丁的**一般定义**：即**补丁的本质**
  1. 补丁是一条**有向边**，从**源点** 出发 **指向** **终点**.
  2. 这条有向边所包含的信息是具有指向性的，即源点要变成和终点一样需要作出的改变.
    - 相对的，也等于终点相对于源点的变化.
  3. 源点只要**应用**补丁（也就是打补丁），就可以变得**和终点一模一样**.
    - 打补丁就是**源点**按照**补丁的描述**作出改变.

<br><br>

### 二、补丁在git版本控制中的定义和实现：
> 定义：一个节点要变成**和另一个节点完全一样**所要作出的改变.

- 源点和终点：版本库中的任意两个节点.
- 补丁：源节点想要变得**跟终节点完全一样**所要作出的改变
  - 实质其实就是**终节点和源节点之间的git diff结果**.
- 打补丁的实现过程：
  - 官方：
    1. 官方做了从版本A到版本B的升级.
    2. 然后官方以A->B（或者说B相对于A）的git diff结果作为A升级到B的补丁：A2B.patch
      - .patch是文本文件，内容为A->B的git diff输出.
  - 用户：
    1. 用户此时还处于版本A（工作区、stage、HEAD都是A的内容）.
    2. 用户从官方下载到了A2B.patch
    3. 用户根据A2B.patch的描述对工作区作出修改，接着将修改加入stage，最后提交到，使得当前HEAD的内容跟官网最新版本内容一致.

- 版本发布的两种方式：git pull和补丁
  - 一种是git pull最新代码(节点ID一样)，第二种是下载补丁，然后打补丁到最新代码（节点ID不一样）.


1.可以在网上自由传播的cherry-pick——补丁：

  a.之前更新远程仓库往往需要先pull再push，但设想，如果是一个超庞大的项目，真正的权威版本库的push权限只可能掌握在少数项目发起者或者管理者的手里：
    i.这就意味着可能百分之99%的普通参与者无权向权威版本库进行推送，那这样的话不就失去了开源社会化编程的意义了吗？
    ii.对于这种项目，普通参与者如果想贡献代码往往需要将自己的修改先发送给管理者审阅，审阅通过后再交由管理者进行最后的推送，这种管理方式非常科学
*.可以有效提高代码质量，同时也不会让权威版本库因为太多人的提交变得杂乱无章
    iii.但是这种组织方式最大的问题是参与者的代码修改应该如何审阅？首先肯定不能讲参与者自己完整的版本库推送给管理者来审阅
    iv.首先这样做非常麻烦，流量大，并且并且直接推送版本库的做法并不能让审阅者快速精确定位到你修改的内容
    v.因此补丁交互就应运而生了！

  b.之前讲过的git cherry-pick其实就是补丁的前生：
    i.每一次提交其实都是对上一版本代码所作出的修改，那么这种修改就可以形象地理解为上一个版本的补丁了
    ii.每次cherry-pick应用一个已有的提交其实就是打一次补丁
    iii.那cherry-pick的局限在于分拣只能在本地进行，不能将已有的提交直接cherry-pick到远程（作为补丁打到远程分支上）
    iv.基于这个需求，git就提供了一个补丁功能，允许将本地已有的提交构造成补丁文件，并且这种补丁文件可以在网上随意传播
    v.补丁文件中有对代码修改的详细说明，并且可以附以补丁功能的说明，审阅者可以根据这些信息快速高效地审阅
    vi.最重要的是git还提供了打补丁的功能，可以像cherry-pick一样把一个补丁应用到当前版本库中

  c.总结：补丁的特点
    i.等价于一个cherry-pick提交
    ii.可以随意传播，传递方便
    iii.补丁内容可以快速定位代码修改，并且具有功能描述信息
    iv.是社会化编程的利器


2.创建补丁：git format-patch -s

  a.git format-patch -s <commit-left>..<commit-right>
    i.将按照时间顺序提交的连续的left到right的提交打成补丁
    ii.-s是将作者的姓名添加到补丁说明中，这虽然没什么，但这是作者唯一露脸的机会，如果你不是那么无私的话还是报上姓名比较好
    iii.left和right中间的连续两点..是git命令中表示范围的操作符，类似中文的~  

  b.命令会为每个提交创建一个补丁，每个补丁的命名风格：
    i.会显示序号0001、0002等，序号作为前缀
    ii.补丁名其实就是提交说明的字符串将空格换成-
    iii.例如：git commit -m "fix info bug"转换成补丁就是0001-fix-info-bug.patch
*.最前面的序号按照left-right从左到右递减

  c.补丁其实是一个文本文件（脚本文件），可以用文本编辑器打开查看，里面有对代码修改的描述，git提供命令直接运行脚本来打补丁

  d.应用补丁（打补丁）：git am
    i.补丁创建完之后可以通过任何介质传递：邮件、U盘等等的一切
    ii.应用补丁：git am 补丁名.patch.mbox列表
    iii.am其实是apply mbox的缩写，因为最初git补丁的初衷就是用邮件来传递，而在Linux中邮件附件的格式都是.mbox
    iv.因此应用补丁的命令其实是直接将邮件附件.mbox格式的补丁先转码成正常.patch然后再应用补丁
    v.但考虑到可能很多人没有在控制台操作邮箱的习惯，其实邮箱客户端可能更好用，因此需要一些特殊处理
    vi.特殊处理后应用补丁命令变成：cat 补丁名.patch列表 | git am
*.应用一下管道即可
*.git am可以一次打多个补丁，打补丁的顺序按照补丁序号从小到大依次进行
    vii.示例：cat *.patch | git am
    viii.打补丁的过程其实就是一个个“cherry-pick”


2.变基rebase的实质——补丁：

  a.之前讲过的git rebase，是把(left, right]临时保存，在后面变基中一个个cherry-pick的

  b.而其实用的是补丁，因为补丁更加高效，它吧(left, right]创建成临时补丁（即一个补丁列表），然后变基时一个个git am上去
*.最后补丁打完后再将那个临时补丁列表删除
