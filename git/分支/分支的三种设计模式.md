# 分支的三种设计模式
> 即发布分支、特性分支、卖主分支三种.

<br><br>

## 目录

1. [发布分支](#一发布分支)
2. [特性分支](#二特性分支)
3. [卖主分支](#三卖主分支)

<br><br>

### 一、发布分支：[·](#目录)
> Release Branch，也称为Bugfix Branch（版本修复分支），**最最常见的一种分支设计模式**.

- 应用背景：发布分支一定是建立在一个稳定的发布版本上的
  - 比如，向用户交付了一个稳定的发布版本v1.0后接下来应该干什么呢？
    1. 首先，必须得马不停蹄地打造、设计、开发下一个版本v2.0（包含新的功能、新的特性）.
    2. 但v1.0在用户使用过程中难免会遇到一些bug需要修复.
      - 那接下来该怎么办呢？
        1. 是先放弃v2.0的开发来紧急修复v1.0的bug？
          - 显然不可行，不符合软件工程的理念，bug修复和v2.0的开发肯定是要并行的.
        2. 如果修复bug，那应该把修复bug的版本一并放到v2.0发布吗？
          - 显然也不行，从v1.0升级到v2.0必然是一个漫长浩大的过程，时间上用户必然是等不及的.
    3. 因此，就需要在v1.0这个节点上单独开辟一条bugfix分支，而主线分支则是继续开发v2.0的开发分支.
      - 在v1.0节点开始的bugfix分支上可以愉快进行bug修复了.
        - 修改一次版本就可以升级一次，比如v1.0.1 -> v1.0.5 -> v1.1.3（每次升级都代表一次bug修复）.
        - 而主线上还是继续v1.0 -> v2.0的开发工作.

<br>

- **注意：**
  1. bugfix分支上修复的bug并没有在主线的v1.0 -> v2.0的开发中修复！！
    - 两个分支都是基于v1.0的，从v1.0分出去后两个分支相互独立了.
  2. 因此，**bugfix上每升级出一个节点，都要git cherry-pick到v1.0 -> v2.0的主线分支上！**
    - 即，上面的bugfix中，每生出来一个新节点（v1.0.1、v1.0.5 ...）都要git cherry-pick到主分支上（v1.0 -> v2.0）.

<br><br>

### 二、特性分支：[·](#目录)
> Feature Branch，专门为了开发、尝试某一**新特性**而专门开辟一条分支，也是**最最常见的一种分支设计模式**.

- 最大的好处：撤销方便
  - 设想，如果这个新特性是实验性的、冒险性尝试的，那么单独为其开辟一条分支会非常方便撤销该新功能（删掉这个分支，或直接不管它放一边儿也行）.
- 不这样做的最大坏处：还是撤销方面的
  - 如果你在主分支上进行新功能的尝试性开发，例如：v1.0 -> v1.0+新功能尝试
    1. 而此时，你可能又在新功能尝试之后又开发了其它非尝试性的必要开发：v1.0 -> v1.0+新功能尝试 -> 又加了一个合同里需求的必要模块（功能）
    2. 现在突然不想要那个尝试性的功能了，要撤掉它，那么大麻烦就来了.
      - 因为新尝试的功能已经和刚刚开发的必要功能融合在一块儿了，撤销起来非常麻烦，需要一行行检查代码，让人绝望.
  - 如果采用了特性分支就非常方便了：
    1. 首先完全不影响主线开发（不会和主线开发融合在一起）.
    2. 想撤离可以随时撤离（放着特性分支不管就行了）.
    3. 如果这个尝试性新功能打算采用的话也非常方便，只要将特性分支的最新节点git cherry-pick到当前主分支的最新节点就行了.
      - 实际操作中往往是通过**git rebase**将特性分支融合到主分支上.
      - 因为**git rebase比git cherry-pick少一次和并提交**.
        - 而真实的生产环境中要求，**提交一次就审核一次**，少一次提交就少一次审核，提高工作流的效率.

<br><br>

### 三、卖主分支：[·](#目录)
> Vendor Branch，也称为上有分支，基于第三方框架的时候会采用的一种分支设计模式.

- 考虑到第三方框架往往也会进行升级（上游代码升级、打补丁（漏洞）），这就带来了框架升级和项目进度的合并问题.
- 卖主分支就是建立在项目起始点（还未开发一条代码），专门为框架代码开辟一条卖主分支（也称为**上游分支**）.
  - 框架的升级更新只在上游分支中进行.
  - 上游框架每更新一次就git cherry-pick到主分支上一次.
    - 这里就不能用git rebase了，因为上游分支要一直保持存在的状态专门用于框架的更新.
