# 远程标签
> 本地和远程共享标签的时候会有一些**特殊的限制**，目的是为了更好的协同开发.
>
>> 远程标签的操作同样也不会记录在git reflog中，因此操作的时候一定要慎重.

<br><br>

## 目录

1. [本地和远程共享标签过程中的混乱情况](#一本地和远程共享标签过程中的混乱情况)
2. [推送标签](#二推送标签)
3. [拉取标签](#三拉取标签)
4. [删除标签：更一般化的标签推送](#四删除标签更一般化的标签推送--)

| 命令 | 说明 |
| --- | --- |
| git push 远程仓库引用 本地标签列表 | 将本地标签推送到远程（冲突覆盖）|
| git push 远程仓库引用 **本地标签:远程标签** | 用任意本地标签覆盖任意远程标签 |
| git push 远成仓库引用 **:远程标签** | 删除指定的远程标签 |
| git pull | **顺带**拉取本地没有的新的远程标签 |
| git **pull** 远程仓库引用 **refs/tags/远程标签:refs/tags/本地标签** | 同步远程标签的更新 |

<br><br>

### 一、本地和远程共享标签过程中的混乱情况：[·](#目录)

1. 推送混乱：
  - 你想推送的标签和别人已经推送过的标签冲突.
    - 标签名相同，但是标签的说明和指向不同.
2. 拉取混乱：
  - 你拉取的标签和本地的标签冲突.
    - 标签名相同，但标签说明和指向不同，说明别人修改过远程标签了（或者你自己修改了本地的标签）.

<br>

- 解决混乱的方法：
  1. 最最有效的和根本的就是小组成员事先协商，订立规则和约定，并在推送前进行校验和审核.
  2. 被动的方法：在标签共享命令上加一些限制.

<br>

- 接下来就介绍受限的标签共享命令.

<br><br>

### 二、推送标签：[·](#目录)

- 单单的git push命令无法推送**本地创建**的标签，因为推送混乱的可能性存在.
  - 因此推送本地创建的标签必须使用**显式**的标签推送命令：**git push 远程仓库引用 本地标签列表**
    1. 就是将指定的本地标签推送至远程仓库，例如：git push origin v1.0 v2.0
      - 也可以将本地的所有标签都推送到远程仓库：git push origin **refs/tags/\***
    2. 该命令会覆盖远程标签：如果推送的标签在远程已存在（同名）则会覆盖（指向和标签对象）.
  - 可以看出该命令还是相当危险的，只不过限制是：
    - 想推送标签，必须显式单独推送标签，不能由节点推送自动连带推送标签.
    - 这样可以达到强迫你“三思而后行”的目的，即慎重考虑之后再决定是否执行，让本人承担行为的后果.

<br><br>

### 三、拉取标签：[·](#目录)

- 简单git pull对标签拉取是有效的：
  - 是指，**如果远程仓库中有本地-不存在-的-新-标签**，那么单单的git pull可以拉取这些标签.

<br>

- 但是git pull无法同步远程仓库中标签的更新：
  - 如果远程仓库中有本地存在的标签，但是后来远程仓库中的这个标签被其它人更新（修改）过了.
    - 此时你用单单的git pull无法将这种更新同步到本地，这是为了避免拉去混乱的可能性.
  - 如果经过你本人的三思后，认为这种更新是必须的，就可以使用**显式**的标签拉取命令拉取：
    - 命令：**git pull 远程仓库引用 refs/tags/远程标签:refs/tags/本地标签**
      1. 表示用指定的远程标签**覆盖**（指向和标签对象）指定的本地标签.
      2. :左边指代远程，右边指代本地，意思就是用远程覆盖本地.
    - 也是一种“三思后行”式的被动命令.

<br><br>

### 四、删除标签：更一般化的标签推送  [·](#目录)

- 一般化的标签推送命令：git push 远程仓库引用 **本地标签:远程标签**
  - 用任意本地标签覆盖任意远程标签
  - 如果本地标签为空，则表示用空来覆盖指定的远程标签，就是删除指定的远程标签的意思了.
    - 例如：git push origin :v1.0   # 删除远程仓库中的v1.0标签
