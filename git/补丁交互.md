# 补丁交互
> 开源社会化的顶梁柱：开源项目的追随者都是通过提交补丁给项目管理者的方式参与开源项目的发展.

<br><br>

## 目录

1. [从打补丁的基本含义来理解补丁的本质](#一从打补丁的基本含义来理解补丁的本质)
2. [补丁在git版本控制中的定义和实现](#二补丁在git版本控制中的定义和实现)
3. [GitHub开源社会化编程的补丁交互](#三github开源社会化编程的补丁交互)
4. [生成补丁的命令：git format-patch](#四生成补丁的命令git-format-patch--)
5. [打补丁的命令：git am](#五打补丁的命令git-am--)

| 命令：**生成补丁** | 说明 | 区间（**都是左开右闭的**）|
| --- | --- | --- |
| git format-patch **left right** | 生成[left:left+1]...[right-1:right]的系列补丁 | (left, right] |
| git format-patch **start** | 生成[start:start+1]...[HEAD-1:HEAD]的系列补丁<br>**如果start和HEAD处于不同分支则自动令start=start和HEAD的最近公共祖先节点** | (start, HEAD] |
| git format-patch **-数字n node** | 生成[node-n:node-n+1]...[node-1:node]的系列补丁 | (node~n, node] |

| **git format-patch的额外选项** | 说明 |
| --- | --- |
| -o 补丁的输出目录 | 将生成的补丁放到指定的目录中去 |
| --signature=签名 | 添加签名 |
| --signature-file=签名文件 | 将签名写在一个文本文件中，然后让该命令读取文件内容作为签名<br>用于签名比较长的情况 |

| 命令：**应用补丁到当前HEAD** | 说明 |
| --- | --- |
| git am 一个.patch | 一次只打一个 |
| git **apply** 一个.patch | 测试该补丁能否成功应用到当前HEAD上 |
| git am 一个.patch**系列**（可以使用通配符*）| 自动按照.patch从**小到大的顺序**依次应用到当前HEAD上 |
| 过程中遇到打补丁失败的情况下可以做 | 说明 |
| git am **--continue** | 修改文件然后继续往下打 |
| git am **--skip** | 跳过当前补丁继续往下打 |
| git am **--abort** | 撤销该系列的所有补丁回到原始状态（第一补丁应用之前的状态）|

<br><br>

### 一、从打补丁的基本含义来理解补丁的本质：[·](#目录)

- 打补丁的基本含义：
  - 字面意思就是：对代码进行一次**修改/更新（打补丁）** 从而变成另一个**已存在的版本**.
    - 思考打补丁的核心关键词：**已存在的版本**，举例说明：
      1. 官网出了一个最新的版本，然后要如何让本地升级成**和官网一样的最新版本**呢？
      2. 从官网下载一个**从当前版本到最新版本**的补丁.
      3. 打补丁后成功升级成**和官网一样的**最新版本了.
- 总结得到补丁的**一般定义**：即**补丁的本质**
  1. 补丁是一条**有向边**，从**源点** 出发 **指向** **终点**.
  2. 这条有向边所包含的信息是具有指向性的，即源点要变成和终点一样需要作出的改变.
    - 相对的，也等于终点相对于源点的变化.
  3. 源点只要**应用**补丁（也就是打补丁），就可以变得**和终点一模一样**.
    - 打补丁就是**源点**按照**补丁的描述**作出改变.

<br><br>

### 二、补丁在git版本控制中的定义和实现：[·](#目录)
> 定义：一个节点要变成**和另一个节点完全一样**所要作出的改变.

- 源点和终点：版本库中的任意两个节点.
- 补丁：源节点想要变得**跟终节点完全一样**所要作出的改变
  - 实质其实就是**终节点和源节点之间的git diff结果**.
- 打补丁的**实现过程**：
  - 官方：
    1. 官方做了从版本A到版本B的升级.
    2. 然后官方以A->B（或者说B相对于A）的git diff结果作为A升级到B的补丁：A2B.patch
      - .patch是文本文件，内容为A->B的git diff输出.
  - 用户：
    1. 用户此时还处于版本A（工作区、stage、HEAD都是A的内容）.
    2. 用户从官方下载到了A2B.patch
    3. 用户根据A2B.patch的描述对工作区作出修改，接着将修改加入stage，最后提交到，使得当前HEAD的内容跟官网最新版本内容一致.

<br>

- 版本发布的两种方式：**用户git pull** 或者 **发布补丁**
  - 用户git pull：
    1. 官方发布最新版本（官方提交了一个最新的节点）.
    2. 然后用户直接git pull到本地即可.
  - 发布补丁：
    1. 官方发布最新版本（官方提交了一个最新的节点）.
    2. 官方做一个上一节点到最新节点的补丁.
    3. 用户下载补丁，然后打补丁，升级到最新版本.
- 两种方式的主要区别：
  1. 补丁的传播更加自由和不受限制：
    1. git pull要求用户必须使用git客户端才行，并且git pull产生流量更大.
    2. 补丁则仅仅就是一个.patch文本文件，可以随意自由地传播（可以用任意下载工具下载，不依赖git客户端）.
  2. git pull跟新：
    - 如果没有发生合并的的git pull（快进式pull）那么本地更新的节点的提交ID和远程最新节点的提交ID相同.
    - 如果是补丁更新的话，其实是在本地生成了一个新的提交，因此新节点的提交ID和远程最新节点的提交ID不同.
      - 就是此节点（本地最新节点）非彼节点（远程最新节点），因为**提交ID不同**，但是**内容完全相同**.
        - 对于强迫症的宝宝完全可以在打完补丁后再git pull一下（发生合并）.
        - 只不过合并时由于补丁更新和远程新节点对上一个节点的更新内容完全相同而发生自然合并.
        - 合并后本地和远程的最新节点提交ID也就相同了.

<br><br>

### 三、GitHub开源社会化编程的补丁交互：[·](#目录)

- 开源社会化编程的特点和主要形态：
  1. 金字塔模式：
    - 最顶层的是项目的发起者（可能就只有一两个发起者）.
    - 接下来是项目的审核者（审核者通常也有可能是发起者），审核追随者提交的补丁或者push request，决定是否更新最终的版本库.
    - 底层是众多的追随者，自己研究项目代码，共同讨论和开发，将自己对代码的更新做成补丁提交给上层人员审核提交.
  2. 主要特点：只有核心人员才有项目的push权限
    - 这是必然的，如果任意追随者都有push权限，那版本库岂不是乱套了吗？谁想push就push.
    - 因此，为了实现人人都可参与的社会化编程目标，不得不采用金字塔模式.
  3. 虽然push request和提交补丁都可以方便追随者参与项目的发展，但补丁提交更加广泛，主要原因还是**补丁传播更方便、更通用**.

<br>

- GitHub补丁交互模式：
  - 之前介绍的“官方-本地”案例只是为了说明**补丁的定义**以及**补丁的生成和使用**的**基本实现**，这里介绍GitHub开元社会化编程的**补丁应用模式**.
  - 简单一句话描述：追随者将**自己的修改/更新**做成补丁提交给项目审核人员**审核**，审核通过将补丁**应用到官方版本库**中正式生效.

<br><br>

### 四、生成补丁的命令：git format-patch  [·](#目录)

- 之前讲过git的补丁其实完全可以用两个节点的git diff输出来表示，但这样做的最明显的缺点是：
  1. 只包含文件的diff信息，不包含补丁的作者信息以及A->B的提交说明.
    - 这非常不利于社会化编程：
      1. 审核者首先不知道补丁作者是谁、该怎么跟作者联系和讨论.
      2. 补丁没有说明，不能一眼就看出该补丁所作出的贡献主要是什么，需要专门花时间研究补丁内容来确定补丁的目的.
  2. git并没有提供节点和节点之间的diff命令.
    - 只提供了工作区-stage、工作区-节点、stage-节点的diff命令.

<br>

- 为此，git专门提供了git format-patch命令来生成补丁：
  1. 首先它生成的是**节点**到**节点**的补丁（diff信息）.
  2. 其次，补丁的内容比普通的git diff更加丰富和完整，可以看一下：
    - 假设是节点a到节点b的补丁，其中：
      1. a的内容是u.txt(1到3行分别是1、2、3、a)，b的内容是u.txt(多了一个4行，内容是b)
      2. b的提交ID是9e682..
      3. b的提交说明就是"b"

```
From 9e682aeb4be174a054c42cd08552a4475388315d Mon Sep 17 00:00:00 2001    # 终节点的提交ID，即b的提交ID
From: double-cute <zilengshan_109@163.com>    # 补丁的作者信息（user.name user.email）
Date: Wed, 14 Dec 2016 14:27:07 +0800    # 补丁的生成时间
Subject: [PATCH 2/3] b           # 补丁的主题（就是终节点b的提交说明），其中[PATCH]表示这是一个补丁
                                 # [2/3]表示这是补丁系列（共有3个不定）中的第2个补丁
                 # 可以看出git补丁完全就是电子邮件的格式，因此可以直接作为邮件发送出去！上面是邮件的头部，后面都是邮件的内容体
---  # 补丁内容总览，改变了哪些文件，以及共有多少行改动
 u.txt | 1 +
 1 file changed, 1 insertion(+)

diff --git a/u.txt b/u.txt    # 标准的git diff输出（a->b的diff信息），补丁的核心内容
index 43dd4cf..38be47b 100644
--- a/u.txt
+++ b/u.txt
@@ -1,3 +1,4 @@
 1
 2
 a
+b
--  # diff信息的结束，签名的起始
signature: Peter Parker(The Spider Man)   # 作者签名
                                          # 虽然发件人已经指明了作者信息，但也有可能不够完整
                                           # 因为作者有可能临时使用其它邮箱或者临时的git客户端导致发件人信息不能
                                           # 精确地确定作者身份
                                          # 而签名可以唯一标识作者身份，一般采用一些国际通用的签名标准（如RFC 3676等）
```

<br>

- git format-patch的一个重要特性：只能按照**时序**生成**相邻两节点**间的补丁
  - 举例来说，现在有提交：A -> B -> C
    1. 时序：是指只能生成生成较前的提交到生成较晚的提交的补丁.
      - 这里只能生成A->B的补丁，不能生成B->A的补丁.
    2. 相邻两节点：意思很明白了，呵呵
      - 这里是指只能生成A->B、B->C不能直接生成A->C，因为跨越了一个节点.
      - 如果想要得到A->C的补丁，就必须生成两个，分别是A->B和B->C.
        - 应用的时候先打A->B的，再打B->C的.
- 为什么不能生成任意两节点直接的补丁呢？
  - 其实这是git项目管理的科学性表现：
    1. 时序：这是必然的，补丁强调的是源到终的变化，即旧到新的变化，如果可以突破时序那也必然打破了项目开发的时间顺序逻辑.
    2. 相邻：是为了记录源到终的整个变化过程，如果直接忽略中间过程就无法再未来查看中间变化的历史信息，这很重要.
      - 比如可以从中间变化过程看出原作者当时思路的变化和发展，非常有利于继续深入开发.
  - 正因为此，git设计者如此限制了该命令的使用.

<br>

- 命令的具体用法：
  - git format-patch其实是一个**补丁系列**生成命令.
    - 由于它的时序和相邻性约束，它只能生成起点到终点的一系列时序且连续的补丁链.
    - 比如，提交A -> B -> C -> D，该命令如果以A作为起点D作为终点则会按照时序生成一个补丁系列：
      - A->B.patch、B->C.patch、C->D.patch
      - 这里的B->C.path就是这个系列的第2个补丁，即[PATCH 2/3]的意思，3表示这个系列共有3个补丁.
  - 说明：
    1. left、right、start、node都是节点引用.
    2. [left:left+1]表示left到left+1的补丁.
      - +n表示相邻的后n个节点，-n表示相邻的前n个节点.

| 命令 | 说明 | 区间（**都是左开右闭的**）|
| --- | --- | --- |
| git format-patch **left right** | 生成[left:left+1]...[right-1:right]的系列补丁 | (left, right] |
| git format-patch **start** | 生成[start:start+1]...[HEAD-1:HEAD]的系列补丁 | (start, HEAD] |
| git format-patch **-数字n node** | 生成[node-n:node-n+1]...[node-1:node]的系列补丁 | (node~n, node] |

- 特殊的：git format-patch start命令中，如果start所在的分支和HEAD所在分支不同
  - 则会以start和HEAD的最近公共祖先节点作为新的start来执行该命令：
    1. 令new_start=start和HEAD的最近公共祖先节点.
    2. 生成[new_start:new_start+1]...[HEAD-1:HEAD]系列补丁，即(new_start, HEAD]区间

<br>

- git format-patch命令会自动生成补丁的文件名，规则是：
  - [补丁编号+终点的提交说明:用-分隔].patch
    - 补丁编号体现了系列补丁的时序关系，0001表示第一个补丁，然后依次往后+1
    - 例如：a("commit a") -> b("add a line") -> c("add u.txt") -> d("the end")，括号中的是提交说明
      - 那么git format-patch a d的输出结果就是：
        1. 0001-add-a-line.patch
        2. 0002-add-u.txt.patch
        3. 0003-the-end.patch
    - 即补丁系列按照区间从左到右编号从0001开始+1

<br>

- **额外** 选项：

| git format-patch的额外选项 | 说明 |
| --- | --- |
| -o 补丁的输出目录 | 将生成的补丁放到指定的目录中去 |
| --signature=签名 | 添加签名 |
| --signature-file=签名文件 | 将签名写在一个文本文件中，然后让该命令读取文件内容作为签名<br>用于签名比较长的情况 |

- 示例：git format -o dir_pat --signature="Peter Parker" -5 pat_branch

<br><br>

### 五、打补丁的命令：git am  [·](#目录)

- 一次只打一个补丁：git am xxx.patch
  - 将xxx.patch**应用**到**当前HEAD**.
  - 打补丁的过程无非就是前面讲过的打补丁的原理，该命令会自动完成以下步骤：
    1. 按照.patch的内容修改当前工作区.
      - 这就要求打补丁前必须是clean的（工作区、stage、HEAD保持一致）.
    2. 将修改加入stage.
    3. 提交stage到版本库，**提交说明跟补丁中的提交说明一样**.

<br>

- **打补丁失败：**
  - 如果打补丁失败则该命令会报错，并告诉你哪个文件打补丁失败.
  - 打补丁失败的原因只有一种：.patch中描述的打补丁前的文件内容和你当前HEAD中的文件内容不一致
    - 例如：

- 补丁内容是：

```
--- a/u.txt
+++ b/u.txt
@@ -1,3 +1,4 @@
 1
 2
 a
+b
```

- 也就是说该补丁要求打补丁之前u.txt的内容必须为：

```
1
2
a
```

- 但如果你现在HEAD中u.txt的内容为：

```
1
2
aa
```

- 那就和补丁描述的不一致了，这就导致了补丁的失败，必须自己手动将第3行改为a才能成功应用补丁.
- 也就是说补丁其实描述的是两个状态之间的变化，必须两个状态和补丁描述的完全一致才能引用该补丁.
- 可以使用**git apply --check xxx.patch**命令事先检测一下该补丁能否成功应用在当前HEAD上.

<br>

- 一次性打系列补丁：git am 一个系列的补丁
  - 例如：
    1. 不使用通配符：git am 0001-a.patch 0003-c.patch 0002-b.patch
    2. 使用通配符：git am patchdir/\*.patch
  - 该命令会自动按照编号**从小到大的顺序**依次将补丁应用到当前HEAD.
  - 在该连续的打补丁过程中可能会遇到某个补丁应用失败的情况，此时你可以做如下三种选择：
    1. 自己动手修改然后接着继续往下打补丁：git am --continue
    2. 发现后悔了，这个系列不想再打了：git am --abort   # 直接还原到第一个补丁应用之前的原始状态
    3. 跳过该补丁继续从下一个往后打：git am --skip
