# Git
> 分布式版本控制系统.

<br><br>

## 导航

<br>

#### 一、配置：

| 内容 | 说明 |
| --- | --- |
| git **--version** | 查看当前git软件的版本号 |
| [git conifg](配置/git%20config.md#git-config) | **git自身**配置的**查看**和**修改** |
| [.gitignore](配置/.gitignore.md#gitignore) | 向git注册**不想被**版本控制（管理/跟踪）的**文件** |

<br>

#### 二、stage：

1. [工作区、stage、版本库](stage/工作区、stage、版本库.md#工作区stage版本库)：
2. [操纵stage](stage/操纵stage.md#操纵stage)
3. [保存当前工作进度：git stash](stage/保存当前工作进度：git%20stash.md#保存当前工作进度git-stash)

| 命令：**操纵stage** | 说明 |
| --- | --- |
| git add 文件列表 | 添加/覆盖到stage |
| git add -u | 只刷新工作区中stage记录过的文件到stage |
| git add -A | 将stage中记录过和没记录过的所有工作区文件刷到stage（不包括.gitignore中的）|
| git add -f 文件列表 | 强制添加到stage（不管.gitignore）|
| git rm 文件列表 | 直接删除stage中的文件，之后延展到工作区 |
| git mv src dest | 直接重命名stage中的src为dest，之后延展到工作区 |

| 命令：**保存进度** | 说明 |
| --- | --- |
| git stash | 保存进度 |
| git stash save comments | 保存进度同时附上说明 |
| git stash list | 查看进度栈 |
| git stash pop\|apply | 只还原工作区（删除/不删除进度栈中的相应进度）|
| 加 --index | 同时还原stage |
| 加 stage@{n} | 指定要还原的进度 |
| git stash drop | 删除栈顶进度 |
| git stash drop stash@{n} | 删除指定进度 |
| git stash clear | 清空进度栈 |

<br>

#### 三、时光穿梭（穿梭于版本库的历史节点间）：

1. [当前工作节点和当前工作分支（HEAD）](时光穿梭（穿梭于版本库的历史节点间）/当前工作节点和当前工作分支（HEAD）.md#当前工作节点和当前工作分支head)
2. [穿梭于历史：操纵HEAD](时光穿梭（穿梭于版本库的历史节点间）/穿梭于历史：操纵HEAD.md#穿梭于历史操纵head)
3. [悔棋](时光穿梭（穿梭于版本库的历史节点间）/悔棋.md#悔棋)
4. [提交：git commit](时光穿梭（穿梭于版本库的历史节点间）/提交：git%20commit.md#提交git-commit)

| 命令：**穿梭** | 说明 | 对应的HEAD操作 |
| --- | --- | --- |
| git checkout 分支名 | 切换分支（全覆盖，必须干净） | \*HEAD = &branch |
| git reset --soft\|mixed/空\|hard 节点引用 | 重设位置<br>（无/只覆盖stage/全覆盖，无提示） | \*\*HEAD = node_ref  或<br>\*HEAD =  node_ref（断头）|
| git checkout 分支名 | 强行断头重设位置 | 无条件执行\*HEAD = node_ref |

| 命令：**悔棋** | 说明 |
| --- | --- |
| git commit --amend -m new_comments | 单步修改提交说明 |
| git reset --soft HEAD^n<br>git commit -m new_combined_comments | 合并修改多步提交说明 |
| git reflog<br>git reset --hard HEAD@{n} | 回到n次提交之前 |
| git checkout origin_branch<br>[git reflog + git reset --hard HEAD@{n}] | 断头修复 |
| git **revert HEAD** | 反转提交：通过一次**额外**的提交来“撤销”当前提交回到HEAD^的状态<br>A->B(不理想，想撤销)->C(反转提交，使其内容和A完全一样，**仿佛**B不存在) |

| 命令：**提交** | 说明 |
| --- | --- |
| git commit -m comments | 正常提交（不允许空提交）|
| git commit **-a** -m comments | 一条龙提交工作区中被跟踪的文件 |
| git commit **--allow-empty** -m comments | 强制空提交 |

<br>

#### 四、[复原文件：撤销修改](复原文件：撤销修改.md#复原文件撤销修改)

| 命令 | 说明（.表示全部文件）|
| --- | --- |
| git checkout -- 文件列表\|. | stage复原到工作区 |
| git **reset [节点引用]** -- 文件列表\|. | 节点复原到stage（[节点引用]不写默认为HEAD）|
| git checkout **节点引用** -- 文件列表\|. | 节点**同时**复原到stage**和**工作区 |

<br>

#### 五、[版本库归档：git archive](版本库归档：git%20archive.md#版本库归档git-archive)

| 命令 | 说明 |
| --- | --- |
| git archive -o 输出的归档文件名 节点引用 [该节点中想归档的文件或目录列表] | 将指定节点的指定内容压缩成zip格式 |
| git archive **--format=tar** 节点引用 [该节点中想归档的文件或目录列表] **\| gzip > 输出的归档文件名** | tar格式压缩 |

<br>

#### 六、查看信息：

1. [查看变动：git diff](查看信息/查看变动：git%20diff.md#查看变动git-diff)
2. [查看状态：git status](查看信息/查看状态：git%20status.md#查看状态git-status)
3. [查看历史：git log](查看信息/查看历史：git%20log.md#查看历史git-log)

| 命令：**查看变动** | 说明 |
| --- | --- |
| git diff [目标文件列表] | 工作区相对于stage的变化：+工作区, -stage |
| git diff **节点引用** [目标文件列表] | 工作区相对于某个版本库节点的变化：+工作区, -节点 |
| git diff **--staged\|cached 节点引用** [目标文件列表] | stage相对于某个版本库节点的变化：+stage, -节点 |

| 命令：查看状态 | 说明（不加-s都是显示详细信息）|
| --- | --- |
| git status **-s** | 查看简化双状态 |
| **git checkout [HEAD]** | 查看简化单状态（只有stage相对于HEAD的变化）|
| git status **-b -s** | 查看当前处于哪个分支 |
| git status **--ignored -s** | 查看被忽略的文件 |

<br>

#### 七、分支：

1. [分支的三种设计模式](分支/分支的三种设计模式.md#分支的三种设计模式)
2. [分支的增删查：git branch](分支/分支的增删查：git%20branch.md#分支的增删查git-branch)
3. 操纵分支：改变历史
  1. [合并：git merge](分支/操纵分支：改变历史/合并：git%20merge.md#合并git-merge)
  2. [应用合并：git cherry-pick](分支/操纵分支：改变历史/应用合并：git%20cherry-pick.md#应用合并git-cherry-pick)
  3. [变基：git rebase](分支/操纵分支：改变历史/变基：git%20rebase.md#变基git-rebase)

| 命令：**分支的增删查** | 说明 |
| --- | --- |
| git branch | 罗列版本库中存在的分支（当前分支用*标示） |
| git branch **-r** | 罗列所有远程分支 |
| git branch new_branch [startpoint] | 在startpoint（默认为HEAD）建立一个新分支 |
| git **checkout -b** new_branch [startpoint] | 建立的同时切换到新分支上 |
| git branch -d\|D branch_name | 删除分支（-D强制删除）｜
| git branch -m\|M old_branch new_branch | 分支重命名（-M强制重命名）|

| 命令：**改变历史** | 说明 |
| --- | --- |
| git merge 节点引用 **-m 合并提交说明** | 将指定节点和HEAD合并**提交**到HEAD之后的一个位置 |
| git **cherry-pick** 节点引用 | 应用合并（等于git merge去掉连线），**合并提交说明等于被合并节点的提交说明** |
| git mergetool | 手动解决冲突的无脑工具 |
| git merge --no-commit 节点引用 | 制止git merge的自动提交（常用于逻辑冲突的解决）|
| git rebase [--onto] 嫁接点 | HEAD分支和嫁接点分支融合（嫁接到嫁接点上）成HEAD分支<br>被融合的分支还会保留（并没有删除） |
| git rebase **--continue** | 一次冲突解决后继续变基的cherry-pick过程 |
| git rebase **--abort** | 取消本次变基操作（**完全**复原到变基操作之前的状态）|

<br>

#### 八、版本标签：git tag：

1. [查看标签以及标签的命名规范]()
2. []()



<br>
