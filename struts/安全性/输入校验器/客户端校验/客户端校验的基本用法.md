# 客户端校验的基本规则
> - 客户端校验 = struts表单标签 + 校验规则文件

<br><br>

## 目录
1. []()

<br><br>

### 一、客户端校验的实现步骤：
1. struts表单标签（各种输入框，即输入标签）都实现了输入校验功能（js）.
  - 只不过**默认情况下不启用，需要编写校验规则文件来激活校验功能**.
2. 编写校验规则文件：
  - 在JSP页面中，表单标签 **属于** 一个表单，而一个表单则 **对应** 一个action.
  - 因此，校验规则文件应该以表单为单位编写，即一个表单就对应一个校验规则文件.
    - 但是，可能出现多个表单都对应同一个action，那么这样的表单往往内容是重复的.
    - 既然表单和action是多对一的关系，那还不如一个action对应一个校验规则文件.
  - 因此最终，**一个action对应一个校验规则文件**.
    - 但编写校验规则文件的时候是**把action当做一个表单看待**的（并不是对action的属性进行校验，而是**对action所对应的表单的各个输入框进行校验**）.
3. 校验规则文件的大致内容：
  - 无非就是对表单中的各个输入标签的输入进行校验.
  - **由于是客户端校验，struts提供了大量内置校验器**，直接在文件中调用这些内置校验器进行校验即可.
    - 这些内置校验器有必填校验、整数校验、正则表达式校验等，基本覆盖了客户端校验的所有功能.

<br><br>

### 二、校验规则文件：
> 内容就是对表单中的每一个输入框应用各种校验规则（struts提供的内置校验器）进行限制.
>> 因此内容应该诸如一条条：某某输入框  ->  规则1 + 规则2 + ...

- **重申：**
  1. 客户端校验的目标是表单中的输入框，因此校验文件应该和表单一一对应.
  2. 但表单又和action是多对一的关系，因此为了工程上的方便（舍弃了逻辑上的合理）就使校验文件和action一一对应了.
  3. 但是在编写校验规则文件时是把action当做表单看待的，因为内容是**"某某输入框  ->  规则1 + 规则2 + ..."**，而**不是"action的某个属性  ->  规则1 + 规则2 + ..."**
    - 归根结底，客户端校验毕竟是前台校验，是发生在页面中的，而不是进入action后才校验的，因此校验的对象都是页面中的输入框.

<br>

1. 开启struts表单标签的客户端校验功能：这里登录页面是regist.jsp，"input"视图也是regist.jsp，只不过校验失败会在新的regist.jsp中显示出错误提示.
  - 即**\<s:form action="XXX" validate="true"/\>** .
  - 其实不开启也行，即validate="false"也能启用客户端校验，但两者的区别何在呢？
    1. validate="true"会开启struts的“纯粹MVC”功能：即视图资源无法直接访问，只能通过核心控制器调度才能访问.
      - 在这种模式下，视图资源（jsp）必须都放在表现层目录WEB-INF/content/下，不能直接放在根目录中应用根目录中.
        - 因为在这种模式下**应用根目录的访问被强制关闭**.
      - 因此在URL中直接请求视图资源会返回异常：.../${appName}/regist.jsp   # 异常，试图直接访问应用根目录
        - 访问视图层必须使用前缀名：.../${appName}/**regist**  # 正确，默认到WEB-INF/content/下找名为regist的jsp页面
    2. 而validate="false"（默认也是关闭）那就关闭了“纯粹MVC”功能，视图资源只能直接放在应用根目录中，WEB-INF/content无法被识别.
      - 因此URL也只能直接请求应用根目录中的视图.
