# 继承映射
> Hibernate的这一特性使得数据库操作可以表现出多态行为.

<br><br>

## 目录
1.

<br><br>

### 一、继承映射的目的：
- 既然ORM能让数据库操作面向对象，那何不也让其表现出多态行为呢？
- 在程序层面，多态表现为PO之间的继承关系，而在数据库层面主要表现在**多态查询**.
  - 即查询一个父类PO表也可以得到所有子类PO表的结果.
- 要实现上述功能，就必须进行继承映射，将这种继承关系交代给Hibernate，让它将PO层面的继承映射到数据表之间.

<br><br>

### 二、继承映射的种类：
- 主要是根据数据表的存储方式来分的：
  1. 冗余式：父PO表和子PO表都保存在一张表里.
    - 例如：Person(name, age)  -->  Teacher(class)   -->   HeadMaster(group)
      - 那么映射完之后全部保存在Person表中，列为：name, age, class, group, discriminator
      - 其中discriminator为身份辨别列，它指明了本条记录属于哪个类，比如指定列"disc"为discriminator，其值"Per"代表Person，"Tea"代表Teacher，“Hdm”代表HeadMaster.
      - 即不管是父类记录还是子类记录都保存在顶级类的PO表中，只不过父类PO记录中那些子类独有的列只能为NULL，这就导致了空间的浪费（冗余）.
    - 缺点不仅是浪费空间，而且也不好扩展，哪天又多了一个子类，属性有增加了，那么父类表就只能被迫多加几个NULL列了.
  2. 分离式：子PO的父类部分保存在父表中，子类部分保存在子表中.
    - 也就是说将子类中父类部分和子类部分分离存放，即父表中的某些记录是子表中某些记录的一部分（父类部分）.
    - 这虽然能够解决冗余问题，但又引出了一个新的问题，那就是必须在父表或者子表中新增一列用来关联父表和子表.
      - 即用来表示某些父表记录是某些子表记录的一部分.
    - 虽然少了冗余，但多了连接关系需要维护，反过头来其实还是冗余了，并且当继承层次特别多、继承形式非常复杂的情况下这些多出来的关系真是剪不完理还乱.
  3.
