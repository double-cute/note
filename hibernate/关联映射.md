# 关联映射
> *使用外键关联是数据库减少数据冗余的一种常用手段.*<br>
> *Hibernate可以轻松地管理这种关联关系，手法就是关联映射.*

<br><br>

## 目录
1.

<br><br>

### 一、关联关系的种类：
- 具体的关联关系体现在数据表层面如：A表中的记录a1参考了B表中的记录b3，那么B就是a1的主表，如果A表中的另一个记录a2也参考了B表中的b3，那么就是N -> 1的关系，N端有多个记录参考到了1端的1个记录.


- 具体分类如下：
  1. 单向关联：只能由一端访问另一端.
    1. 1 -> 1
    2. 1 -> N
    3. N -> 1
    4. N -> N
  2. 双向关联：两端可以相互访问对方.
    1. 1 <-> 1
    2. 1 <-> N
    3. N <-> N
      - **没有N <-> 1**，因为和1 <-> N是对成的，但是在单向关联中就不是对称的.

<br><br>

### 二、关联是否需要连接表？（直接连接和间接连接）
- 上述的A(a1) -> B(b3)的案例就是直接连接，即A中的记录直接参考了B中的记录，中间没有任何中间表.
- 间接连接就是指A、B之间通过一张**连接表**来间接传递关联关系，即A(a1) --J(A的主键+B的主键)--> B(b3).
  - 连接表中的记录必然包含发生关联关系的两个表的主键（因为主键唯一代表表中的记录）.

<br><br>

### 三、Hibernate对关联关系的表达：端口和关联映射

1. 从数据库角度看，关联关系就是一个表的记录参照了另一个表的记录.
  - 那么从ORM角度看，关联关系就是一个PO参照了另一个PO（由于是不同表之间，因此也就是映射了两张不同的表的PO之间）.
  - 即，记录 - 记录  ==  PO - PO
2. 从端访问端的角度来看：
  - A端能访问B端就意味着必须在PO-A中开一个能访问PO-B的端口咯！
  - 具体的说就是PO-A中必须包含一个PO-B的引用作为数据域.
3. 还缺一个配置————关联映射：
  - 关联关系的实质是外键关联.
  - 但Hibernate并不能仅凭一个PO-A中包含PO-B的引用就可以自动在数据表之间添加外键，也许根本就不是关联关系仅仅就是组件包含关系呢？
  - 因此还需要在配置文件hbm中交代关联映射关系才能让Hibernate正确地配置添加外键.


- 总结：**关联关系 = 端口 + 关联映射**


**示例说明：后面演示的示例都是基于Person和Address的**

```java
package org.lirx.app.user;

import org.lirx.app.user.info.Address;

public class Person {
	private Integer id;
	private String name;
    private Integer age;

    public Integer getAge() {
    		return age;
    }
    public void setAge(Integer age) {
    	this.age = age;
    }
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}

}


package org.lirx.app.user.info;

public class Address {
	private Integer id;
	private String detail;

	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getDetail() {
		return detail;
	}
	public void setDetail(String detail) {
		this.detail = detail;
	}

}
```

<br><br>

### 四、N -> 1：
- 是**最最常见的关联关系**，例如多人住同一个地址，只需要从住户访问到对应的地址即可，通常没有通过地址找到住的所有人的需求.

**示例：N(Person) -> 1(Address)**

- **端口：** Person中

```java
private Address address;
getter、setter
```

- **关联映射：**
- 直接连接：Person表直接连接至Address表

```html
<!-- Address的映射不变 -->
<hibernate-mapping package="org.lirx.app.user.info">
    <class name="Address" table="address_inf">
        <id name="id" column="address_id">
            <generator class="identity"/>
        </id>
        <property name="detail" column="address_detail"/>
    </class>
</hibernate-mapping>

<!-- 由于是Person访问Address，因此需要在Person的映射中交代关联关系 -->
<hibernate-mapping package="org.lirx.app.user">
    <class name="Person" table="person_inf">
        <id name="id" column="person_id">
            <generator class="identity"/>
        </id>
        <property name="name" type="string"/>
        <property name="age" type="integer"/>

        <!-- 使用many-to-one来映射N -> 1关联 -->
            <!-- name指定了端口，即getAddress所代表的数据域 -->
        <!-- 会在person_inf表中添加一个名为column="address_id"的外键列 -->
            <!-- 它默认参考的是class="Address"所关联的表address_inf的主键列（也就是address_id) -->
                <!-- 不能写成class="info.Address"，会忽略package前缀，只能用全限定类名 -->
        <many-to-one name="address" class="org.lirx.app.user.info.Address" column="address_id" cascade="all"/>
            <!-- cascade表示级联，all表示主表、子表的操作会相互级联到对方 -->
                <!-- 具体来说，就是如果往person表中添加记录时发现address还没有在address表中出现过 -->
                    <!-- 这就意味着该记录在主表中没有记录可以参照，应该会报错 -->
                    <!-- 但是设定all级联后就会非常智能地在插入person记录前先插入一条相应的address记录 -->
                        <!-- 使之可以参照，然后再插入person记录 -->
    </class>
</hibernate-mapping>
```

- **应用：**

```java
public class Test
{
    public static void main(String[] args)
        throws Exception
    {
        Configuration conf = new Configuration().configure();
        SessionFactory sf = conf.buildSessionFactory();
        Session sess = sf.openSession();

        Transaction tx = sess.beginTransaction();

        	Person p = new Person();
        	p.setName("Peter");
        	p.setAge(15);
        		Address addr = new Address();
        			addr.setDetail("bridge of fish");
        	p.setAddress(addr);

        	sess.persist(p); // 由于cascade="all"，addr会自动级联持久化
        	// p以进入持久化态

        	Address addr_ = new Address();
        	addr_.setDetail("er jie");
        	p.setAddress(addr_); // 同样，addr_也会自动从瞬态被级联持久化

        tx.commit();

        sess.close();
        sf.close();
    }
}
```
