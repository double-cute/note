# 关联映射
> *使用外键关联是数据库减少数据冗余的一种常用手段.*<br>
> *Hibernate可以轻松地管理这种关联关系，手法就是关联映射.*

<br><br>

## 目录
1.

<br><br>

### 一、关联关系的种类：
- 具体的关联关系体现在数据表层面如：A表中的记录a1参考了B表中的记录b3，那么B就是a1的主表，如果A表中的另一个记录a2也参考了B表中的b3，那么就是N -> 1的关系，N端有多个记录参考到了1端的1个记录.


- 具体分类如下：
  1. 单向关联：只能由一端访问另一端.
    1. 1 -> 1
    2. 1 -> N
    3. N -> 1
    4. N -> N
  2. 双向关联：两端可以相互访问对方.
    1. 1 <-> 1
    2. 1 <-> N
    3. N <-> N
      - **没有N <-> 1**，因为和1 <-> N是对称的，但是在单向关联中就不是对称的.

<br><br>

### 二、关联是否需要连接表？（直接连接和间接连接）
- 上述的A(a1) -> B(b3)的案例就是直接连接，即A中的记录直接参考了B中的记录，中间没有任何中间表.
- 间接连接就是指A、B之间通过一张**连接表**来间接传递关联关系，即A(a1) --J(A的主键+B的主键)--> B(b3).
  - 连接表中的记录必然包含发生关联关系的两个表的主键（因为主键唯一代表表中的记录）.

<br><br>

### 三、Hibernate对关联关系的表达：端口和关联映射

1. 从数据库角度看，关联关系就是一个表的记录参照了另一个表的记录.
  - 那么从ORM角度看，关联关系就是一个PO参照了另一个PO（由于是不同表之间，因此也就是映射了两张不同的表的PO之间）.
  - 即，记录 - 记录  ==  PO - PO
2. 从端访问端的角度来看：
  - A端能访问B端就意味着必须在PO-A中开一个能访问PO-B的端口咯！
  - 具体的说就是PO-A中必须包含一个PO-B的引用作为数据域.
3. 还缺一个配置————关联映射：
  - 关联关系的实质是外键关联.
  - 但Hibernate并不能仅凭一个PO-A中包含PO-B的引用就可以自动在数据表之间添加外键，也许根本就不是关联关系仅仅就是组件包含关系呢？
  - 因此还需要在配置文件hbm中交代关联映射关系才能让Hibernate正确地配置添加外键.


- 总结：**关联关系 = 端口 + 关联映射**


**示例说明：后面演示的示例都是基于Person和Address的**

```java
package org.lirx.app.user;

import org.lirx.app.user.info.Address;

public class Person {
	private Integer id;
	private String name;
    private Integer age;

    public Integer getAge() {
    		return age;
    }
    public void setAge(Integer age) {
    	this.age = age;
    }
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}

}


package org.lirx.app.user.info;

public class Address {
	private Integer id;
	private String detail;

	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getDetail() {
		return detail;
	}
	public void setDetail(String detail) {
		this.detail = detail;
	}

}
```

<br><br>

### 四、N -> 1：
- 是**最最常见的关联关系**，例如多人住同一个地址，只需要从住户访问到对应的地址即可，通常没有通过地址找到住的所有人的需求.

**示例：N(Person) -> 1(Address)**

- **端口：** Person中

```java
private Address address;
getter、setter
```

- **关联映射：**

<br>

- **直接连接：** Person表直接连接至Address表

```html
<!-- Address的映射不变 -->
<hibernate-mapping package="org.lirx.app.user.info">
    <class name="Address" table="address_inf">
        <id name="id" column="address_id">
            <generator class="identity"/>
        </id>
        <property name="detail" column="address_detail"/>
    </class>
</hibernate-mapping>

<!-- 由于是Person访问Address，因此需要在Person的映射中交代关联关系 -->
<hibernate-mapping package="org.lirx.app.user">
    <class name="Person" table="person_inf">
        <id name="id" column="person_id">
            <generator class="identity"/>
        </id>
        <property name="name" type="string"/>
        <property name="age" type="integer"/>

        <!-- 使用many-to-one来映射N -> 1关联 -->
            <!-- name指定了端口，即getAddress所代表的数据域 -->
        <!-- 会在person_inf表中添加一个名为column="address_id"的外键列 -->
            <!-- 它默认参考的是class="Address"所关联的表address_inf的主键列（也就是address_id) -->
                <!-- 不能写成class="info.Address"，会忽略package前缀，只能用全限定类名 -->
        <many-to-one name="address" class="org.lirx.app.user.info.Address" column="address_id" cascade="all"/>
            <!-- cascade表示级联，all表示主表、子表的操作会相互级联到对方 -->
                <!-- 具体来说，就是如果往person表中添加记录时发现address还没有在address表中出现过 -->
                    <!-- 这就意味着该记录在主表中没有记录可以参照，应该会报错 -->
                    <!-- 但是设定all级联后就会非常智能地在插入person记录前先插入一条相应的address记录 -->
                        <!-- 使之可以参照，然后再插入person记录 -->
    </class>
</hibernate-mapping>
```

- 关于级联操作：涉及到关联关系时（外键关联），Hibernate在插入一个从表记录之前**必须要先确定参考的主表记录存在**（即先插入主表记录），因此要么**自己先手动插入主表记录**，要么**设置级联**，否则会抛出异常！

<br>

- **应用：**

```java
public class Test
{
    public static void main(String[] args)
        throws Exception
    {
        Configuration conf = new Configuration().configure();
        SessionFactory sf = conf.buildSessionFactory();
        Session sess = sf.openSession();

        Transaction tx = sess.beginTransaction();

        	Person p = new Person();
        	p.setName("Peter");
        	p.setAge(15);
        		Address addr = new Address();
        			addr.setDetail("bridge of fish");
        	p.setAddress(addr);

        	sess.persist(p); // 由于cascade="all"，addr会自动级联持久化
        	// p以进入持久化态

        	Address addr_ = new Address();
        	addr_.setDetail("er jie");
        	p.setAddress(addr_); // 同样，addr_也会自动从瞬态被级联持久化

        tx.commit();

        sess.close();
        sf.close();
    }
}
```

<br>

- **间接连接：** 使用连接表

<br>

```html
...
<property .../>
<property name="name" type="string"/>
<property name="age" type="integer"/>
<!-- 使用join标签强制指定连接表 -->
    <!-- 连接表名由table属性指定 -->
<join table="person_address_join_inf">
    <!-- 用key标签将从表主键person_id映射到连接表的column="pid"列 -->
    <key column="pid"/>
    <!-- 还是使用many-to-one标签将主表class="Address"的主键address_id映射到连接表的column="aid"列 -->
        <!-- 映射键的同时也映射了关联关系 -->
    <many-to-one name="address" class="org.lirx.app.user.info.Address" column="aid" cascade="all"/>
</join>
```

- **连接表中的两张关联表的主键将作为连接表的联合主键.**

<br><br>

### 五、1 -> 1：
- 先考虑N -> 1关系，如果采用间接关联其表形如：

| 从表主键 | 主表主键 |
| :---: | :---: |
| 1 | 5 |
| 2 | 5 |
| 3 | 2 |
| 4 | 5 |

- 即从表中多个记录映射到主表中一个相同的记录.
- 而1 -> 1就是N -> 1的基础上加了一个限定，就是从表中的记录只能映射到主表不同的记录中.
  - 也就是上面的"主表主键"这一列不能有重复值.
- 因此1 -> 1映射就变的非常简单了：
  - 不管是直接连接还是间接连接，都 **`在\<many-to-one\>标签中加一个unique="true"`** 即可！

<br>

**1 -> 1的特殊情况：从表的主键参考了主表的主键**
<br>

- 就是说本表（从表）的主键，同时也是外键，它参考了其它表（主表）的主键（主键关系必然是传递的）.
- 既然都是主键，那必然是一一对应的，如果是单向访问的话那必然是1 -> 1的.
- 这种情况下的关联映射应该这样写：

```html
<class name="Person" table="person_inf">
    <id name="id" column="person_id">
    <!-- 主键1 -> 1的从表主键参考主表的主键，因此其生成策略应该是“参考主表” -->
        <!-- 因此指定为foreign，即参考其它表 -->
        <generator class="foreign">
            <!-- 具体参考哪张表由端口决定 -->
            <param name="property">address</param>
        </generator>
    <!-- 注意！这里仅仅是指定了主键生成策略为“参考主表”，但并没有映射关联关系，关联关系还需要单独映射 -->
    </id>
    <property name="name" type="string"/>
    <property name="age" type="integer"/>
<!-- 最后别忘了映射映射关联关系，主键关联需要使用one-to-one标签，其参数用来指定端口 -->
    <one-to-one name="address"/>
</class>
```
