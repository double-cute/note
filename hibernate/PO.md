# PO（持久化对象）

<br><br>

## 目录

<br><br>

### 一、PO规范：
1. 必须提供一个无参构造器，并且所有构造器的访问控制符要**大于等于包访问权限**.
  - 这是为了Hibernate在运行时生成代理.
2. 不要将PO定义成final类：同样是为了生成代理，代理时需要自举生成PO的子类，final后则无法做出这一动作.
  - **代理** 是Hibernate**非常重要**的功能，尽量不要和该该功能背道而驰.
2. 最好提供一个标识属性：
  - 就是专门提供一个数据域来映射数据表的主键，那么该数据域就是PO的标识属性.
  - Hibernate不推荐数据表中提供具有实际意义（物理意义）的主键
    - 比如用Student ID作为主键的话，Student ID是有实际意义的，即学生ID.
    - 而是推荐使用不具有任何实际意义的逻辑主键，比如就用一个自增长的int来作为主键，或者是一个SHA1编码作为主键，只要能唯一表示该记录即可.
    - 那既然Student ID已经可以唯一表示一条记录了，为什么还要再多弄一个“逻辑主键”呢？这不是数据冗余吗？
      - 其实不然，如果使用多列作为联合主键，则需要再从表中增加多个列，这比只增加一个“逻辑主键”冗余度大得很多很多！这样看来，“逻辑主键”并不是那么冗余了！
  - 因此，该标识属性代表的只是逻辑主键，无需是一个有意义的名称，名称一般可以随意取.
  - 该属性的类型可以是任何Java基本类型、基本类型的包装器类型、String、Date等Java基本Util类型.
    - **由于基本类型使用不便，还是推荐使用包装器类型.**
3. 为所有属性提供getter、setter、is（即boolean isFoo();，但通常情况下is根据需要决定开不开发）.
4. 实现equals、hashCode：
  - 考虑到有时候会将PO放入Set中.
  - 有时候需要知道两个PO是否对应数据表中的同一条记录.
  - 有时可能会重用托管的PO.
  - **重新强调equals、hashCode、comparable、comparator的作用**:
    1. 前三个应该同生死，即逻辑结果应该保持一致.
    2. equals、hashCode共同决定元素在Java容器中的位置.
    3. comparable用于自然排序，就是元素在大自然中的天然的从小到大的顺序，比如整数中1就是比2小.
    4. comparator用于业务逻辑排序，比如有时候业务要求需要按照ID从大到小排序，有时候需要按照名称从大到小排序，而如果名称相同再按照ID排序等.

<br><br>

### 二、PO的状态：
1. 瞬态：刚new出来并没有与任何Session关联.
  - 对瞬态对象的任何操作都不会持久化到数据库.
2. 持久化态：
  - 和Session关联了，这就意味着已经被Hibernate追踪.
  - 并且对应到数据表中的某行数据（某条记录）.
  - **最重要的就是拥有了一个持久化标识（identifier）.**
3. 托管：
  - 刚刚关联的又和Session断开了（关闭了Session）.
  - 托管状态下也同样会被Hibernate追踪，期间对PO的操作虽然不会被写入数据库但是会被记录到Hibernate缓存中.
  - 如果重新连接Session，则又可以从脱管状态回到持久化状态，这个时候提交脱管状态下的操作写入数据库.
