### 一、三次握手：

- 用于TCP连接的建立：假设通信双方分别为A和B.

1. 首先，A请求B建立连接：这是第一次握手，过程是
   1. A向B发送SYN报文，假设A此时的发送序号为x.
   2. 报文中SYN置1，表示向B请求建立连接.
2. 接着，B确认并回复A的请求：这是第二次握手，过程是
   1. B收到报文后向A回复SYN+ACK报文，假设B此时的发送序号为y.
   2. 报文中：
      1. SYN置1，表示同意A的连接请求.
      2. 同时呢ACK位置1，确认序号为x+1，表示序号在x+1之前的报文都已经被接受并确认.
3. 最后，A确认并回复B回发的报文：这是第三次握手，过程是：
   1. A收到报文后向B回复ACK报文，此时发送序列号承接之前的SYN报文，因此为x+1.
   2. SYN置0，ACK置1，确认序号为y+1，表示确认序号在y+1之前的所有报文.
4. 之后，建立通路，传送数据.

- 为什么要3次握手而不是2次呢？

1. 这是考虑到一种特殊情况.
2. A第一次发送的SYN报文有可能因为网络拥塞而卡在某个节点上.
3. 此时A由于等不到B的确认而重发SYN报文，而第二次发的这个SYN报文可能非常幸运地顺利到达B.
4. 如果是2次握手的话，那么此时就B就已经建立通路并传输数据了.
5. 如果刚好在这个过程中，第一次发送的SYN报文因为网络的恢复传到了B，那B就又建立了一个通路并等待A发送的数据.
6. 而此时A正在和B传输数据，是不会理会它的.
7. 那么第二次建立的重复的通路就要一直等待A传完，造成资源的浪费.
   - 这在网络拥塞的情况下有非常高的几率发生，简直雪上加霜.
8. 因此只能通过多加一次握手来解决这个问题了.

### 二、四次挥手：

- 用于TCP连接的断开：

1. 首先，A请求断开连接：这是第一次挥手，过程是
   1. A向B发送FIN报文（FIN置1）.
2. 接着，B确认并回复A的请求：这是第二次挥手，过程是
   1. B收到报文后向A回复ACK报文（ACK置1）.
3. 第三次和第四次挥手是反向的，B向A发送FIN报文，然后A确认回复ACK报文.

- 为什么是4次：

1. 因为TCP是全双工的，断开必须是两个方向上的断开.
2. B回复A的ACK报文是为了断开A到B的连接，A回复B的ACK报文是为了断开B到A的连接.
3. 肉眼看上去第3次握手似乎是多余的，但是必须要考虑到断开连接的真正条件是什么.
   - 断开连接的真正条件必须是已经没有数据要发送了才能断开连接.
   - 发送FIN报文的目的就是告诉对方，我这里已经没有数据要发送了，所以发个FIN断开连接吧.
4. 当B第一次收到A的FIN报文时只是知道A没东西要发了，但并不代表B就已经发完数据了.
   - 此时B可能还有没法送完的数据.
   - 只有当B发送FIN时才能让A知道B已经没东西发了，可以真正的断开B到A的连接了.
5. 因此中间多了一个B到A的FIN报文.
6. 其实双方发送的FIN报文里都是将ACK置1的，表示已经收到了对方的最后一个数据包了.
