# 数据标签
> 主要用于提供各种数据访问的相关功能

<br><br>

## 目录

1. [action](#一action)
2. [bean](#二bean)
3. [date](#三date)
4. [set](#四set)
5. [push](#五push)

<br><br>

### 一、action：[·](#目录)
- 直接在JSP页面中调用指定的Action进行服务，即显式手动调用Action.

- 属性：
  - name：**必选**，要调用的Action的名字.
  - namespace：可选，即Action的命名空间.
  - ignoreContextParams：可选，[true/false]，当前JSP页面的请求参数是否要传入该Action中，默认为false，即传入
  - executeResult：可选，[true/false]，是否直接将该Action的结果物理视图包含到当前位置（即<s:include>的效果），默认是false，即不包含.
  - var：可选，为该Action对象命名并放入**`Stack Context（以及requestScope）`** 中，否则就仅仅是一个临时对象.

示例：
```js
<s:action name="login" namespace="/user"
    ignoreContextParams="true" executeResult="true"
    var="aLoginActionObj"/>
```
- 调用/user/login.action，不把当前页面的请求参数传入，并将该Action的返回结果页面显示在当前位置，并为该Action对象起名为'aLoginActionObj'，放入Stack Context以及requestScope中.

<br><br>

### 二、bean：[·](#目录)
- 直接在JSP页面中创建一个JavaBean供接下来的代码使用.

用法示例：
```js
<!-- 只需要指定Bean对应的Java类即可 -->
<s:bean name="org.lirx.app.user.Person" var="p">
    <!-- 通过setName()和setAge()为Bean的数据域赋值 -->
    <s:param name="name" value="Peter"/>
    <s:param name="age" value="20"/>

    <!-- bean标签内访问的对象临时保存在ValueStack中，无需#前缀 -->
    name为<s:property value="name"/><br/>
    age为<s:property value="age:"/><br/>
</s:bean>

<!-- 在bean标签外访问 -->
<!-- var将Bean保存在Stack Context/requestScope中，需要通过#前缀访问 -->
name为<s:property value="#p.name"/><br/>
age为<s:property value="#p.age:"/><br/>
${requestScope.p}
```

<br><br>

### 三、date：[·](#目录)
1. 可以格式化输出日期时间.
2. 也可以计算各种日期时间差.
> 其操作的日期可以是Java类库中的各种日期对象，比如java.util.Date


- 属性：
  1. name：**必选**，用OGNL指定待格式化的日期时间（应该是一个JavaBean）.
  2. format：可选，决定了格式化方式，分别用dd、MM、yyyy表示日、月、年.
    - 例如：format="yyyy/MM/dd"，年月日的顺序比较符合中国人的习惯.
    - 只有dd、MM、yyyy是关键字，其余可以任取，例如：format="yyyy年MM月dd日"也行.
  3. nice：可选，[true/false]，是否输出name所代表的日期和当前时刻的时差，true输出，默认值是false.
    - format和nice**不同时指定**，nice只用来输出与当前时差，format只用来格式化输出指定日期.
    - 如果同时指定（nice="true" format也有值）那么**format将失效**.
  4. var：Stack Context & requestScope.
    - **指定var之后就不会输出了，要输出只能在标签外通过#var输出.**


- **格式化输出的值以及时间差值都是一个临时产生的值，不影响原来的值，如果要延该临时值寿命就使用var.**

示例：
```js
<s:bean var="now" name="java.util.Date"/>
<s:date name="#now" format="dd哈MM哈yyyy"/><br>
<s:date name="#now" nice="true"/><br>
```

<br><br>

### 四、set：[·](#目录)
- 用来定义一个变量，并指定它存储在什么位置（scope）.
- 变量的值可以用OGNL获取.

用法示例：
```js
<!-- 假设p是一个JavaBean -->
<s:set name="varName" value="#p.age" scope="request"/>
```
> 含义就是varName=value，varName就是该变量的名称，之后引用它是需要用到.

- scope的合法值有application、session、request、page和action这5个.
  - 其中action等于Stack Context + request.
- 上面访问该变量就是：
```js
<s:property value="#application.varName"/>
```

### 五、push：[·](#目录)
- 将一个值临时压入ValueStack栈顶.
- **`不能`** 对该值命名，**只能** 在push标签内访问，出了标签就会被弹栈.
- 就只有一个value属性，即待压入的值.

示例：
```js
<!-- push和set最大区别就是没有name属性 -->
<s:push value="'lala'">
    <s:property/> <!-- s:property没有value属性表示直接取ValueStack栈顶元素 -->
</s:push>

<!-- 假设#p是JavaBean，Person对象，包含name和age数据域 -->
<s:push value="#p">
    <s:property value="name"/>
    <s:property value="age"/>
</s:push>
```

- 可以看到push标签连name属性都没有，因此其最大的作用就是超级快速、方便地临时处理一个数据.
- 如果一个值就在局部需要大量频繁地用到，并且用OGNL取值特别麻烦（比如名称特别长、繁琐，例如#p.a.b.c.d.e.f）就是和压栈处理了.
