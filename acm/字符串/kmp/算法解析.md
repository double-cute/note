

t: abcababcad  n = 10
w: abcad       m = 5

暴力bm：即模式串一位一位移动

||||||||||||
|--|--|--|--|--|--|--|--|--|--|--|
|text|a|b|c|a|~~b~~|a|b|c|a|d|
|word|a|b|c|a|~~d~~|||||||

||||||||||||
|--|--|--|--|--|--|--|--|--|--|--|
|text|a|~~b~~|c|a|b|a|b|c|a|d|
|word| |~~a~~|b|c|a|d||||||

···

||||||||||||
|--|--|--|--|--|--|--|--|--|--|--|
|text|a|b|c|a|b|a|b|c|a|d|
|word| |||||a|b|c|a|d|

- 缺点：
  - 必须一位一位移动模式串.
  - 每移动一位就需要匹配一次.
  - 因此匹配次数非常多.
  - 因此算法复杂度高.
    - (n - m) × m ≈ O(n × m)


### 如何降低复杂度呢？
> 最直接的思路就是**降低匹配次数**，也就是**增加移动距离**
>
>   - 不要一位一位移动模式串，而是一次移动多位的**长距离移动**.

- 首先意淫一下最理想的移动方式：那毫无疑问，就是跟神一样的一次性直接移动到完全匹配的位置

||||||||||||
|--|--|--|--|--|--|--|--|--|--|--|
|text|a|b|c|a|~~b~~|a|b|c|a|d|
|word|a|b|c|a|~~d~~|||||||

||||||||||||
|--|--|--|--|--|--|--|--|--|--|--|
|text|a|b|c|a|b|a|b|c|a|d|
|word|1|2|3|4|**5**|a|b|c|a|d|

- 在第一次匹配失败后直接跟神一样预知未来，直接移动5位匹配成功.
  - 但这样的能力显然是不存在的，因此我们需要进一步探索长距离移动的必要条件.


- 先尝试无原则的加大移动距离：从主串上匹配错误的那一位开始重新匹配

||||||||||||
|--|--|--|--|--|--|--|--|--|--|--|
|text|a|b|c|a|~~b~~|a|b|c|a|d|
|word|a|b|c|a|~~d~~|||||||

失败后直接从主串上匹配错误的b开始重新匹配模式串（直接移动了4位）

||||||||||||
|--|--|--|--|--|--|--|--|--|--|--|
|text|a|b|c|a|~~b~~|a|b|c|a|d|
|word|1|2|3|4|~~a~~|b|c|a|d|

为什么这就是最大距离？
  - 因为匹配失败后直接终止一轮匹配了.
  - 也就是说主串上b后面的字符还未扫描过，也就是说后面的情况还未知.
  - 所以最远也只能把模式串移动到b的位置开始新一轮扫描了.

- 但无原则加大移动距离有什么问题呢？
  - 假如主串是：abcabcadwk
  - 那么按照最大移动距离原则，匹配过程变成了

||||||||||||
|--|--|--|--|--|--|--|--|--|--|--|
|text|a|b|c|a|~~b~~|c|a|d|w|k|
|word|a|b|c|a|~~d~~|||||||

||||||||||||
|--|--|--|--|--|--|--|--|--|--|--|
|text|a|b|c|a|b|~~c~~|a|d|w|k|
|word||||||~~a~~|b|c|a|d|

而错过了正确的匹配结果

||||||||||||
|--|--|--|--|--|--|--|--|--|--|--|
|text|a|b|c|a|b|c|a|d|w|k|
|word||||a|b|c|a|d||||

- 犯错的原因就是**遗漏了之前已匹配内容的信息**
  - 即忽略了还可以从之前已匹配的abcab的最后两个ab开始重新匹配的事实.

- 因此，最后总结出移动模式串的原则就是：
  1. 不遗漏之前已匹配内容的信息.
  2. 移动的距离要最大.
- 只要同时满足这两个条件就能使算法**正确**且**最优**.


- 解决方法很简单：
  - 就是在主串里已匹配出的模式串子串中，找出**最长的**、**相同的** 前缀和后缀，使之重叠.
  - 找相同的前后缀很好理解，就是为了不遗漏已匹配的信息，但为什么要找最长的呢？看例子：

|||||||||||||||
|--|--|--|--|--|--|--|--|--|--|--|--|
|text|a|a|a|b|c|a|a|~~a~~|b|c|a|d|f|
|word|a|a|a|b|c|a|a|~~d~~|||||||

其中主串中已匹配到的模式串子串aaabcaa中前后缀相同的子串有a和aa，其中aa最长.
  - 如果我们只让a重叠而不是aa重叠同样会因为遗漏了一个a的信息而导致结果错误.

重叠的不是最长，移动了6位

|||||||||||||||
|--|--|--|--|--|--|--|--|--|--|--|--|
|text|a|a|a|b|c|a|a|a|~~b~~|c|a|d|f|
|word|1|2|3|4|5|**6**|a|a|~~a~~|b|c|a|d||

而正确的结果就是因为这短短的一个a被错过了，重叠最长情况下只移动了5位，比不是最长的会少.

|||||||||||||||
|--|--|--|--|--|--|--|--|--|--|--|--|
|text|a|a|a|b|c|a|a|a|b|c|a|d|f|
|word|1|2|3|4|**5**|a|a|a|b|c|a|d|||

- 总结：如果重叠的不是最长的相同前后缀，那么可能会存在因为移动距离过长而遗漏信息导致结果错误.


- kmp算法总结：
  1. 从头开始匹配.
  2. 如果发生匹配错误，那么寻找已匹配的模式串子串中的最长相同前后缀并使之重合，然后继续匹配.
  3. 重复2.的过程直至主串全部匹配完.

- 也就是说整个算法的核心就是寻找模式串子串的最长相同前后缀了.
  - 然后匹配可能在任意一个模式串子串的位置发生错误，因此必须要事先求出模式串所有子串的最大相同前后缀.

- 那该怎么求呢？先看一个例子，求aabbaabbb的所有子串的最长相同前后缀子串.
  - 看似很难，但不过可以先从简单的入手：
    1. 先排除一种特殊情况，一个字符串本身即是其前缀也是其后缀，但在kmp算法中不考虑这种情况，因为不发生任何移动，因此没有意义.
      - 所以，在这里我们定义一个字符串的前后缀不能是它自身.
    2. 然后直接用肉眼求结果，从最短子串求到最长子串：设x表示空字符串，也表示第一个字符前面的空位置

| 子串 | 最长相同前后缀 |
| --- | --- |
| a | x |
| aa | a |
| aab | x |
| aabb | x |
| aabba | a |
| aabbaa | aa |
| aabbaab | aab |
| aabbaabb | aabb |
| aabbaabbb | x |

  - 当然，如果你足够聪明可能直接用数学归纳法猜出其中的规律，但如果不行，那最敏锐的直觉会告诉你也许应该采用**动态规划**，即每一步的最优解可能会利用到前几步的最优解（局部最优解）
  - 从后往前观察规律可以发现：设[str]为str的解
    1. 求[aabbaabbb]，先观察上一步的结果，发现上一步[aabbaabb] = aabb，再以aabb作为前缀，看aabb的后一个字符是否和当前子串aabbaabbb的最后一个字符b相同，发现aabb后面的是a，不相同，那么得继续观察aabb.
    2. 发现[aabb] = x，那么再以x作为前缀，看x的后一个字符是否和当前子串aabbaabbb的最后一个字符b相同，发现x的后一个字符是a，还是不相同，那么得继续观察x.
    3. 由于x已经到头了，[x]是无解的，因此[aabbaabbb] = x.
  - 在看求解[aabbaabb]的过程，发现上一步[aabbaab] = aab，再以aab作为前缀，看aab的后一个字符是否和当前子串aabbaabb的最后一个字符b相同，发现aab后面的是b，相同，因此[aabbaabb] = [aabbaabb] + b = aab + b = aabb

- 总结，这是一个非常明显的动态规划过程：

```
字符串s的长度为n，{s[1 ~ m]}表示求子串s[1 ~ m]的最长相同前后缀

{s[1 ~ 1]} = x  // 初始化

for (now = 2; now <= n; now++)  // 每一个now循环求出一个{s[1 : now]}
    i = {s[1 ~ i-1]}的最后一个字符的索引
    while true
        if s[i+1] == s[now]
            {s[1 ~ now]} = {s[1 ~ i]} + s[now]
            break
        else if s[1 ~ i] == x
            {s[1 ~ now]} = x
            break
        else
            i = {s[1 ~ i]}的最后一个字符的索引
```

```C++
void build_table(int table[], char s[]) {
    // table[i]表示{s[0 : i]}的最后一个字符的索引

    table[0] = -1; // 初始化

    for (int now = 1; now < strlen(s); ++now) {
        int i = table[now - 1];
        while (true) {
            if (s[i + 1] == s[now]) { // 情况一，匹配上
                table[now] = i + 1;
                break;
            }
            else if (i == -1) {    // 情况二，没匹配上并且到头了
                table[now] = -1;
                break;
            }
            else {                    // 情况三，没匹配上且没到头，只能继续循环
                i = talbe[i];
                continue;
            }
        }
    }
}
```
