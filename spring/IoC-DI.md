# IoC-DI
> Inversion of Control，反转控制，也称为Dependency Injection，即依赖注入.

<br><br>

## 目录
1. [依赖注入]()
2. [IoC-DI使用规范（面向接口编程）]()
3. [将初始值注入bean的方式]()

<br><br>

### 一、依赖注入：[·](#目录)
- DI也是IoC的另一个称谓，IoC之前已经解释过了，就是将创建各种组件对象的控制权反交给容器来完成，但不过DI的定义可能更加形象和清晰.


1. 首先要搞清楚**“依赖”** 的含义：
  - A**调用**了B或者A**创建**了B都称为A依赖B.
  - 示例：在class A中的某个方法出现代码"B b = new B();"或者"b.show();"都属于**A依赖B**.
2. 现在的问题可以很形象的描述成：假设A是人，B是斧子，人需要使用斧子砍柴，而上面new B()的代码就相当于人需要自己早出一把斧子供自己使用，也就是人**使用斧子和造斧子的过程耦合在了一起**，一旦某天斧子升级了（B的构造器多了几个参数），那么人就要**跟着改变造斧子的方法**（也就是所有new B()的代码都需要修改），非常低效和落后！
3. 如果有这么一个工厂（也就是Spring容器），你想要什么工具**（依赖什么组件）** 都能立马现场提供给你**（并且是初始化过的）** ，而且永远是最新版的**（对应最新版的构造器以及属性和内容）** 那该多好啊！那就不需要后期维护的时候各种修改代码了！


- 上面描述的“将依赖提供给你”其实就是让Spring容器将依赖**注入**到程序中，也就是将被依赖者注入给依赖者，这就是依赖注入的含义.


**科学严谨的描述是：**

1. 程序在运行过程中，如果需要另一个对象写作，则无须在代码中创建被调用者，而是依赖外部容器的注入.
2. 调用者既不知道被调者的实例在哪里，也不知道如何实现，只是傻乎乎的“衣来伸手，饭来张口”而已.



- **Spring容器提供的就是上述服务**：
  1. 将程序中依赖的组件以bean的形式描述在配置文件中，并在配置文件中提供bean对象的初始化参数.
  2. Spring容器启动后就读取配置内容，并构建、初始化bean对象们，将其保存在容器中统一组织和管理.
  3. 当程序需要用到依赖的bean时就直接请求Spring容器来提供，无需自己显式调用构造器与Bean的实现相耦合.
  4. 如果后期Bean类型要升级的话，只需要修改Bean的类定义以及bean配置即可，程序以及业务逻辑完全不需要任何改动，这是多棒的设计模式啊！！
- **如果是IoC描述的是操作手法（实现描述），那么DI就是核心思想（设计思想）.**

<br><br>

### 二、IoC-DI使用规范————规范和实现分离：[·](#目录)
1. 由于IoC-DI的自身特点，强烈建议**面向接口编程**.
2. 即被依赖的对象在依赖主体中声明为接口，这样可以更好地让规范和实现分离.
  - 示例：class Person中有一个Axe对象axe，其方法useAxe表示使用斧头砍柴，需要在该方法中调用斧子的chop方法进行砍柴，因此Person依赖Axe.
    1. 这里最好将Axe定义成接口，这样Person对象就不知道axe的实例在哪儿以及Axe是怎么实现的了.
    2. 如果不这样做，假设今天使用的是石斧（实现）StoneAxe，砍了一段时间，发现效率不高，要改用铁斧了（SteelAxe实现），那么就需要将源代码中的"private StoneAxe stoneAxe;"改为"private SteelAxe steelAxe;"了.
    3. 这就是规范和实现相耦合，这也会导致代码污染（实现升级后还需要修改程序（业务逻辑））.
3. 一旦在IoC-DI模式中面向接口编程，那就是如虎添翼了，几乎可以做到代码的0污染！！
  - 即获取依赖的代码无需随升级而改变，依赖的使用也无需随实现改变而改变！！

<br><br>

### 三、将初始值注入bean的方式：[·](#目录)
- 分为两种：
  1. 设置注入：IoC容器使用bean的setter将初始值注入.
  2. 构造注入：IoC容器使用bean的构造器将初始值注入.

- 假设依赖关系如下：

```java
public Person { // Person依赖Axe
    private Axe axe; // 面向接口变成，被依赖对象在调用者中声明为接口类型

    public setAxe(Axe axe) { // setter
        this.axe = axe;
    }

    public Person(Axe axe) { // 构造器
        this.axe = axe;
    }
}
```

- 配置如下：bean.xml

```html
<!-- 一个bean标签定义一个bean，一个bean就是一个Java对象，会在Spring容器中被new出来 -->
<!-- id就是Spring容器中唯一标识一个bean的依据，在代码中注入bean就是根据该id注入的 -->
    <!-- class必须是实现类，因为Spring容器需要根据配置来new出一个实体对象，因此不能是接口 -->
<bean id="peter" class="org.lirx.app.user.Person">
    <!-- 下面两个分别是设置注入和构造注入，使用的时候必须二选一！ -->
        <!-- 如果初始值是普通数据类型（Java基本类型以及基本类，则使用value给出值 -->
        <!-- 如果初始值是另一个bean对象，即一个bean依赖另一个bean，则值用ref给出，表示引用另一个bean对象 -->
    <!-- 因此，bean.xml不仅可以初始化bean，也可以配置bean与bean之间的依赖关系 -->

<!-- 设值注入，使用property标签，指定属性并给出对应的初始值 -->
    <property name="axe" ref="stoneAxe"/>
        <!-- 依赖的是一把石斧 -->

<!-- 构造注入，使用constructor-arg标签，用来给出构造器的一个参数 -->
<!-- 如果构造器有多个参数，则多次使用constructor-arg标签 -->
    <!-- index表示第几个参数，从0计 -->
    <constructor-arg index="0" ref="steelAxe"/>
        <!-- 依赖的是一把铁斧 -->
</bean>

<!-- 被依赖的bean -->
<bean id="stoneAxe" class="org.lirx.app.util.StoneAxe"/>
<bean id="steelAxe" class="org.lirx.app.util.SteelAxe"/>
```

- **设值注入和构造注入的区别：**
  1. 设值注入是先调用了无参构造器后再使用setter设值.
  2. 构造注入是直接在调用有参构造器时设值.
  3. **因此设值注入必须提供无参构造器！**
- 优缺点比较：
  1. 设值注入更加直观和自然.
  2. 使用设值注入就无需有参构造器，可以减少代码量.
  3. 但不过使用构造器构造可以精确控制整个构造过程，对于复杂的构造逻辑使用构造器更好.
  4. 因此原则就是，设值注入为主，构造注入为辅.
