# 索引 & 视图
> 1. 索引最大的用处就是 **加速查询**，但也会消耗额外的空间，并且维护索引也消耗一定的时间.
> 2. 视图允许将复杂的查询结果作为临时表供进一步使用，不占磁盘空间，第一次查询时临时存储在内存中.
>    - 不仅可以将复杂问题简单化，也提高了进一步查询的效率.

<br><br>

## 目录

1. []()
2. []()

<br><br>

### 一、索引：index
> 1. 定义索引的关键字是index.
> 2. 索引相当于书的目录，目的就是为了 **加速表的查询**，可以加在 **单列** 或 **多列的组合** 上.
>    - 索引的实质其实是 **通过快速路径访问** 来加速数据的定位.
>    - 和约束一样，索引也必须从属于表，不能离开表而单独存在（加在列上的 **8大数据对象之一**）.

<br>

**1.&nbsp; 索引的缺点：**
！！所有在一个数据库对象中创建的索引都会被记录在information_schema数据库的STATISTCS表中；

1. 建立索引需要额外的存储空间.
2. 添加、删除、修改记录时索引也需要跟着变化，须要消耗额外的时间.

<br>

**2.&nbsp; 创建索引：** 有自动创建和手动创建两种

1. 自动创建：唯一键（UNIQUE）、主键（PRIMARY KEY）、外键（FOREIGN KEY）本身就是用索引实现的.
2. 手动显式创建：使用create关键字创建.
   - 毕竟索引（index）也是和table一样平行地属于 **8大DDL数据对象之一**.

```SQL
-- 手动显式创建索引. （索引从属于表，必须体现出索引属于哪张表）
create index 索引名
on
    目标表(目标列或列组合)
;
```

- 示例：

```SQL
-- 1. 单列索引
create index MyIndex
on
    table_XXX(id)
;

-- 2. 多列组合的索引
create index MyIndex
on
    table_XXX(name, no)
;
```

<br>

**3.&nbsp; 删除索引：** drop index （必须要体现出索引属于哪张表）

```SQL
drop index 索引名
on
    从属的表
;
```

<br><br>

### 二、视图：
> 关键字是view，**8大DDL数据对象之一**.
>
>> 1. 视图是一种“特殊”的数据表，它是select语句的 **临时查询结果**.
>> 2. 它作为 **临时数据表** 保存在内存中，**不会写入磁盘永久保存**.

<br>

**1.&nbsp; 视图的用途：**

1. 将复杂问题简单化：
   - 要查询的数据要基于一个复杂的select查询结果，那么可以将该复杂select查询定义成视图.
      - 那么，接下来就可以把该视图当做一个普通表继续进行下一步的查询了.
2. 大大提高查询效率：
   - 如果很多数据的查询都要基于该复杂select查询，那如果将该select查询都当做各个查询的子查询的话就会重复进行该复杂select查询好多次.
      - 将该复杂select查询定义成视图的话，该视图在底层其实是内存中的一张临时表，各个查询就是基于该内存临时表查询，效率大大提高.

<br>

**2.&nbsp; 创建视图：** create & 基于select查询

> 8大DDL数据对象的创建和删除必然使用create和drop语句.

- 创建view **没有IF NOT EXISTS语法，只有OR REPLACE语法**.
   - 表示，**如果已存在同名的视图就覆盖，否则拒绝创建**.

```SQL
create [OR REPLACE] view 自定义视图名
as
    select查询
;
```

<br>

**3.&nbsp; 视图：**

```SQL

```

<br>


    2) 因此视图的本质就是一个查询语句罢了，其定义格式（关键字是view）：
！！create or replace的意思就是如果不存在就创建，如果已经存在了就那新的替换掉；
！例如：create or replace view MyView as select Number, Name from TableStudent; // 视图MyView就是select Number, Name from TableStudent查询得到的一张临时逻辑表
    3) 那为什么需要视图呢？直接调用那个里面的子查询不就能得到视图的结果吗？
         i. 如果要对那个子查询的结果继续查询呢？那不就要继续嵌套一层select查询了吗？
         ii. 如果有很多很多最终的查询都是基于那个子查询的结果继续查询呢？那岂不是要写很多遍那个子查询了吗？
         iii. 基于上述两点，再之，如果那个子查询非常非常的复杂，那谁又愿意重复多次写那个子查询呢？
         iv. 但是如果将这个子查询的结果当成一张普通的表来处理，然后再基于这张表继续查询那么一切问题不就简化很多了吗？
         v. 视图就是这个目的：方便查询！！简化查询！！
     4) 由于视图只是数据的逻辑显示，并不存储真正的数据，因此不能修改视图中的数据，即使修改也是会被拒绝的，以为标准SQL规定视图仅仅就是用来简化查看数据的，因此视图必定是只读的；
！！MySQL允许在创建视图时在末尾使用with check option子句来强制规定该视图不允许被修改，例如：create or replace view MyView as select * from t1 with check option;
    5) 既然都要用子句来强制限制视图不能修改，那就意味着其实还是能修改的咯？是的，是允许修改，只不过修改的只是视图产生在内存中的那个临时数据（就是那个临时产生的结果“表”），但不影响真实存放在磁盘中的原表的数据；
    6) 删除视图：视图只是临时性的逻辑显示，因此删除总是能成功的，而且绝不会产生任何附加影响，语法就是：drop view 目标视图名;
    7) 视图可以是很多表连接查询的组合，因此必定是和表平行的一种数据库对象；
