# 约束的创建和删除
> 约束是8大数据对象之一，只有DDL语句才能操作约束.
>
> - MySQL的键（唯一键、主键、外键都是用索引实现的）. （非空键除外）

<br><br>

## 目录

1. []()
2. []()

<br><br>

### 一、约束的概念：
> 1. 约束是定义在数据表上的 **强制执行** 的 **数据完整性校验规则**.
> 2. 它和数据表本身都属于 **8大DDL数据对象之一**.
>    - 因此它和表的地位是相同的，也会被当做元数据记录在系统表中：
>       - MySQL使用 **information_schema.TABLE_CONSTRAINTS** 系统表来记录在该系统中定义的所有约束.
> 3. 约束一定是属于表的：
>    1. 约束 **不能离开表而定义**，约束 **一定属于某张表**.
>    2. 因此在查询约束的时候可以使用TABLE_NAME这个属性：
>
>> select * from **information_schema.TABLE_CONSTRAINTS** where **TABLE_NAME='XXX'**;

<br>

**1.&nbsp; 5种主要的完整性约束：**

1. NOT NULL：非空键.
   - 列的值不能为空.
2. UNIQUE：唯一键.
   - **列的值** 或 **列的值的组合** 不能重复.
3. PRIMARY KEY：主键.
   - **列的值** 或 **列的值的组合** 唯一标识一条记录.
      1. 本质就是 UNIQUE + NOT NULL.
      2. 但主键在逻辑上还有唯一标识的作用，因此主键在一张表中 **最多只能定义1个**.
         - 但也 **可以不定义任何主键**.
4. FOREIGN KEY：外键.
   - 该列的值 **参照（来自）** 另一列（另一列**可以来自本表也可以来自其它表**）的值.
      - 当然也可以是 **列的值的组合**. （那就必须和被参照的列的值的组合一一对应）.
5. ~~CHECK~~：逻辑表达式约束.
   - 列的值必须满足指定的逻辑表达式.
      - 但MySQL并 **不支持check约束**，虽然提供了check语句，但不起任何作用.
      - MySQL要求开发者 **手工用触发器来实现check约束**.

<br>

**2.&nbsp; 单列约束 & 多列约束：**

1. 单列约束：约束只加在一列上.
2. 多列约束：也叫 **组合约束**.
   - 将多列（≥2列）当成一列加以约束.
   - 约束的是 **多列的值的组合**.

<br>


**3.&nbsp; 约束的 定义&删除：**

> 约束只能定义和删除，**不能修改**，修改就只能 **先删除再重新定义**.

1. 定义约束的2个时机：
   1. 创建表的时候. （**create table**）
   2. 修改表的时候. （**alter table** XXX add|modify|change）
2. 定义约束的语法：
   1. 列级约束语法：在 **列定义的末尾** 指定约束.
      - 时机：创建表、修改表（添加列、修改列）.
   2. 表级约束语法：像定义列一样单独定义.
      - 时机：
         1. 创建表：在新的一行，和定义列一样平行地定义一个约束.
         2. 修改表：只能是 alter table XXX **add** 一个约束.
      - 表级约束**最大的特点**：
         1. **多列的值的组合** 的约束 **只能** 使用表级约束语法定义.
            - 不能使用列级约束语法定义.
         2. 可以 **为约束单独命名**.
            - 就像命名表一样命名一个约束的名字.
3. 删除约束：
   - MySQL中删除约束的语法比较特殊.
   - 很多约束底层使用索引实现的，因此有些约束删除时要用到索引删除的语法.

<br><br>

### 二、NOT NULL：
> 列的值不能为空（null），null是关键字，没有大小写之分，表示空值.
>
> - null在SQL中 **不等于0、不等于空字符串""**，**null也不等于null本身**.
>    - 只是表示空、没有值而已.
>
>> 非空约束的关键字就是not null.

<br>

**1.&nbsp; NOT NULL只能：**

1. 定义 **单列约束**.
2. 使用 **列级约束语法定义**.

<br>

**2.&nbsp; 举例：**

```SQL
-- 1. 创建表时
craete table xxx
(
   col int not default 10 NOT NULL, -- 单列约束 + 列级约束语法
   ...                              -- 不能多列约束 + 没有表级约束语法
);

-- 2. 修改表时
alter table xxx
modify|add|change(需要额外重命名)
  col varchar(255) default 'xyz' NOT NULL;
```

<br>

**3.&nbsp; 注意事项：**

1. 一般会给NOT NULL列指定一个default默认值.
   - 由于非空约束必须插入非空值，否则会拒绝插入（修改）数据.
   - 当然可以不指定默认值，但要小心插入空值会报错哦！
2. 创建表时不指定NOT NULL就默认为是null的（即可以是空值），当然也可以显式写上NULL强制指定成可以为空值！
   - **删除非空键时用的就是这招.**

<br>

**4.&nbsp; 删除非空约束：**

> 用NULL抵消NOT NULL.

- 只能在修改表时进行. （没有表级约束语法的原因）

```SQL
-- 假设这列原来是NOT NULL约束，那么用NULL抵消一下就可以达到删除的目的了
alter table xxx modify col int NULL;
```

<br><br>

### 三、UNIQUE： 列级约束、表级约束的语法——以unique约束为例：
> 指定 **列的值** 或 **多列的值的组合** 唯一，关键字是UNIQUE.
>
>> 支持所有，**单列约束、多列约束、列级约束语法、表级约束语法**.

<br>

- 关于NULL唯一的特殊情形：
   1. 前面说过了，null不等于null.
   2. 因此多个null值也符合UNIQUE约束. （包括多列null值组合）
      - 毕竟空的值不能比较，比较也没有意义，只能说明现在还没值，等有值了以后才能比较是否唯一.

<br>

**1.&nbsp; 列级约束语法：**

```SQL
-- 1. 建表时
create table XXX (
  id int UNIQUE,
  ...
);

-- 2. 修改表时
alter table XXX
add|modify|change(需要额外重命名)
  id int UNIQUE;
```

<br>

**2.&nbsp; 表级约束语法：**

- 表级约束定义的一般语法：**[constraint 约束名] 约束的具体定义**
   - 对于UNIQUE非命名版本，各个数据库厂商给的默认命名实现差异较大.
   - 想要知道MySQL的默认命名版本可以使用一下select语句查询：
      - select * from **information_schema.TABLE_CONSTRAINTS** where **TABLE_NAME='XXX'**;

```SQL
-- 1. 创建表时
create table XXX (
  ...,
  UNIQUE(id1),   -- 1. 单列表级约束
  UNIQUE(id2, id3),  -- 2. 多列组合表级约束
  constraint XXX_UK(id4, id5),  -- 3. 约束命名（多列组合）的表级约束
  ...
);

-- 2. 修改表时：一次只能add一个UNIQUE键，不能add多个.
alter table XXX
add
  UNIQUE(id1, id2);  -- 命名和非命名的版本两者二选一
  constraint XXX_UK UNIQUE(id1, id2);  -- 两者二选一，不能同时使用！
```

<br>

**3.&nbsp; 删除UNIQUE键：**

- 由于UNIQUE键在MySQL中底层使用索引（index)实现，这里 **使用索引删除语法删除**.
   - 任何键都离不开所属的表，因此必须先alter table才能进一步删除.

```SQL
-- 由于需要UNIQUE键名，如果创建时采用默认命名的方式
  -- 就必须select information_schema.TABLE_CONSTRAINTS一下了
alter table XXX
drop
  index 唯一键的键名;
```

<br><br>

### 四、PRIMARY KEY：
> 主键用于 **唯一标识一条数据记录**，关键字是PRIMARY KEY.
>
> - 本质就是 **NOT NULL + UNIQUE**.
> - 但特殊的是，一张表中 **最多只能指定1个** 主键.
>    - 这是由唯一标识的逻辑属性决定的.
>    - 但一张表可以没有主键.
>
>> - 支持所有，**单列约束，多列约束，列级约束语法，表级约束语法**.

<br>

- MySQL对主键的特殊实现：
   - 虽然底层也是用索引实现的，但是：
      1. **MySQL无论如何都只会给主键命名为"PRIMARY".**
         - 即使自己使用constraint关键字命名了也没有，还是为"PRIMARY".
         - 这是因为：毕竟一张表最多只能有一个主键，表内不存在主键命名重复的问题，因此还不如强制统一命名为"PRIMARY"来的好，可以降低系统表的复杂度.
      2. **删除主键MySQL提供了特殊语法，不是用drop index删除.**

<br>

- 一般设置整型主键**自增长**：
   - 一般作为主键最多的就是像“编号”这一类的整型字段的，这类属性往往具有递增的特性，如加一条记录“编号”就+1.
   - 定义自增长使用 **auto_increment** 关键字.
      - 方便之处在于：insert记录时可以不指定该字段的值，默认等于上一条记录的该列值+1.

<br>

**1.&nbsp; 列级约束语法：**

```SQL
-- 1. 建表时
create table XXX (
  id int auto_increment PRIMARY KEY,  -- 自增长整型主键
  -- 命名版本无效，永远命名为"PRIMARY"
  ...
);

-- 2. 修改表时
alter table XXX
add|modify|change(额外重命名)
  id int PRIMARY KEY;  -- 主键不能多于1个！注意了
```

<br>

**2.&nbsp; 表级约束语法：**

```SQL
-- 1. 建表时
create table XXX (
  ...
  PRIMARY KEY(id1, id2),  -- 多列表级约束
  -- PRIMARY KEY(id1),  单列表级约束
  ...
);

-- 2. 修改表时
alter table XXX
add
  PRIMARY KEY(id1, id2);
```

<br>

**3.&nbsp; 删除PRIMARY KEY：**

- 提供了特殊语法：drop PRIMARY KEY
   - 当然也可以使用 drop index PRIMARY，毕竟主键名永远都是"PRIMARY"嘛.
   - 但既然提供了专用语法，那就应该多使用专用语法.

```SQL
alter table XXX
drop
  PRIMARY KEY;
```

<br><br>

### 五、FOREIGN KEY：
    1) 顾名思义，就是该列的值参照了另外一列（值的范围处于另一列的值中），而被参照的列可以是其它表（外关联），也可以参照本表中的其它列（自关联）；
    2) 被参照的表称为“主表”，参照的表称为“从表”；
    3) 外键最大的特点就是其值必须可以唯一对应到被参照列的一个值上，也就是说对于外键，只能是唯一键被参照（当然可以是主键，主键也是一种唯一键）；
！！因此可以概括为从表上外键必须来自主表的被参照列，因此外键的值的范围就限定在了被参照列的值之内，或者为空（null属于任何范围，即表示还没参照任何值）；
    4) 外键的3种关系：
         i. 1对空：外键的值为null，即还没有参照任何值；
         ii. 1对多：外键的值可以重复，那么相同的值必然对应到参照的同一个主表值上，因此主对从的记录之间是1对多的关系；
         iii. 1对1：外键同时被指定为unique，那么外键之间互不相同，那么就意味着他们参照的值也互不相同（参照值跟被参照值必然相等的），因此主队从的记录之间是1对1的关系；
    5) 一张表中当然可以指定多个外键！
    6) 设置外键：语法格式还是通用的，只不过关键字是references，即参照的动词，表示该键要参照哪一列；
    7) 而外键的名称（关键字）是foreign key：列级约束直接用动词references指定要参照的列，而表级约束需要使用“名词（指定谁是外键）+动词（参照了谁）”；
    8) 格式总结：
         i. 列级约束：列定义... references 被参照的表(被参照的列);
         ii. 表级约束：[constraint 自定义约束名] foreign key(哪几列是外键) references 被参照的表(被参照的那些列);
！！可以看到表级约束可以定义组和列的外键，因为有多列作为一个组合参照其它表，因此被参照的列也必须是组合，类型啥的一定要一一对应；
！！MySQL并不支持外键的列级约束！MySQL要求定义外键只能用表级约束，但MySQL还是保留了列级约束的语法，只不过不生效而已，仅仅就是为了兼容标准SQL的语法而已；
    9) 设定外键不能用modify，只能在建表或者是add的表级约束方式添加！！！MySQL不支持add的列级约束设置外键！
    10) 示例：

create table t2
(
	col1 int,
	col2 int,
        // col3 int references t1(col1), // 列级约束的外键在MySQL中不生效！！
	constraint fk foreign key(col1, col2) references t1(col1, col2) // 建表时的表级约束
);

alter table t2 add constraint fk foreign key(col1, col2) references t1(col1, col2); // 增加是的表级约束，MySQL不支持modify的列级约束
！！注意：多列组合是要保证主和从的列一一对应；
！！如果references参照的是本表中的另外一列那么就是自关联了！！比如一张员工表，里面有一个字段为是否是经理，而经理可以管理多个员工，那么就在一张表的记录中就存在从属关系了，如果有这样的字段（比如所属的经理），那么就是自关联了；

6. 删除约束：




    6) 和外键相关的删除：比较麻烦，因为存在主从对照的关系，特别是在主表上删除会影响到从表
         i. 首先考虑删除主表中的记录：由于主表被从表参照，那么删除主表中的记录后从表中参照它的记录就没有东西可以参照了，因此如果直接删除主表中的记录会被拒绝；
         ii. 因此正常情况下必须先删除从表中参照的记录，然后才可以删除主表中被参照的那几个记录；
         iii. 当然标准SQL语句提供了级联删除语法，可以在删除主表记录时自动将相应的被参照的从表记录也删除，这必须在从表定义外键时指定：
              a. 关键字是on delete cascade（级联删除参照记录）和on delete set null（并不删除参照记录，只是级联地将参照记录中的外键设为null（但前提是该外键不能是not null约束的！）；
              b. 这两个属性作为属性语法写在外键定义的末尾处；
              c. 示例：
create table t2
(
	col1 int,
	col2 int,
	constraint fk foreign key(col1, col2) references t1(col1, col2) on delete cascade
);

alter table t2 add foreign key(col1) references t1(col2) on delete set null;
！！外键定义在MySQL必须使用标记约束，这里前者是级联删除，后者是级联置空；
         iv. 接下来考虑删除表中的外键约束了：外键约束很好删除，因为外键是从表中的，从表的改变并不影响主表，因此可以直接放心删除
              a. MySQL提供的删除外键的语句是：drop foreign key 外键名;
              b. 如果自定义了外建名那么可以直接指定，如果没有定义外键名（没有用[constraint 键名]的方式定义外键），就只能使用系统隐式指定的默认外键名；
              c. MySQL默认的隐式外键命名规则是："表名_ibfk_n"，其中n代表该外键是表中定义的第几个外键，按照定义的先后顺序编号；
              d. 例如：
	foreign key(col1) references t1(col1) on delete cascade,
	foreign key(col2) references t1(col2) on delete set null,
