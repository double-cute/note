# 任务队列
> **任务队列** 以及 **发布/订阅模式** 都是典型的 **生产者/消费者模型**.
>
>> - 任务队列是指：传递任务的队列
>>    1. 是 **生产者进程** 和 **消费者进程** 之间的 **沟通桥梁**.
>>    2. 生产者负责产生任务，并将任务放入任务队列中.
>>    3. 消费者负责从任务队列中取出任务并执行.

<br><br>

## 目录

1. [生产者-消费者模型的优点](#一生产者-消费者模型的优点)
2. [任务队列的实现：list、blpop-brpop](#二任务队列的实现listblpop-brpop--)

<br><br>

### 一、生产者-消费者模型的优点：[·](#目录)

<br>

1. 松耦合：
   1. 生产者和消费者无须知道彼此的实现，只需要约定好任务的格式.
   2. 两者可以分别由不同团队使用不同编程语言实现.
2. 易于部署和扩展：
   - **消费者可以有多个，分别部署在不同服务器上.**
      - 这样可以有效降低单台服务器的负载.

<br><br>

### 二、任务队列的实现：list、blpop-brpop  [·](#目录)
> 首先可以想到的思路就是利用list的push/pop系列命令来实现队列.
>
>> - 生产者向list的一头push任务.
>> - 消费者向list的另一头pop出任务并执行.
>>    - 但使用list的普通pop命令需要用一个死循环不安检测队列是否非空.
>>       - 在空的情况下死循环等待队列中有元素.
>>       - 非空的情况下取出元素并执行.
>>       - 死循环特别耗费资源.
>>    - 因此Redis提供了blPop/brPop命令：
>>       - **在list为空的情况下会阻塞连接，一直等待有任务进队列后才会取出元素.**

<br>

**1.&nbsp; blPop和brPop的用法：**

1. 最后一个参数是超时时间：
   1. 单位是秒.
   2. "0"表示无线等待（队列为空就永久阻塞）.
   3. 如果超时则返回nil.
2. pop的list键可以有多个：
   1. 优先级是左边的大，右边的小.
   2. 同一时刻，只要参数中有非空的队列，那就一定是：
      1. 先pop优先级高的.
      2. 只有优先级高的pop空以后才会pop优先级低的.
3. 返回两个string值：
   1. 第1个是被弹出元素的那个list的键名.
   2. 第2个是该元素的值.

```Shell
blpop|brpop k1 k2 ... timeout(s)
```

<br>

**2.&nbsp; 消费者执行步骤：**

```Shell
infinite_loop:
    task = brPop
            task_queue_important
            task_queue_normal
            task_queue_low
            0;
    excute($task)
```

<br>

**3.&nbsp; 测试方法：**

1. 只开一个redis-server.
2. 开4个redis-cli连接：
   1. 消费者cli使用brpop等待从三个队列中取元素.
      - 三个队列的优先级分别为高、中、低.
   2. 其余3个生产者cli分别对应3个优先级的队列.
      - 分别往各自的队列中lpush元素.
   3. 消费者cli不断观察命令返回结果（取出的是哪个队列的哪个元素）.
