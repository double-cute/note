# 列表：list
> list，命令前缀是l.
>
>> 1. 只能存放string类型数据.
>> 2. 用双向链表维护string的插入顺序.
>> 3. 最常应用于队列（两端操作复杂度为O(1)）.
>> 4. 1个list最多容纳 **2^32 -1** 个string.
>>
>>> - **左端是前，右端是后，最左端索引为0.**
>>> - **只要是删除元素的操作（弹栈、remove等），如果把元素都删完了，那key也就一并被删除了！（keys命令也找不到了！）**

<br><br>

## 目录

1. [工具命令](#一工具命令)
2. [端口栈操作](#二端口栈操作)
3. [修改](#三修改)
4. [索引操作](#四索引操作)

<br><br>

### 一、工具命令：[·](#目录)

<br>

**1.&nbsp; 获取列表长度：**

- 和SQL不同的是，list直接维护这一个list_len域实时记录列表的当前长度，因此复杂度是O(1).

```Shell
llen 键名
```

<br><br>

### 二、端口栈操作：[·](#目录)
> 该系列命令比较特殊，前缀l表示操作左端，前缀r表示操作右端.
>
>> push的时候，按照参数从左往右的顺序逐个压栈（FILO）.

<br>

**1.&nbsp; 压栈：支持批量压栈**

- 返回增加元素后列表的长度

```Shell
lpush|rpush 键名 值 [值 ...]
```

<br>

**2.&nbsp; 弹栈：只支持单个弹栈**

- 返回弹出来的元素. （弹出后删除被弹元素）

```Shell
lpop|rpop 键名
```

<br><br>

### 三、修改：[·](#目录)

<br>

**1.&nbsp; 在指定元素处插入元素：**

- 在指定元素 之前|之后 插入元素.
- 返回插入后列表的长度.

```Shell
linsert 键名 before|after 指定元素 待插入元素
```

<br>

**2.&nbsp; 删除前count个指定元素：**

- count > 0：从左到右删除前count个value.
- count < 0：从右往左删除前|count|个value.
- count == 0：删除全部元素，变成一个空列表
   - 返回实际删除的元素个数.

```Shell
lrem 键名 count value
```

<br>

**3.&nbsp; 列表转移：**

- 将源列表右端元素弹出后压入目的列表的左端.
   - 返回该元素的值.

```Shell
rpoplpush 源列表键名 目的列表键名
```

<br><br>

### 四、索引操作：[·](#目录)
> 由于列表使用双向链表实现的，因此索引操作的效率并不是很高，在生产环境中使用要慎重.
>
>> - 索引可以为负数：-1表示右边第1个元素

<br>

**1.&nbsp; 指定索引处取值/设值：**

```Shell
# 1. 取值
lindex 键名 index
# 2. 设值（必须在range范围内，否则报错：index out of range），返回是否成功的状态
lset 键名 index 新值
```

<br>

**2.&nbsp; 取子区间：**

- 返回取得的子区间的所有元素.
   - 区间端点：
      1. 闭区间[beg, end]
      2. beg > end：返回空集
      3. end > range：则默认end = range

```Shell
lrange 键名 beg end
```

<br>

**3.&nbsp; 瘦身：只保留指定区间**

- 指定区间之外的元素全部删除.
   - 返回OK状态.

```Shell
ltrim 键名 beg end
```
