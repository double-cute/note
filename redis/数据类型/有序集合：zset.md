# 有序集合：zset
> Sorted Set，但是其命令前缀为z.
>
>> - 结构与实现：
>>    1. 元素只能是string类型，最多容纳 **2^32 - 1** 个元素.
>>    2. 用 **hash表 & 跳跃表（skip list）** 实现的，所以比较大小的依据是 **元素的分数**.
>>       1. 分数的类型是数字型string，可以是 **双精度浮点类型的数字string**.
>>       2. 元素各不相同（仍然是集合，这部分用hash表实现），但分数可以相同（跳跃表）.
>>    3. 复杂度：
>>       1. 可以调整元素的位置.
>>       2. 和list相比，访问位于中间的元素的复杂度仅为O(logN).
>>       3. 5中类型中最耗费内存，但结构最为高级.
>>
>> <br>
>>
>>> - 常用于游戏玩家排行榜之类的需要实施调整元素位值的应用场景.

<br><br>

## 目录

1. []()
2. []()

<br><br>

### 一、工具命令：

<br>

**1.&nbsp; 获取集合中元素的个数：**

```Shell
zcard 键名
```

<br>

**2.&nbsp; set的正常删除元素：**

- 返回实际删除的元素个数.

```Shell
zrem 键名 元素 [元素 ...]
```

<br><br>

### 二、跟分数相关的操作：

<br>

**1.&nbsp; 添加元素：按照分数添加**

- 如果元素已存在则覆盖分数，否则插入元素（如果键不存在则创建）.
   - 返回的是新添加的元素个数（**原来已存在而覆盖的不算**）.
   - 再强调一下，**分数可以是双精度浮点型字符串**.

```Shell
zadd 键名 分数 元素 [分数 元素 ...]
```

<br>

**2.&nbsp; 给某个元素的分数来一发增量：**

- 返回的是 **更改后的分数**，如果原来的分数不存在则会先赋成0再计算.
   - 增量可以是负数，就是用该命令修改分数.
   - zadd覆盖，zincrby修改.

```Shell
zIncrBy 键名 增量 元素
```

<br>

**3.&nbsp; 获取某个元素的分数：**

- 元素不存在返回nil. （毕竟分数是str类型的嘛）

```Shell
zscore 键名 元素
```

<br>

**4.&nbsp; 在指定的分数范围内进行一定操作：**

- 关于分数范围：
   1. 首先范围是闭区间：[min, max].
   2. **想设定成开区间就必须给区间端点加前缀'('.**
      - 例如：(min max表示(min, max]，min (max表示[min, max)，(min (max表示(min, max)
   3. 端点也可以指定为+inf和-inf.

```Shell
# 1. 获得指定分数范围内的元素个数
zcount 键名 min分 max分

# 2. 删除指定分数范围内的所有元素
  # 返回实际删除的元素个数
zremrangebyscore 键名 min分 max分

# 3. 获得指定分数范围内的所有元素
  # 返回元素列表（1行一个元素），如果有withscores选项则一并输出分数（第2行是分数）
  # limit限定了只输出 “结果中（从[min分]开始）” 从offset排名处（从0计）开始的count个元素.
    # revrange是从大到小排，而非rev是从小到大排，并且min、max顺序也反过来.
zRangeByScore 键名 min分 max分 [withscores] [limit offset count]
zRevRangeByScore 键名 max分 min分 [withscores] [limit offset count]
```

<br><br>

### 三、跟排名相关的操作：
> 排名就是按照分数 **从小到大** 或者 **从大到小**. （**从0计**）

<br>

**1.&nbsp; 获取元素的排名：**

- 分别是从小到大的排名和从大到小的排名.

```Shell
zrank 键名 元素
zrevrank 键名 元素
```

<br>

**2.&nbsp; 在指定的排名范围内进行一定操作：**

- 对于排名：0表示第1名，-1表示最后一名，负数表示从后往前.

```Shell
# 1. 删除指定范围内的所有元素  （只有从小到大排序的版本）
  # 返回实际删除的元素数量
zremrangebyrank 键名 beg end

# 2. 输出指定排名范围内的元素列表
  # rev是指输出顺序从大到小排列，但是beg和end的关系不变（beg≤end）.
zrange 键名 beg end [withscores]
zrevrange 键名 beg end [withscores]
```

<br><br>

### 四、有序集合的集合运算：
> 可惜的是有序集合只提供了交并运算，并没有差运算，并且只有存储的形式（store）.

<br>

1. 只有存储的版本，将运算结果 **覆盖入** dst_key中，dst_key的存储类型也是 zset.
2. 必须指定操作数（集合）的个数 op_key_num.
3. 权重是各个操作数集合的权重，参与运算时给各自集合中元素的分数 ×上 自己集合的权重.
   - 权重可以是 **双精度浮点数字符串**.
4. aggregate决定了结果中各个元素的分数是如何计算的：
   1. sum：不写的话默认就是sum模式，各集合元素分数的累加.
   2. min：取最小值.
   3. max：取最大值.
5. 返回dst中元素的个数.

```Shell
zInter|UnionStore dst_key op_key_num op_key [op_key ...] [weights 集合权重 ...] [aggregate sum|min|max]
```
