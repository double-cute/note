# 散列
> 即hash，其命令前缀为h.
>
> - 该类型可以很好地和面向对象编程兼容，散列化是一种数据库层面上的面向对象.

<br><br>

## 目录

1. [散列的结构]()
2. [散列结构的最大优点]()
3. [工具命令]()
4. [字段设值 & 删除]()
5. [取值]()
6. [数字运算]()

<br><br>

### 一、散列的结构：[·](#目录)
> 相当于键值（key所对应的value）又是一个字典.
>
>> 1. 这个字典的键叫做 **字段**，当然和Redis键一样 **只能是string类型**.
>> 2. 这个字典的值叫做 **字段值**，字段值也 **必须是string** 类型，不能嵌套其它类型.
>>    - 总结：
>>       1. 键（key）就相当于对象引用.
>>       2. 值（value）就是一个散列类型，该类型中：
>>          - 字段（field）就是对象中的数据域的引用.
>>          - 字段值（field value）就是数据域中的真实数据.
>>
>> <br>
>>
>>> - Redis的其它3中类型也都不允许类型嵌套（集合不能嵌套集合或其它，列表也不能嵌套列表和其它，都只能存放string）.
>>>    - 因为不嵌套也可以完成几乎所有的功能和设计，数据库还是越简单越好.

<br>

- 散列类型的基本属性：
   1. 最多包含2^32 - 1个字段.
   2. 命名策略：
      1. 存储对象：key命名为 "类型名(单数):对象ID"，字段正常命名为 "数据域名".
      2. 存储类：key命名为 "类型名(复数)"，字段命名为 "静态域名".

<br><br>

### 二、散列结构的最大优点：[·](#目录)

<br>

- 相比SQL表而言，如果SQL表中的 **某1条记录** 需要增加1个字段，那么：
   1. 情况1：为整个表增加该字段，但只有该记录会用到，其它记录用不到，造成大量空间浪费.
   2. 情况2：再额外构造半结构化的表，将这种少数、零散地信息存入这些同样少数的半结构化表中.
      - 但这样会造成表太多，不利于管理.
   3. 情况3：采用ORM时修改表结构意味着中断服务、重启网站.

<br><br>

### 三、工具命令：[·](#目录)

<br>

**1.&nbsp; 获取字段数量：**

```Shell
hlen 键名
```

<br>

**2.&nbsp; 判断字段是是否存在：**

- 存在返回1，不存在返回0.

```Shell
hexists 键名 字段名
```

<br><br>

### 四、字段设值 & 删除：[·](#目录)
> 如果键不存在则会顺便自动建立该键.

<br>

**1.&nbsp; 单字段设值：**

- 如果字段原来不存在，则是插入操作（insert），将返回1.
- 如果字段原来已经存在了，则是更新操作（update），将返回0.

```Shell
hset 键名 字段名 字段值
hsetnx 键名 字段名 字段值  # 只有当字段不存在时设值，成功返回1，否则返回0
```

<br>

**2.&nbsp; 批量字段设值：**

- 返回的是状态码（OK之类）.

```Shell
hmset 键名 字段名 字段值 [字段名 字段值...]
```

<br>

**3.&nbsp; 删除字段：支持批量删除**

- 返回实际删除的字段数量.

```Shell
hdel 键名 字段名 [字段名 ...]
```

<br><br>

### 五、取值：[·](#目录)

<br>

**1.&nbsp; 获取单个/多个字段的值：**

- 输出是：一行一个字段值.

```Shell
hget 键名 字段名
hmget 键名 字段名 [字段名 ...]
```

<br>

**2.&nbsp; 获取所有：**

```Shell
# 1. 获取所有字段名，1行1个字段名
hkeys 键名
# 2. 获取所有字段值，1行1个字段值
hvals 键名
# 3. 获取所有字段名&字段值，2行一对字段名&字段值，其中第1行是字段名，下一行是字段值
hgetall 键名
```

<br><br>

### 六、数字运算：[·](#目录)

<br>

**1.&nbsp; 数字字段增量：**

```Shell
hincrby 键名 字段名 增量
```
