# 位操作
> 相当于Java中的BitSet.
>
>> 再用位操作操作字符串键值时，就是把字符串当成一个长长的、连续的位向量来看待.
>
> <br>
>
>> Redis作为高性能缓存时经常被当作位表来使用（比如存放40亿个QQ号的在线情况之类的）.
>>
>> - Redis的位操作时间复杂度都是常数，因此采用广泛，相当重要.

<br><br>

## 目录

1. [大端 & 小端]()
2. [获取键值的位信息]()
3. [设值 & 位运算]()

<br><br>

### 一、大端 & 小端：[·](#目录)
> 即字节的存储顺序.
>
>> 大端-小端 顺序的差异只存在于单个字节内，整体上看都是低字节存放在地地址处，高字节存放在高地址处.

<br>

1. 小端：比较常见，大多数应用都采用小端存放.
   - 单个字节内，低位存放在低地址处，高位存放在高地址处.
2. 大端：
   - 单个字节内，高位存放在低地址处，低位存放在高地址处.

<br>

- Redis的存储模式是 **大端**.
   - 例如：set str bar中键值"bar"的存储格局如下.

| 索引 | 0 - 7 | | 8 - 15 | | 16 - 23 |
| --- | :---: | :---: | :---: | :---: | :---: |
| 位值 | **'b'**：0 1 1 0 0 0 1 0 | | **'a'**：0 1 1 0 0 0 0 1 | | **'r'**：0 1 1 1 0 0 1 0 |

- 可以看到，每个字节中的高位处于低索引（低地址）处，低位处于高索引（高地址）处，典型的大端存放.
- **索引从0计.**

<br><br>

### 二、获取键值的位信息：[·](#目录)
> 所有get命令都不改变数据库中的内容（原封不动）.

<br>

**1.&nbsp; 获取指定索引处的位值：getbit**

1. 只能返回0或1的(integer)值.
2. 指定索引范围异常：
   1. 负值报错.
   2. 正值超出范围的都返回0. （Redis假设不存在的位都是0）
3. 如果键本身不存在也返回0，并且不会自动加入该键. （还是nil）

```Shell
getbit 键名 指定索引
```

<br>

**2.&nbsp; 获取第1个值为0/1的位的索引：** 返回的是绝对索引（相对于0计的）

> **Redis中的区间都是闭区间，跟标准的Java API风格不一样（Java是左闭右开的）.**

1. 不指定区间表示检测整个键值.
2. 区间端点指的是 **字节的索引**，**从0计**.
3. 只指定1个端点表示从该字节开始到末尾.
4. 指定两个表示闭区间.
5. 超出范围的都算位值0.

```Shell
bitpos 键名 检测的位值 [起始字节索引[ 终止字节索引]]
```

- 不存在就返回-1：
   1. 1不存在很容易判断.
   2. 0不存在：一种是全是1（真不存在），另一种是起始点大于字符串的长度.

<br>

**3.&nbsp; 统计位值位1的个数：**

```Shell
# 注意：是闭区间[start, end]，而不是左闭右开，和Java的API风格不一样！
bitcount 键名 [起始字节索引[ 终止字节索引]]
```

<br><br>

### 三、设值 & 位运算：[·](#目录)

<br>

**1.&nbsp; 设置指定索引处位的值：setbit**

1. 位值只能是0或1，其余直接报错.
2. 索引异常：
   1. 负数直接报错.
   2. 超出范围：末尾到指定索引之间全部置0，即使在指定索引处置的值是0也一样.
   3. 键不存在：0-指定索引之间全部设0，就是2.的一种特殊情况.
3. 返回指定索引处的旧值.

```Shell
setbit 键名 指定索引 位值
```

- 因此想快速得到一个长度为$len的空的字符串，可以：

```Shell
setbit 键名 $[ 8*$len - 1 ]
```

<br>

**2.&nbsp; 位操作：bitop**

```Shell
bitop 位运算类型 目标键名 操作键名1 [操作键名2 ...]
```

1. 将操作键值运算的结果存入目标键值.
2. 位运算类型包括：and、or、xor、not
   - 其中：not只能有1个操作数，否则报错，其余可以有多个操作数.
3. 只有not nil == nil，对于其余操作，nil都被看成所有位为0.
4. 返回目标键值最终的字符串长度.
