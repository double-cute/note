# 集合：set
> set，只能存放string类型元素，命令前缀为s.
>
>> 1. 元素不能重复. （list可以重复）
>> 2. 无序. （list维护插入顺序）
>> 3. 最多存放 **2^32 - 1** 个元素.
>>
>>> - 底层用hash表保存，因此插入、删除等的复杂度都是O(1).

<br><br>

## 目录

1. [工具命令](#一工具命令)
2. [增删元素](#二增删元素)
3. [获取集合中的所有元素](#三获取集合中的所有元素)
4. [集合运算](#四集合运算)
5. [随机命令](#五随机命令)

<br><br>

### 一、工具命令：[·](#目录)

<br>

**1.&nbsp; 获取集合中元素个数：**

```Shell
scard 键名
```

**2.&nbsp; 判断一个元素是否在集合中：**

- 返回：1/0状态码

```Shell
sismember 键名 指定元素
```

<br><br>

### 二、增删元素：[·](#目录)

<br>

- 都是返回实际添加/删除的元素个数.

```Shell
sadd|srem 键名 元素 [元素 ...]
```

<br><br>

### 三、获取集合中的所有元素：[·](#目录)

<br>

- 返回所有元素的值.

```Shell
smembers 键名
```

<br><br>

### 四、集合运算：[·](#目录)
> **统统不改变参与运算的原集合.**
>
>> - 都支持连续运算，例如sdiff k1 k2 k3，计算的就是k1 - k2 - k3.

<br>

**1.&nbsp; 临时结果：** 差、交、并

- 输出临时结果集合中的所有元素.

```Shell
sdiff 键名 [键名 ...]
sinter 键名 [键名 ...]
sunion 键名 [键名 ...]
```

<br>

**2.&nbsp; 将结果保存至另一个集合中：**

- 返回结果集合的元素个数.
   - 是覆盖到结果集合（即先删除原结果集合，在覆盖）.

```Shell
sdiffstore 目标键名 键名 [键名 ...]
sinterstore 目标键名 键名 [键名 ...]
sunionstore 目标键名 键名 [键名 ...]
```

<br><br>

### 五、随机命令：[·](#目录)

<br>

**1.&nbsp; 随机获得集合中的元素：**

1. 无count：随机获取1个元素.
2. 0 ≤ count ≤ size：随机获取count不同的元素，当count > size时count = size.
3. count < 0：随机获取|count|个可能重复的元素.
   - 返回结果列表.

```Shell
srandmember 键名 [个数count]
```

- 当count < 0时看上去结果可能 **并不是那么随机**，有些元素出现次数特别多，那是因为set底层的存储结构：
   1. set底层用hash表存，采用 **拉链法** 解决冲突. （桶中的槽位用链表存放）.
   2. 桶中的元素越少，那么该桶中的元素被选中的可能性就越大.
      - 实际上，算法的随机性还是非常均匀的.

<br>

**2.&nbsp; 随机从集合中弹出一个元素：**

- 弹出后返回被弹的元素，并删除该元素.

```Shell
spop 键名
```
