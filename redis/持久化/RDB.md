# RDB
> Redis不光可以作为高速缓存数据库，同样也可以将内存数据库中的数据持久化到硬盘中.
>
>> - Redis采用两种方式进行持久化（**双保险**）：
>>    1. RDB：Redis Database的缩写
>>       - 默认开启，并且必须（**强制**）使用的持久化方式.
>>       - 数据库文件是 **dump.rdb**. （**仅此一个文件，非常简约**）
>>          - **通过dir（.rdb的存储目录），dbfilename（为dump.rdb重命名）参数配置.**
>>       - 保存的是 **序列化的二进制数据**.  （**因此格式紧凑，占用空间得到了简化（压缩）**）
>>          - 序列化机制是：
>>             - 只能 **定时（在某个时间点，不能实时、不停、连续）** 将内存数据更新到dump.rdb中.
>>    2. AOF：Append Only File的缩写
>>       - 默认不开启，需要设置后才能开启此功能.
>>       - 数据库文件是 **appendonly.aof**.
>>       - 保存的是 **所有更改数据库内容的命令**，即 **记录命令的纯txt文本文件**.  （**因此占用空间较大**）
>>          - 序列化的机制是：
>>             - **实时、不停、连续** 地将 **每一条更改数据库内容的命令** 瞬时记录到.aof文件中.
>>             - 因此，在 **更改命令较频繁** 的情况下 **比较影响性能**.
>>
>> <br>
>>
>>> 通常两者配合使用：**双保险**
>>>
>>> 1. RDB速度快，但缺点就是：如果发生断电等极端异常情况时，**最后一次RDB快照** 到 **异常发生** 之间的所有更新数据都将丢失.
>>> 2. 而AOF是实时记录的，因此可以弥补上述RDB的数据丢失（用AOF来恢复）.
>>>
>>> - 通常的做法是，**每进行一次RDB快照就删除一次.aof，保证.aof只记录最近一次RDB快照之后的数据更新**.
>>>    - 这样可以最大程度减小磁盘的占用.

<br><br>

## 目录

1. [RDB快照类型](#一rdb快照类型)
2. [同步RDB快照：save](#二同步rdb快照save--)
3. [异步RDB快照](#三异步rdb快照)
4. [异步RDB快照的实现原理：写时复制](#四异步rdb快照的实现原理写时复制--)
5. [异步RDB快照的内存空间申请 & 压缩选项](#五异步rdb快照的内存空间申请--压缩选项)
6. [启动加载dump.rdb](#六启动加载dumprdb)

<br><br>

### 一、RDB快照类型：[·](#目录)
> RDB采用的是 **快照（Snapshotting）** 完成持久化的.
>
>> - 步骤是：
>>    1. 在特定时刻. （**可以通过配置指定，也可以主动输入命令来控制**）
>>    2. 将整个Redis内存的所有数据备份（快照）到硬盘上.
>>       - 写成一个临时文件，例如：dump.rdb.tmp
>>    3. 等 **完整的** 快照 **全部都写入** .tmp临时文件 **之后**，再用.tmp替换旧的dump.rdb
>>       - 因此，**无论何时dump.rdb都是完整的**，**可以通过备份dump.rdb来备份Redis数据库**.

<br>

- RDB快照的类型分为 **同步** 和 **异步**：
   1. 同步方式：同步快照时会阻塞客户端请求（即Stop The World，停止一切服务，专心快照）.
      - 优点：所有资源用来快照，可以加快快照的速度.
      - 缺点：服务被阻断，影响客户端的体验.
   2. 异步方式：Redis启动一个额外的后台线程在背后默默地快照，不影响前台对客户端的服务（仍然可以相应客户端）.
      - 优点：服务可以继续.
      - 缺点：由于资源被分开（一部分服务客户，一部分进行快照），因此双方性能都会受到一定影响.
         - 最大的缺点就是，只能持久化快照点那个时间点的数据，之后边快照边服务过程中数据库的更新无法被持久化.
            - 所以，还是无法做到完全同步客户端对数据库的更新，只有同步的方式才能做到这点（毕竟客户端都不能响应了嘛）.
- 小结：默认情况下还是用户体验高于一切，因此 **异步快照的方式是用得最多的方式**.

<br><br>

### 二、同步RDB快照：save  [·](#目录)

<br>

- 即单单一个 `save` 命令就搞定了.  （**手动**）
   - 该命令是同步快照，会阻塞客户端的请求.
   - 在数据量较大的情况下用户体验极差！

<br><br>

### 三、异步RDB快照：[·](#目录)

<br>

**1.&nbsp; 手动式：bgsave**

- 即Begin Save的缩写.

```Shell
# 1. 执行后返回状态信息：Background saving started，表示异步快照已经在后台开启
bgsave
# 2. 快照完成后并不会提示，必须使用下面的命令查看最近一次快照成功的Unix时间戳
lastsave  # 同样可以查看其它各种快照的成功时间点（save同步快照也行，所有都适用）
```

<br>

**2.&nbsp; 配置自动式：**

- 配置save参数

```Shell
# 表示60秒内被更改的键的个数 > 10000时自动隐式调用bgsave（不输出信息）
save 60 10000
# 一般式：window表示窗口时间，delta表示更改数量
save window delta
```

<br>

**3.&nbsp; 自动式的3种情况：**

1. **2.** 的配置.
2. 执行flushall命令：**有条件**
   - 前提是：配置save参数 **不为空**.
   - 执行flushall命令就回执行bgsave.
      - 该命令会清空所有Redis数据库（0~16）.
      - 如果save参数为空那就是彻底删除（dump.rdb也删了）.
         - 否则就快照到dump.rdb，只清空内存而已.
3. replication（数据库复制）时 **无条件强制执行bgsave**.

<br><br>

### 四、异步RDB快照的实现原理：写时复制  [·](#目录)
> 起始就是Unix的fork函数的功能而已（copy-on-write）.

<br>

1. 快照发生时Redis父进程fork出一个子进程.
2. 刚刚fork的时刻，父子进程共享相同的内存.
   - 就是 **用子进程的内存作为快照** 写入硬盘临时文件.
3. 在写入临时文件的过程中，父进程继续相应客户端.
4. 如果要更新数据，父进程就 **只复制出需要更改的那片局部内存** 进行修改.  （**即写时复制**）
   - 因此完全不影响子进程的内存空间.
5. 子进程写入完毕后，将临时文件替换旧的dump.rdb，同时父进程 **将更新的内存片和原来子进程的快照内存合并**.

<br>

- 写时复制的优点：
   - 很明显，父进程无须完全复制子进程的内存空间，以达到节省空间的目的.
      - 例如，当前Redis内存占用1.5G，异步快照时可能需要更改的内存大小只有0.5G，因此总内存只需占用2G.
         - 否则整个复制的话需要3G.

<br>

- **同步快照不需要写时复制，因为客户端请求被关闭，没有数据更新，就一个父进程即可，都不需要fork子进程.**

<br><br>

### 五、异步RDB快照的内存空间申请 & 压缩选项：[·](#目录)

<br>

**1.&nbsp; 由于异步RDB快照时需要写时复制（开辟额外的内存空间）：**

- 因此有可能发生这种情况：在快照之前内存还是够用的，但是快照的时候内存不够用了，直接内存穿透（OS卡死）.
   - 因此需要配置Unix系统，允许Redis申请超过可用空间的内存以防万一（物理内存 & swap）.

```Shell
$ sudo vim /etc/sysctl.conf  # 加入 vm.overcommit_memory = 1
# 然后重启，或者执行以下命令以确保设值生效
$ sudo sysctl vm.overcommit_memory=1
```

<br>

**2.&nbsp; dump.rdb文件默认采用一定的压缩算法压缩过的，因此实际占用空间比内存中的要小：**

- 但是压缩过程会消耗CPU资源，如果对性能要求特别苛刻，则可以在Redis配置中关闭该功能：

```Shell
rdbcompression no # 默认是yes
```

<br><br>

### 六、启动加载dump.rdb：[·](#目录)

<br>

- redis-server在启动时默认从 **唯一的数据库文件dump.rdb** 中加载数据到内存中.
   - 该过程必定执行.  （**完全自动，不需要开发者插手**）
      - 如果开启了AOF则从.aof文件中加载.
   - 性能优越，通常1000万个string键（1G左右）只需半分钟左右.
